{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Programa Tarjetas Electr\u00f3nicas de control para sistemas Mecatr\u00f3nicos 2023","text":"<p>Documentaci\u00f3n para el aprendizaje del Lenguaje C con un enfoque b\u00e1sico para quien no ha programado pero tiene nociones de algoritmos, y ahora tendr\u00e1 que aplicar ese conocimiento a un lenguaje en una tarjeta de control, en este caso para ESP32 con Arduino.</p>"},{"location":"#mapa-del-sitio","title":"Mapa del sitio","text":"<p>Capitulo 1</p> <p>Capitulo 2</p>"},{"location":"Referencias/","title":"Referencias","text":"<ul> <li>https://cplusplus.com/reference/</li> <li>https://docs.espressif.com/projects/arduino-esp32/en/latest/getting_started.html</li> <li>https://docs.espressif.com/projects/esp-idf/en/latest/esp32/hw-reference/esp32/get-started-devkitc.html#get-started-esp32-devkitc-board-front</li> <li>Datasheet</li> </ul>"},{"location":"simuladores/","title":"Simuladores","text":"<p>Para la simulaci\u00f3n del ESP32, tenemos algunas opciones, sin embargo, siempre de manera f\u00edsica sera mucho mejor.</p>"},{"location":"simuladores/#wokwi","title":"Wokwi","text":"<p>Es una simulador web para diversas plataformas, lenguajes, placas, microcontroladores.</p> <p></p>"},{"location":"simuladores/#picsimlab","title":"PicSimLab","text":"<p>Este simulador se basa en puros proyectos open source, los puedes compilar para cada plataforma. </p> <p>Tiene una version Web (pero es super lenta y pesada, esperemos en un futuro mejore). click aqu\u00ed, picsimlab web</p> <p></p>"},{"location":"Capitulo%201/","title":"Cap\u00edtulo 1","text":""},{"location":"Capitulo%201/#introduccion-al-lenguaje-c","title":"Introducci\u00f3n al Lenguaje C","text":"<p>De las cosas importantes que debemos saber del lenguaje C es que es unos los principales lenguajes que existen hoy en d\u00eda. </p> <p>Es la base de la mayor\u00eda de los lenguajes de alto nivel, por ejemplo JAVA, Python, est\u00e1n hechos con este lenguaje. Infinidad de aplicaciones y herramientas est\u00e1n realizadas con dicho lenguaje. El kernel de Linux esta escrito en <code>C</code>.</p> <p>De las cosas importantes a destacar son:</p> <ul> <li>Los archivos tienen la extension <code>.c</code> y <code>.h</code>.</li> <li>Es un lenguaje compilado</li> <li>Es un lenguaje tipado.</li> <li>Te permite una manipulaci\u00f3n libre de la memoria</li> <li>En extremo flexible</li> </ul> <p></p>"},{"location":"Capitulo%201/#mapa-del-sitio","title":"Mapa del sitio","text":""},{"location":"Capitulo%201/#nota-importante","title":"Nota importante!!!","text":"<p>En caso de no saber algoritmos, primero ir al sitio de Algoritmos para aprender y conocer, dado que aqu\u00ed te toma como que usted ya tiene ese conocimiento previo.</p>"},{"location":"Capitulo%201/01_variables/","title":"Variables","text":""},{"location":"Capitulo%201/01_variables/#que-es-una-variable","title":"\u00bfQu\u00e9 es una variable?","text":"<p>Una variable desde el punto de vista computacional, es un espacio en memoria con un nombre, es decir, un espacio determinado al momento de declarar la variable, se indica su tipo y cada tipo tiene cierto espacio en memoria. </p> <p>Es un espacio virtual el cual quedar\u00e1 registrado en la memoria; el cual se podr\u00e1 llamar en diferentes puntos de la programaci\u00f3n cuantas veces la necesitemos. A este espacio se le da un nombre que nos indique para qu\u00e9 ha sido creada. Las variables pueden tomar cualquier tipo de valor</p> <p>Variables</p> <pre><code>int edad = 20; //Variable que almacena un numero, la edad\nfloat altura = 1.7;\nchar letra = 'a';\nchar* nombre = \"Aprendiendo programaci\u00f3n\"; //Variable que almacena una frase (String)\nbool isAlive = true //Variable que almacena un valor booleano\n</code></pre>"},{"location":"Capitulo%201/01_variables/#que-es-declarar-una-variable","title":"Qu\u00e9 es declarar una variable?","text":"<p>La declaraci\u00f3n de una variable es reservar un espacio en memoria de la computadora. La computadora tiene cierta cantidad de memoria, la cual es repartida entre todos los programas y los propios procesos para ejecutar el sistema operativo. Cuando ejecutamos un programa, \u00e9ste comienza reservar memoria para poder trabajar. Entonces, al declarar variables estamos consumiendo memoria, la cual vamos a utilizar en alg\u00fan momento, si estamos reservando el espacio significa que en alg\u00fan otro momento necesitamos recuperar lo que hemos guardado para realizar otra operaci\u00f3n, de lo contrario no necesitamos reservar memoria si el valor solo ser\u00e1 utilizado una \u00fanica vez.</p>"},{"location":"Capitulo%201/01_variables/#como-nombrar-una-variable","title":"\u00bfC\u00f3mo nombrar una variable?","text":"<p>Dentro de la programaci\u00f3n existen buenas practicas para declarar variables. Estas reglas se definen a lo largo del tiempo que ha evolucionado. Estas son las reglas gen\u00e9ricas para (casi) todos lenguajes. </p> <ul> <li>Deben comenzar en min\u00fascula</li> <li>Se escriben en min\u00fasculas, las variantes se dan cuando son m\u00e1s de dos palabras.</li> <li>Solo puede contener n\u00fameros despu\u00e9s de la primera letra.</li> <li>Sensibles a min\u00fasculas y may\u00fasculas; es decir, si declaro una variable llamada <code>variable1</code> y otra llamada <code>Variable1</code>, para la computadora son variables o espacios de memoria distintos, aun que suenen igual, con el solo hecho de cambiar una letra, ya estamos hablando de una variable distinta.</li> <li>No pueden contener espacios entre letras o palabras</li> <li>No puede comenzar con n\u00fameros o s\u00edmbolos</li> <li>No puede contener caracteres especiales, todos son caracteres especiales menos el abecedario ingles. Ejemplo: <code>!\"\u00b7%&amp;-+/()=?\u00bf...</code>, los \u00fanicos s\u00edmbolos permitidos son <code>$</code> y <code>_</code>.</li> <li>El nombre debe ser descriptivo; es decir, con solo leerlo podemos deducir qu\u00e9 hace o para qu\u00e9 fue declarada</li> <li>(Regla especial): Todo de escribe en ingles.</li> <li>(Regla especial): Si se desea escribir una variable combinando dos palabras o m\u00e1s, se hace comenzando la siguiente palabra con mayuscula y todo pegado, a esto se le conoce como la convenci\u00f3n <code>CamelCase</code>.</li> <li>Ejemplos:<ul> <li><code>valor</code></li> <li><code>valor1</code></li> <li><code>valorUno</code></li> <li><code>variableNueva</code></li> </ul> </li> </ul>"},{"location":"Capitulo%201/02_tipos_datos/","title":"Tipos de datos","text":"<p>Los tipos de datos son la manera en la que vamos a decirle al programa el tama\u00f1o de la variable y al mismo momento</p> Nombre Tipo Tama\u00f1o Rango byte <code>byte</code> 8 bits = 1 byte -128 a 127 o 0 a 255 Car\u00e1cter sin signo <code>unsigned char</code> 1 byte 0 hasta 255 Car\u00e1cter con signo <code>char</code> 1 byte -128 hasta 127 Entero corto sin signo <code>unsigned short int</code> o <code>unsigned short</code> 2 bytes 0 a 65,535 Entero corto con signo <code>short int</code> 2 bytes -32,768 a +32,767 Entero con signo <code>int</code> 4 bytes -2,147,483,648 a +2,147,483,647 Entero largo <code>long int</code> 4 bytes -2,147,483,648 a +2,147,483,647 Entero largo sin signo <code>long long int</code> 8 bytes 9,223,372,036,854,775,808 al +9,223,372,036,854,775,807 Flotante <code>float</code> 4 bytes -3.4\u00b3\u2078 al  +3.4\u00b3\u2078 Doble <code>double</code> 8 bytes -1.7\u00b3\u2070\u2078 al +1.7\u00b3\u2070\u2078 Doble largo <code>long double</code> 12 bytes -1.9\u2074\u2079\u00b3\u00b2 al +1.9\u2074\u2079\u00b3\u00b2 <p>Nota</p> <p>El tipo de dato que aplicara esta en funci\u00f3n de que tan grande sera el valor que contendr\u00e1. Es decir, si el valor no pasar\u00e1 de 255 y entero, podemos usar un tipo <code>char</code>, pero si el valor que podr\u00e1 ser hasta 1,000,000 pues seleccionamos el tipo <code>long int</code>.</p> <pre><code>char i = 0;\nint valor = 20000;\nfloat altura = 1.8;\n</code></pre>"},{"location":"Capitulo%201/02_tipos_datos/#comentarios","title":"Comentarios","text":"<p>Siempre que escribimos un c\u00f3digo queremos colocar un comentario con respecto a lo que hace el programa o dejarnos una nota para nuestro yo del futuro, obviamente estos comentarios no le interesa al compilador o al programa, es para nosotros.</p> <p>Hay dos maneras de indicar un comentario, que son comentarios en l\u00ednea o multil\u00ednea</p>"},{"location":"Capitulo%201/02_tipos_datos/#comentarios-de-una-sola-linea","title":"Comentarios de una sola l\u00ednea","text":"<p>La forma de indicar un comentario de una l\u00ednea es usando doble diagonal hacia adelante (<code>//</code>).</p> <pre><code>// comentario de una l\u00ednea\nint edad = 3; // //en esta variable guardo el valor de 3\n</code></pre> <p>Todo lo que se escribe delante de <code>//</code> el compilador lo comienza a tomar como comentario, aun asi tenga c\u00f3digo correcto y propio del lenguaje, dado que al saber que es un comentario lo va a ignorar.</p>"},{"location":"Capitulo%201/02_tipos_datos/#comentarios-multilinea","title":"Comentarios multil\u00ednea","text":"<p>La forma de indicar un comentario multi l\u00ednea es envolverlo con una diagonal con un asterisco y cierra con un asterisco y una diagonal (<code>/**/</code>).</p> <p>Una de las ventajas es que se puede colocar codigo en cualquier parte sin ser parte del codigo.</p> <pre><code>/*\n* En esta secci\u00f3n se toma como un bloque de comentario\n* Todo lo que esta escrito el compilador lo ignora porque \n* es una indicaci\u00f3n para nosotros\n*/\n\nint valor = 5; /*tambi\u00e9n se puede ocupar como de una l\u00ednea, lo importante es que este envuelto entre los s\u00edmbolos correspondientes*/\n\nfloat /*tipo de variable*/ altura /*nombre de variable*/ = 1.782; \n</code></pre>"},{"location":"Capitulo%201/03_declaracion_de_variables/","title":"\u00bfC\u00f3mo se declaran las variables ?","text":"<p>Cada lenguaje tiene su sintaxis de declaraci\u00f3n de variables, en nuestro que es <code>lenguaje C</code>, es la siguiente manera:</p> <p>Sintaxis:</p> <pre><code>tipoDeDato nombreVariable = valor;\n</code></pre> <p>Ejemplos:</p> <p><pre><code>int edad = 10;\nfloat altura = 1.4;\nchar letra = 'a';\nbool isLleno = true; // se debe importar el header &lt;stdbool.h&gt;\nchar* nombre =  \"Programacion en C\";\nint myDec = 50/* notaci\u00f3n decimal  */\nint myOct = 062; /* notaci\u00f3n octal (0) */\nint myHex = 0x32; /* notaci\u00f3n hexadecimal (0x) */\n</code></pre> A continuaci\u00f3n se muestra todas las partes de declaraci\u00f3n de variable:</p> <p></p>"},{"location":"Capitulo%201/03_declaracion_de_variables/#declaracion-de-constantes","title":"Declaraci\u00f3n de constantes","text":"<p>En ocasiones necesitamos declarar una variable que nunca cambie su valor, para eso existe que se vuelva constante, en el caso de <code>C</code>, se cuenta con la palabra reservada <code>const</code> al momento de declarar la variable. Esto lo que hace que una vez sea declarada, nunca mas podr\u00e1 cambiar su valor.</p> <p>La forma de declarar una constante es la siguiente:</p> <pre><code>const tipo_de_dato NOMBRE = valor;\n</code></pre> <p>Observe que ahora la convenci\u00f3n de Camel Case indica que una constante debe ser nombrada en may\u00fasculas, en caso de contar con mas de 2 palabras se van separando con guion bajo (<code>_</code>). Con ello, al momento de verla sabremos que es una constante y ese valor no se puede modificar.</p> <pre><code>const float PI = 3.141592; // declaramos la constante de pi\nconst MAYOR_DE_EDAD = 18; // declaramos el valor para una constante para comprar cuando sea mayor de edad, este valor pues nunca cambiara\n</code></pre> <p>Nota</p> <p>Existe otra manera en cierta manera mas adecuada de definir constantes que se vera mas adelante (Spoiler: Es un preprocesador (<code>#define</code>))</p>"},{"location":"Capitulo%201/04_estructura_archivo/","title":"Estructura de archivo C b\u00e1sica","text":"<p>De primera instancia si nunca haz programado es muy extra\u00f1o ver muchas cosas en un archivo que pr\u00e1cticamente no hace nada; sin embargo, debemos asimilarlo y tomarlo como una verdad absoluta, dado que para entenderlo hay que recorrer un poco el camino, hasta que cada linea toma todo el sentido del mundo.</p> <p>Con esto pasamos a ver la estructura base que llevara casi todos los archivo en C y mas los que comenzaremos a hacer</p> <pre><code>// nombre del archivo debe ser main.c\n#include &lt;stdio.h&gt;\n\n// funci\u00f3n main\nint main(void){// inicia funci\u00f3n main\n\n    // aqu\u00ed va todo nuestro c\u00f3digo\n\n    return 0; // el valor de retorno de la funci\u00f3n main\n}// termina la funci\u00f3n main\n</code></pre> <p>La estructura anterior por el momento SIEMPRE se escribir\u00e1 as\u00ed, sin preguntar nada y respetando cada s\u00edmbolo en \u00e9l.</p> <p>Por convenci\u00f3n el nombre del archivo en donde va la <code>funci\u00f3n main</code> se llamar\u00e1 <code>main.c</code>. La extension de los archivos en C, es <code>.c</code>; posteriormente aprenderemos que hay otras y tienen otro motivo.</p> <p>Warning</p> <p>Por el momento no se escribir\u00e1 NADA de NADA fuera de las llaves de la funci\u00f3n, esta estrictamente prohibido colocar algo (ya prenderemos d\u00f3nde, c\u00f3mo y porqu\u00e9). Por el momento ten f\u00e9 ciega \ud83d\ude04.</p>"},{"location":"Capitulo%201/04_estructura_archivo/#sintaxis","title":"Sintaxis","text":"<p>La sintaxis en un lenguaje es como saber las reglas ortogr\u00e1fica de cualquier idioma. Cada lenguaje de programaci\u00f3n tiene la suya, en este caso en C tiene sus reglas:</p> <p><pre><code>// main.c\n#include &lt;stdio.h&gt;\n\n// funci\u00f3n main\nint main(void){\n\n    printf(\"Hola Mundo\");\n\n    return 0;\n}\n</code></pre> </p>"},{"location":"Capitulo%201/05_salida_datos/","title":"Salida de datos (funci\u00f3n printf)","text":"<p>Lo primero que aprenderemos es como mandar mensajes a la consola o terminal, y es utilizando la funci\u00f3n <code>printf();</code>. Como se muestra en el siguiente ejemplo:</p> <pre><code>// main.c\n#include &lt;stdio.h&gt; // se debe importar la librer\u00eda est\u00e1ndar de entradas y salidas para poder usar printf, de lo contrario marcara un error al compilar\n\n// funci\u00f3n main\nint main(void){\n\n    printf(\"Hola Mundo\");\n\n    return 0;\n}\n</code></pre> <p>La funci\u00f3n <code>printf</code> nos sirve para mandar informaci\u00f3n a la consola, tiene manera especiales para escribir los tipos de datos y ademas tiene caracteres especiales que se detallan a continuaci\u00f3n.</p>"},{"location":"Capitulo%201/05_salida_datos/#secuencias-de-escape","title":"Secuencias de escape","text":"<p>Las secuencias de escape son caracteres especiales para <code>printf</code>, que no se puden colocar de manera cotidiana porque para C significa otra cosa, por lo tanto, dicho car\u00e1cter se debe escapar; es decir, agregar un back slash al principio <code>\\</code>. </p> S\u00edmbolo Significado <code>\\n</code> Linea nueva - Enter <code>\\t</code> un tabulador <code>\\r</code> Regresa el cursor al inicio - Retorno de carro <code>\\\\</code> Back slash <code>\\\"</code> Dobles Comillas <code>\\'</code> Comillas simple"},{"location":"Capitulo%201/05_salida_datos/#ejemplos-con-secuencias-de-escape","title":"Ejemplos con secuencias de escape","text":"<p>Aplicando las secuencias de escape</p> <p><pre><code>printf(\"Hola\\nMundo\");\n</code></pre> <pre><code>Hola\nMundo\n</code></pre></p> <p><pre><code>printf(\"Hola\\tMundo\");\n</code></pre> <pre><code>Hola    Mundo\n</code></pre></p> <p><pre><code>printf(\"\\\"Hola Mundo\\\"\");\n</code></pre> <pre><code>\"Hola Mundo\"\n</code></pre></p> <p><pre><code>printf(\"\\'Hola Mundo\\'\");\n</code></pre> <pre><code>'Hola Mundo'\n</code></pre></p>"},{"location":"Capitulo%201/05_salida_datos/#especificadores-de-formato","title":"Especific\u00e1dores de formato","text":"<p>En <code>C</code> no se puede mandar a imprimir de manera directa una variable, se de usar un especificador de formato adecuado al tipo de variable que se quiere mandar a la salida.</p> <p>Se debe utilizar el s\u00edmbolo de <code>%</code> seguido de la letra que le corresponde al tipo de variable:</p> Especificador de formato Tipo de variable Nombre <code>%i</code>, <code>%d</code> <code>int</code>, <code>short</code> N\u00famero entero <code>%f</code> <code>float</code> N\u00famero real <code>%c</code> <code>char</code> Car\u00e1cter <code>%o</code> <code>int</code> Octal <code>%x</code> <code>int</code> Hexadecimal <code>%i</code> <code>char</code> El valor ASCII del car\u00e1cter <code>%s</code> <code>string</code>.<code>char*</code>, <code>char[]</code> Cadena de caracteres <code>%Lf</code> <code>long double</code> Flotante doble largo <code>%lld</code> <code>long long int</code> Entero largo <code>%u</code> <code>unsigned char</code>,<code>unsigned short</code>, <code>unsigned int</code> Enteros sin signo <code>%lu</code> <code>unsigned long int</code> Entero sin signo <code>%llu</code> <code>unsigned long long int</code> Entero sin signo <code>%p</code> <code>*</code> Direcci\u00f3n de puntero <pre><code>uint8_t valor = 2;\nint edad = 13;\nfloat altura = 1.73;\nchar arroba = '@';\nchar* frase = \"Hola Mundo\";\n\nprintf(\"%i \\n\", edad);\nprintf(\"%f \\n\", altura);\nprintf(\"%c \\n\", arroba);\nprintf(\"%s \\n\", frase);\nprintf(\"%d \\n\", valor);\n</code></pre> <pre><code>13 \n1.730000 \n@ \nHola Mundo \n2 \n</code></pre>"},{"location":"Capitulo%201/06_operaciones_aritmeticas/","title":"Operaciones","text":""},{"location":"Capitulo%201/06_operaciones_aritmeticas/#operadores-aritmeticos","title":"Operadores aritm\u00e9ticos","text":"<p>En esta secci\u00f3n veremos los operadores aritm\u00e9ticos b\u00e1sicos que podemos encontrar en la mayor\u00eda de lenguajes.</p> Nombre S\u00edmbolo Descripci\u00f3n Agrupaci\u00f3n <code>()</code> Realiza la operaci\u00f3n de agrupaci\u00f3n de una operaci\u00f3n. (NO MULTIPLICA) Suma <code>+</code> Realiza la operaci\u00f3n de suma aritm\u00e9tica Resta <code>-</code> Realiza la operaci\u00f3n de resta aritm\u00e9tica Multiplicaci\u00f3n <code>*</code> Realiza la operaci\u00f3n de multiplicaci\u00f3n aritm\u00e9tica Divisi\u00f3n <code>/</code> Realiza la operaci\u00f3n de raz\u00f3n aritm\u00e9tica Residuo o M\u00f3dulo <code>%</code> Realiza la operaci\u00f3n de divisi\u00f3n aritm\u00e9tica y devuelve el residuo de \u00e9sta divisi\u00f3n <p>Cuando somos nuevos en el mundo de la programaci\u00f3n queremos aplicar conocimiento que tenemos con relaci\u00f3n a matem\u00e1ticas, aqu\u00ed existen algunas cuestiones que no se aplican de la misma manera o solo se puede aplicar de cierta forma.</p> <p>Precauciones que debemos tener en cuenta son:</p> <ul> <li>El \u00fanico s\u00edmbolo que podemos ocupar para la divisi\u00f3n es la diagonal o slash (/), no existe otro s\u00edmbolo ni tampoco se puede ocupar los tradicionales que conocemos.</li> <li>El \u00fanico s\u00edmbolo para multiplicaci\u00f3n es el asterisco (*), no existe alg\u00fan otro ni ninguno m\u00e1s sirve para multiplicar.</li> <li>Los par\u00e9ntesis \"( )\" solo agrupan y nada mas. No sirven para multiplicar. </li> </ul> <p><pre><code>int valor1 = 4;\nint valor2 = 3;\n\nint suma = valor1 + valor2;\nint resta = valor1 - valor2;\nint multiplicacion = valor1 * valor2;\nint division = valor1 / valor2;\nint modulo = valor1 % valor2;\n\nprintf(\"La suma es %i \\n\", suma);\nprintf(\"La resta es %i \\n\", resta);\nprintf(\"La multiplicaci\u00f3n es %i \\n\", multiplicacion);\nprintf(\"La divisi\u00f3n es %i \\n\", division);\nprintf(\"El residuo es %i \\n\", modulo);\n</code></pre> Resultado:</p> <pre><code>La suma es 7 \nLa resta es 1 \nLa multiplicaci\u00f3n es 12 \nLa divisi\u00f3n es 1 \nEl residuo es 1 \n</code></pre>"},{"location":"Capitulo%201/06_operaciones_aritmeticas/#operador-unitario-","title":"Operador unitario (-)","text":"<p>Existe el operador unitario el cual no necesita hacer una operaci\u00f3n entre dos valores o variables, con agregarlo estar\u00eda realizando la operaci\u00f3n de multiplicar por -1.</p> <p><pre><code>int valor = 4;\nint inverso = -valor; // aqu\u00ed aplicamos el operador unitario\n\nprintf(\"valor: %d\\n\", valor);\nprintf(\"valor negativo: %d\\n\", inverso);\n</code></pre> Resultado:</p> <pre><code>valor: 4\nvalor negativo: -4\n</code></pre>"},{"location":"Capitulo%201/06_operaciones_aritmeticas/#operador-de-asignacion","title":"Operador de asignaci\u00f3n (=)","text":"<p>El operador de asignaci\u00f3n (<code>=</code>), el cual asigna un valor a una variable.</p> <p>Danger</p> <p>No es lo mismo asignar que igualar; es decir, en programaci\u00f3n se guardar un dato en una direcci\u00f3n de memoria, e igualar se usa en matem\u00e1ticas.</p>"},{"location":"Capitulo%201/06_operaciones_aritmeticas/#precedencia-de-operadores","title":"Precedencia de operadores","text":"<p>En C, la expresiones son normalmente evaluador de izquierda a derecha. Sin embargo, cuando una expresi\u00f3n contiene multiples operadores, la precedencia de decide el orden en el cual ser\u00e1n evaluados. Este orden es aplicable a otros muchos lenguajes como C++, C#, Java.</p> Orden Operador 1 <code>()</code>, <code>[]</code>, <code>.</code>, <code>-</code>, <code>&gt;</code>, <code>x++</code>, <code>x--</code> 2 <code>!</code>, <code>~</code>,<code>++x</code>,<code>--x</code>, <code>(type) sizeof * &amp;</code> 3 <code>*</code>,<code>/</code>,<code>%</code> 4 <code>+</code>,<code>-</code> 5 <code>&lt;&lt;</code>,<code>&gt;&gt;</code> 6 <code>&lt;</code>,<code>&lt;=</code>,<code>&gt;</code>, <code>&gt;=</code> 7 <code>==</code>,<code>!=</code> 8 <code>&amp;</code> 9 <code>^</code> 10 <code>|</code> 11 <code>&amp;&amp;</code> 12 <code>||</code> 13 <code>=</code> 14 <code>,</code> <p>Nota</p> <p>Con respecto a las operaciones matem\u00e1ticas que conoces, sigue funcionando igual, ahora debes a\u00f1adir las relacionadas al lenguaje.</p>"},{"location":"Capitulo%201/06_operaciones_aritmeticas/#ejercicios-con-operadores-aritmeticos","title":"Ejercicios con operadores aritm\u00e9ticos","text":""},{"location":"Capitulo%201/07_entrada_datos_scanf/","title":"Leyendo datos del usuario - Funci\u00f3n scanf()","text":"<p>Para ir mejorando nuestros programas, que sean din\u00e1micos y mucho mas funcionales, debemos recibir informaci\u00f3n por parte del usuario. Para ello una manera es leyendo datos de teclado que ingresa el usuario, y esto es lo que nos permite realizar la funci\u00f3n <code>scanf()</code>. Que podr\u00edamos decir que complementa a la funci\u00f3n <code>printf()</code>.</p> <p>En la siguiente imagen se ve como cada parte de la sentencia:</p> <p></p> <p>En el siguiente ejemplo vemos como quedar\u00eda un c\u00f3digo:</p> <pre><code>int edad = 0;\n\nprintf(\"Dar el valor de la tu edad\");\nscanf(\"%d\", &amp;edad); //recibo el dato y lo almaceno en edad\n\nint edadNueva = edad + 5; // hago una operaci\u00f3n con este valor \n\nprintf(\"Tu edad en 5 anios sera de: %d\"d, edadNueva);// Recuerda que los s\u00edmbolos del abecedario ingles no tiene la e\u00f1e, y no podemos poner de manera directa ese s\u00edmbolo especial\n</code></pre>"},{"location":"Capitulo%201/08_decisiones_1/","title":"Introducci\u00f3n a Decisiones (if)","text":"<p>Ya que sabemos como declarar variables (sentencia), imprimir por pantalla, solicitar valores al usuario; debemos hacer m\u00e1s din\u00e1mico nuestro programa, y la primer forma de hacerlo es tomando una decisi\u00f3n (una comparaci\u00f3n).</p> <p>Para esto es la condici\u00f3n <code>if</code> (<code>si</code>) o estructura de decision <code>if</code></p> <p>La sintaxis de la estructura <code>if</code> b\u00e1sica es la siguiente:</p> <p></p>"},{"location":"Capitulo%201/08_decisiones_1/#operadores-de-relacion","title":"Operadores de relaci\u00f3n","text":"<p>Los operadores de relaci\u00f3n te dan unicamente dos respuesta (l\u00f3gicas) <code>si</code> o <code>no</code>, que son equivalentes a <code>true</code> o <code>false</code> (booleano), <code>uno</code> o <code>cero</code>, <code>1</code> o <code>0</code> (digitales), <code>0V</code> o <code>5V</code> (voltaje)respectivamente.</p> Nombre Matem\u00e1ticas Lenguaje C <code>Menor que</code> <code>&lt;</code> <code>&lt;</code> <code>Menor o igual que</code> <code>\u2264</code> <code>&lt;=</code> <code>Mayor que</code> <code>&gt;</code> <code>&gt;</code> <code>Mayor o igual que</code> <code>\u2265</code> <code>&gt;=</code> <code>Igual que</code> <code>=</code> <code>==</code> <code>Diferente que</code> <code>\u2260</code> <code>!=</code>"},{"location":"Capitulo%201/08_decisiones_1/#sintaxis-de-comparacion","title":"Sintaxis de comparaci\u00f3n","text":"<p>La forma en la que se escriben las comparaciones es:</p> Izquierda Centro Derecha <code>valor/variable</code> <code>operador</code> <code>valor/variable</code> <code>5</code> <code>==</code> <code>8</code> <code>a</code> <code>&gt;=</code> <code>b</code> <code>10</code> <code>&lt;=</code> <code>x</code> <code>a</code> <code>&lt;=</code> <code>2</code>"},{"location":"Capitulo%201/08_decisiones_1/#ejemplos-de-comparacion","title":"Ejemplos de comparaci\u00f3n","text":"<p>Las \u00fanicas comparaciones que se pueden realizar son entre n\u00fameros, con respecto a las letras o car\u00e1cter (\u00fanico), la comparaci\u00f3n es en su valor ASCII, en si los textos no se pueden comparar; sin embargo, aplicado a un lenguaje en concreto esto puede variar.</p> Comparaci\u00f3n Resultado <code>5 &gt; 8</code> false <code>10 &gt; 8</code> true <code>20 &gt; 5</code> false <code>8 &gt;= 8</code> true <code>6 &lt; 8</code> true <code>2 &lt;= 8</code> true <code>0 == 8</code> false <code>1 != -8</code> true <p>Las comparaciones pueden ser entre variables, obviamente dicha variable debe contener un valor previamente.</p> <p>En  este caso las variables tienen este valor:</p> <ul> <li><code>a = 5</code> </li> <li><code>b = 2</code> </li> </ul> Comparaci\u00f3n Resultado <code>a &gt; b</code> true <code>a &gt;= b</code> true <code>a &lt; b</code> false <code>a &lt;= b</code> false <code>a == b</code> false <code>a != b</code> true"},{"location":"Capitulo%201/08_decisiones_1/#aplicando-la-estructura-if","title":"Aplicando la estructura if","text":"<p>Ahora veremos c\u00f3digo de ejemplo con la estructura <code>if</code></p> <pre><code>int edad = 18;\n\n\nif (edad &gt;= 18){ // comparamos si la variable edad es mayor o igual a 18, en caso que sea verdadero se mostrara el texto\n    printf(\"Eres mayor de edad\");\n}\n\nif (edad &lt; 18){ // comparamos la variable\n    printf(\"Eres menor de edad\");\n}\n</code></pre>"},{"location":"Capitulo%201/09_decisiones_2/","title":"Decisiones (if-else)","text":""},{"location":"Capitulo%201/10_ciclos_1/","title":"Introducci\u00f3n a ciclos (while)","text":""},{"location":"Capitulo%201/11_ciclos_2/","title":"Ciclos (for)","text":""},{"location":"Capitulo%201/12_arreglos/","title":"Arreglos (arrays)","text":""},{"location":"Capitulo%201/13_funciones/","title":"Funciones","text":""},{"location":"Capitulo%201/Ejemplos/","title":"Ejemplos","text":"<ol> <li>Imprimir \"Hola mundo\"</li> <li>Imprimir una frase usando secuencias de escape para que entre palabras se haga un salto de l\u00ednea</li> <li>Sumar 2 n\u00fameros e imprimir el resultado</li> <li></li> </ol>"},{"location":"Capitulo%201/Ejercicios/","title":"Ejercicios","text":"<ul> <li>Convertidor de temperatura de Fahrenheit a Celsius. \\(C=\\frac{5}{9}(F - 32)\\)</li> </ul>"},{"location":"Capitulo%201/Ejercicios/#ciclos","title":"Ciclos","text":"<ul> <li>Imprimir una tabla de equivalencia de temperaturas de Celsius y Fahrenheit. Desde 0\u00baC hasta 100\u00baC.</li> </ul>"},{"location":"Capitulo%202/","title":"Arduino con ESP32","text":"<p>...</p>"},{"location":"Capitulo%202/00_introduccion/","title":"Introducci\u00f3n a Arduino con ESP32","text":"<p>El ecosistema Arduino esta compuesto por una tarjeta con un microcontrolador y los perif\u00e9ricos necesarios m\u00ednimos para operar, el cual contiene un firmware para comunicarse y carga los programas realizados en C. Esta placa trabaja en conjunto con un IDE (Entorno de Desarrollo Integrado) el cual facilita la carga y depuraci\u00f3n de los programas realizados. </p> <p>El lenguaje que utiliza el entorno Arduino es C/C++, el cual nos ayuda a desarrollar nuestro programa y con ello desarrollar un prototipo r\u00e1pido.</p> <p>Todo este entorno es Open Source y Open Hardware, gracias a ello existe mucha comunidad desarrollando <code>mods</code>, <code>shields</code>, variantes de tarjetas, con el firmware que se acopla al entorno de Arduino.</p> <p>En este caso usaremos la tarjeta <code>ESP32 Dev Kit</code>, la cual tiene un microcontrolador <code>ESP32</code> de la empresa <code>espressif</code>.</p>"},{"location":"Capitulo%202/00_introduccion/#descripcion-general","title":"Descripci\u00f3n general","text":"<p>En la siguiente imagen y la tabla se describe los componentes clases, interfaces y controles de la tarjeta ESP32-DevKitC V4.</p> <p></p> Componente clave Descripci\u00f3n ESP32-WROOM-32 Un modulo con un ESP32 en el n\u00facleo. Para mas informaci\u00f3n ver el datasheet EN Bot\u00f3n de Reset Boot Download button. Holding down Boot and then pressing EN initiates Firmware Download mode for downloading firmware through the serial port. Puente USB a UART Single USB-UART bridge chip provides transfer rates of up to 3 Mbps. Puerto micro USB USB interface. Power supply for the board as well as the communication interface between a computer and the ESP32-WROOM-32 module. LED de alimentaci\u00f3n de 5V Turns on when the USB or an external 5V power supply is connected to the board. For details see the schematics in Related Documents. I/O Most of the pins on the ESP module are broken out to the pin headers on the board. You can program ESP32 to enable multiple functions such as PWM, ADC, DAC, I2C, I2S, SPI, etc."},{"location":"Capitulo%202/00_introduccion/#opciones-de-fuente-de-alimentacion","title":"Opciones de fuente de alimentaci\u00f3n","text":"<p>Hay 3 formas mutuamente exclusivas para darle alimentaci\u00f3n a la tarjeta:</p> <ul> <li>Puerto micro USB, por default es por este medio</li> <li>5V / GND header pins</li> <li>3V3 / GND header pins</li> </ul>"},{"location":"Capitulo%202/00_introduccion/#conector-j2-izquierdo","title":"Conector J2 (Izquierdo)","text":"No Nombre Tipo<sup>1</sup> Descripci\u00f3n 1 3V3 P Fuente de alimentaci\u00f3n de 3.3V 2 EN I CHIP_PU, Reset 3 VP I GPIO36, ADC1_CH0, S_VP 4 VN I GPIO39, ADC1_CH3, S_VN 5 IO34 I GPIO34, ADC1_CH6, VDET_1 6 IO35 I GPIO35, ADC1_CH7, VDET_2 7 IO32 I/O GPIO32, ADC1_CH4, TOUCH_CH9, XTAL_32K_P 8 IO33 I/O GPIO33, ADC1_CH5, TOUCH_CH8, XTAL_32K_N 9 IO25 I/O GPIO25, ADC1_CH8, DAC_1 10 IO26 I/O GPIO26, ADC2_CH9, DAC_2 11 IO27 I/O GPIO27, ADC2_CH7, TOUCH_CH7 12 IO14 I/O GPIO14, ADC2_CH6, TOUCH_CH6, MTMS 13 IO12 I/O GPIO12, ADC2_CH5, TOUCH_CH5, MTDI 14 GND G Ground (Tierra) 15 IO13 I/O GPIO13, ADC2_CH4, TOUCH_CH4, MTCK 16 D2 I/O GPIO9, D2<sup>2</sup> 17 D3 I/O GPIO10, D3<sup>2</sup> 18 CMD I/O GPIO11, CMD<sup>2</sup> 19 5V P Fuente de alimentaci\u00f3n de 5V"},{"location":"Capitulo%202/00_introduccion/#conector-j3-derecho","title":"Conector J3 (Derecho)","text":"No Nombre Tipo<sup>1</sup> Descripci\u00f3n 1 GND G Ground (Tierra) 2 IO23 I/O GPIO23 3 IO22 I/O GPIO22 4 TX I/O GPIO1, U0TXD 5 RX I/O GPIO3, U0RXD 6 IO21 I/O GPIO21 7 GND G Ground (Tierra) 8 IO19 I/O GPIO19 9 IO18 I/O GPIO18 10 IO5 I/O GPIO5 11 IO17 I/O GPIO17<sup>3</sup> 12 IO16 I/O GPIO16<sup>3</sup> 13 IO4 I/O GPIO4, ADC2_CH0, TOUCH_CH0 14 IO0 G GPIO0, ADC2_CH1, TOUCH_CH1, Boot 15 IO3 I/O GPIO3 16 IO15 I/O GPIO15, ADC2_CH3, TOUCH_CH3, MTDO 17 D1 I/O GPIO8, D1<sup>2</sup> 18 D0 I/O GPIO7, D0<sup>2</sup> 19 CLK P GPIO6, CLK<sup>2</sup> <p>[1] (1,2): P: Fuente de alimentaci\u00f3n; I: Input, O: Output</p> <p>[2] (1,2,3,4,5,6): The pins D0, D1, D2, D3, CMD and CLK are used internally for communication between ESP32 and SPI flash memory. They are grouped on both sides near the USB connector. Avoid using these pins, as it may disrupt access to the SPI flash memory / SPI RAM.</p> <p>[3] (1,2): The pins GPIO16 and GPIO17 are available for use only on the boards with the modules ESP32-WROOM and ESP32-SOLO-1. The boards with ESP32-WROVER modules have the pins reserved for internal use.</p>"},{"location":"Capitulo%202/00_introduccion/#pinout","title":"Pinout","text":""},{"location":"Capitulo%202/00_introduccion/#diagrama-esquematico","title":"Diagrama esquem\u00e1tico","text":"<p>Ver pdf original</p> <p>Esta informaci\u00f3n fue extra\u00edda de la documentaci\u00f3n oficial</p>"},{"location":"Capitulo%202/01_estructura/","title":"Estructura de c\u00f3digo base Arduino","text":"<p>El c\u00f3digo Arduino es de base es lenguaje <code>C/C++</code>, toda la sintaxis, estructura, etc. Pero, para facilitar la incursion en el ecosistema Arduino dise\u00f1o un estructura base que se divide en dos funciones principales, llamada <code>setup()</code> y <code>loop()</code>. Aqu\u00ed no vemos la funci\u00f3n <code>main()</code> porque esta ha sido abstra\u00edda para evitar mayores detalles, sin embargo, si existe en el programa principal pero no lo vemos.</p> <p>Regresando a la estructura de Arduino y sus funciones principales <code>setup()</code> y <code>loop()</code></p>"},{"location":"Capitulo%202/01_estructura/#la-funcion-setup","title":"La funci\u00f3n setup","text":"<p>La finalidad de esta funci\u00f3n es configurar pines, inicializar sensores, m\u00f3dulos, comunicaci\u00f3n serial, pantallas, etc.</p> <p>Esta funci\u00f3n es la primera en ejecutarse y solo una vez</p>"},{"location":"Capitulo%202/01_estructura/#la-funcion-loop","title":"La funci\u00f3n loop","text":"<p>La finalidad de esta funci\u00f3n es realizar todas las tareas colocadas aqu\u00ed de manera infinita (por eso se llama loop). Lo que vayamos a colocar aqu\u00ed se repetira, realizando todas las tareas indicadas en el codigo, aqui mandamos los diferentes mensajes a pantallas, leemos constantemente los sensores, etc.</p> <p>Esta funci\u00f3n es la ultima en ejecutarse y se repetir\u00e1 de manera infinita todo el c\u00f3digo que este aqu\u00ed</p> <pre><code>// the setup function runs once when you press reset or power the board\nvoid setup() {\n  // secci\u00f3n de configuraci\u00f3n e inicializaci\u00f3n de todo tipo\n}\n\n// the loop function runs over and over again forever\nvoid loop() {\n    /*aqu\u00ed todo el c\u00f3digo que queremos que se repita por siempre;\n    es decir, las tareas que desarrollara el microcontrolador y realizar por siempre\n    */\n}\n</code></pre> <p>Ejemplo de c\u00f3digo blink (encendido y apagado de un LED)</p> <pre><code>#define LED_BUILTIN 34 //for ESP32 board, if you have Arduino UNO board, you don't have to do this\n\n// the setup function runs once when you press reset or power the board\nvoid setup() {\n  // initialize digital pin LED_BUILTIN as an output.\n  pinMode(LED_BUILTIN, OUTPUT);\n}\n\n// the loop function runs over and over again forever\nvoid loop() {\n  digitalWrite(LED_BUILTIN, HIGH);   // turn the LED on (HIGH is the voltage level)\n  delay(1000);                       // wait for a second\n  digitalWrite(LED_BUILTIN, LOW);    // turn the LED off by making the voltage LOW\n  delay(1000);                       // wait for a second\n}\n</code></pre>"},{"location":"Capitulo%202/01_estructura/#configuracion-del-entorno-para-el-esp32","title":"Configuraci\u00f3n del entorno para el ESP32","text":"<p>Hoy en d\u00eda la version de Arduino IDE 1.8x, ya se considera legacy, pero aun asi sigue funcionando de la misma manera para compilar, y hacer todo lo necesario para las placas que soporten el firmware de Arduino. Aunque ya se recomienda hacer uso de la version 2, dado que mejora de cierta manera algunas cosas (pero a mi consideraci\u00f3n aun esta verde y consume demasiado). </p> <p>Otra alternativa es usar VS Code con un plugin de PlatformIO, esto es aun m\u00e1s pesado, pero muy bueno (a m\u00ed consideraci\u00f3n es el mejor entorno, elimina varias limitaciones de la version 2, que me imagino en un futuro va a superar). Si deseas usarla en su sitio oficial est\u00e1n las instrucciones click aqu\u00ed.</p>"},{"location":"Capitulo%202/01_estructura/#arduino-ide-18x","title":"Arduino IDE 1.8.x","text":"<p>...</p>"},{"location":"Capitulo%202/01_estructura/#arduino-ide-2","title":"Arduino IDE 2","text":"<p>En un futuro</p>"},{"location":"Capitulo%202/02_interfaz_ide/","title":"Interfaz de Arduino IDE 1.8","text":""},{"location":"Capitulo%202/03_io/","title":"Entradas y Salidas Digitales (I/O)","text":""},{"location":"Capitulo%202/03_io/#niveles-logicos","title":"Niveles l\u00f3gicos","text":"<p>Tenemos que dar las indicaciones para mandar a nivel alto las salidas del microcontrolador; es decir, mandar a un <code>nivel l\u00f3gico 1</code> o <code>alto</code> o <code>True</code>, esto lo que har\u00e1 ser\u00e1 que a la salida del pin tenga un nivel de voltaje de <code>3.3V</code>, en caso de mandarlo a <code>0</code> o <code>bajo</code> o <code>False</code>, es equivalente a <code>0V</code>.</p> Programaci\u00f3n Nivel l\u00f3gico Digital Voltaje False 0 LOW 0V True 1 HIGH 3.3V"},{"location":"Capitulo%202/03_io/#salidas-digitales","title":"Salidas digitales","text":"<p>Para comenzar vamos a controlar las salidas digitales. Para esto se usa la funci\u00f3n <code>digitalWrite</code>.</p> <pre><code>// uso de la funci\u00f3n digitalWrite\ndigitalWrite(NO_PIN, MODO);\n</code></pre> <p>Configuraci\u00f3n del <code>MODO</code>:</p> <ul> <li><code>OUTPUT</code>: Indica que el pin ser\u00e1 <code>salida</code></li> <li><code>INPUT</code>: Indica que el pin ser\u00e1 <code>entrada</code></li> </ul> <pre><code>// Aqu\u00ed indicamos que el pin 32 ser\u00e1 salida\ndigitalWrite(34, OUTPUT);\n</code></pre> <p>Para conocer los pines que se pueden usar o el numero que podemos pasar para el pin ver la tabla de los pines</p>"},{"location":"Capitulo%202/03_io/#entradas-digitales","title":"Entradas digitales","text":"<p>Para comenzar vamos a controlar las entradas digitales. Para esto se usa la funci\u00f3n <code>digitalWrite</code>.</p> <pre><code>// uso de la funci\u00f3n digitalWrite\ndigitalWrite(NO_PIN, MODO)\n</code></pre> <p>Configuraci\u00f3n del <code>MODO</code>:</p> <ul> <li><code>OUTPUT</code>: Indica que el pin ser\u00e1 <code>salida</code></li> <li><code>INPUT</code>: Indica que el pin ser\u00e1 <code>entrada</code></li> </ul> <pre><code>// Aqu\u00ed indicamos que el pin 32 ser\u00e1 entrada\ndigitalWrite(32, INPUT);\n</code></pre> <p>Para conocer los pines que se pueden usar o el numero que podemos pasar para el pin ver la tabla de los pines</p>"},{"location":"Capitulo%202/03_io/#utilizando-las-salidas-digitales","title":"Utilizando las salidas digitales","text":""},{"location":"Capitulo%202/03_io/#encender-un-led","title":"Encender un LED","text":"<p>Vamos a realizar un ejemplo b\u00e1sico para encender un LED.</p> <p>Material</p> Cantidad Descripci\u00f3n 1 Placa ESP32 1 LED 1 R330 <p>Diagrama pict\u00f3rico</p> <p></p> <p>C\u00f3digo</p> <pre><code>int LED = 32; // declaro una variable con el n\u00famero del pin en donde tengo el led\n// the setup function runs once when you press reset or power the board\nvoid setup() {\n  pinMode(LED, OUTPUT);   // configuro el pin 32 como salida\n  digitalWrite(LED, LOW); // indico que el pin 32 se ponga en estado BAJO, es decir, manda un 0 a la salida\n}\n\n// the loop function runs over and over again forever\nvoid loop() {\n  digitalWrite(LED, HIGH);   // indico que el pin 32 se ponga en estado ALTO, es decir, manda un 1 a la salida, prendiendo el LED\n}\n</code></pre>"},{"location":"Capitulo%202/03_io/#encender-varios-led","title":"Encender varios LED","text":"<p>Vamos a realizar un ejemplo b\u00e1sico para encender un LED.</p> <p>Material</p> Cantidad Descripci\u00f3n 1 Placa ESP32 3 LED 3 R330 <p>Diagrama pict\u00f3rico</p> <p></p> <p>C\u00f3digo</p> <pre><code>int LED1 = 32; // declaro una variable con el n\u00famero del pin en donde tengo el led\nint LED2 = 33; // declaro una variable con el n\u00famero del pin en donde tengo el led\nint LED3 = 25; // declaro una variable con el n\u00famero del pin en donde tengo el led\n// the setup function runs once when you press reset or power the board\nvoid setup() {\n  pinMode(LED1, OUTPUT);   // configuro el pin 32 como salida\n  pinMode(LED2, OUTPUT);   // configuro el pin 33 como salida\n  pinMode(LED3, OUTPUT);   // configuro el pin 25 como salida\n  digitalWrite(LED1, LOW); // indico que el pin 32 se ponga en estado BAJO, es decir, manda un 0 a la salida\n  digitalWrite(LED2, LOW); // indico que el pin 33 se ponga en estado BAJO, es decir, manda un 0 a la salida\n  digitalWrite(LED3, LOW); // indico que el pin 25 se ponga en estado BAJO, es decir, manda un 0 a la salida\n}\n\n// the loop function runs over and over again forever\nvoid loop() {\n  digitalWrite(LED1, HIGH);   // indico que el pin 32 se ponga en estado ALTO, es decir, manda un 1 a la salida, prendiendo el LED\n  digitalWrite(LED2, HIGH);   // indico que el pin 33 se ponga en estado ALTO, es decir, manda un 1 a la salida, prendiendo el LED\n  digitalWrite(LED3, HIGH);   // indico que el pin 25 se ponga en estado ALTO, es decir, manda un 1 a la salida, prendiendo el LED\n}\n</code></pre>"},{"location":"Capitulo%202/03_io/#blink-led","title":"Blink LED","text":"<p>Vamos a realizar un ejemplo de parpadeo de un LED, conocido como blink-blink. Con un intervalo de tiempo de 1s.</p> <p>Material</p> Cantidad Descripci\u00f3n 1 Placa ESP32 1 LED 1 R330 <p>Diagrama pict\u00f3rico</p> <p></p> <p>C\u00f3digo</p> <pre><code>int LED = 32; // declaro una variable con el n\u00famero del pin en donde tengo el led\n\n// the setup function runs once when you press reset or power the board\n\nvoid setup() {\n  pinMode(LED, OUTPUT);   // configuro el pin 32 como salida\n  digitalWrite(LED, LOW); // indico que el pin 32 se ponga en estado BAJO, es decir, manda un 0 a la salida\n}\n\n// the loop function runs over and over again forever\nvoid loop() {\n  digitalWrite(LED, HIGH);   // enciendo el LED \n  delay(1000);               // espero un segundo\n  digitalWrite(LED, LOW);    // apago el LED\n  delay(1000);              // espero un segundo\n}\n</code></pre>"},{"location":"Capitulo%202/03_io/#entradas-digitales_1","title":"Entradas digitales","text":"<p>Nota</p> <p>Se estar\u00e1 usando por default los pines <code>34</code> y <code>35</code> para los botones dado que estos pines solo pueden ser usados como <code>INPUT</code>, y vamos a aprovechar esto para sean nuestras entradas, si tu deseas usar cualquier otro pin solo ajusta tu c\u00f3digo.</p>"},{"location":"Capitulo%202/03_io/#control-de-entrada-encender-led","title":"Control de entrada, encender LED","text":"<p>Vamos a usar un bot\u00f3n para que mientras se este presionando el bot\u00f3n, se encienda el LED; es decir, mientras mantenga presionado el bot\u00f3n el LED estar\u00e1 encendido</p> <p>Material</p> Cantidad Descripci\u00f3n 1 Placa ESP32 1 LED 1 R330 1 push button 1 R1K <p>Diagrama pict\u00f3rico</p> <p></p> <p>C\u00f3digo</p> <pre><code>int LED = 32; // declaro una variable con el n\u00famero del pin en donde tengo el led\nint BTN 34; // declaro una variable para identificar el pin en donde estar\u00e1 el bot\u00f3n\n\n// the setup function runs once when you press reset or power the board\nvoid setup() {\n  pinMode(LED, OUTPUT);   // configuro el pin 32 como salida\n  pinMode(BTN, INPUT); // configuro el pin 34 como entrada\n  digitalWrite(LED, LOW); // indico que el pin 32 se ponga en estado BAJO, es decir, manda un 0 a la salida\n}\n\n// the loop function runs over and over again forever\nvoid loop() {\n\n  int status = digitalRead(BTN); //leo el estado del bot\u00f3n y lo guardo en la variable status\n  if( status == 1){ //si el bot\u00f3n esta siendo presionado mando entro \n    digitalWrite(LED, HIGH);   // enciendo el LED \n    delay(250); // espero este tiempo para evitar el transitorio del bot\u00f3n\n  }else{\n    digitalWrite(LED, LOW);   // apago el LED \n  }\n}\n</code></pre>"},{"location":"Capitulo%202/03_io/#led-onoff","title":"LED ON/OFF","text":"<p>En este caso, si presiono el LED, este se enciende y se manteniente de esa manera, en caso que se vuelva a presionar, se apagar\u00e1 hasta que sea presionado de nuevo el LED.</p> <p>Material</p> Cantidad Descripci\u00f3n 1 Placa ESP32 1 LED 1 R330 1 push button 1 R1K <p>Diagrama pict\u00f3rico</p> <p></p> <p>C\u00f3digo</p> <pre><code>int LED = 32; // declaro una variable con el n\u00famero del pin en donde tengo el led\nint BTN 34; // declaro una variable para identificar el pin en donde estar\u00e1 el bot\u00f3n\n\n// the setup function runs once when you press reset or power the board\nvoid setup() {\n  pinMode(LED, OUTPUT);   // configuro el pin 32 como salida\n  pinMode(BTN, INPUT); // configuro el pin 34 como entrada\n  digitalWrite(LED, LOW); // indico que el pin 32 se ponga en estado BAJO, es decir, manda un 0 a la salida\n}\n\n// the loop function runs over and over again forever\nvoid loop() {\n\n  int status = digitalRead(BTN); //leo el estado del bot\u00f3n y lo guardo en la variable status\n  if( status == 1){ //si el bot\u00f3n esta siendo presionado mando entro \n    digitalWrite(LED, HIGH);   // enciendo el LED \n    delay(250); // espero este tiempo para evitar el transitorio del bot\u00f3n\n  }else{\n    digitalWrite(LED, LOW);   // apago el LED \n  }\n}\n</code></pre>"},{"location":"Capitulo%202/03_io/#control-de-buzzer","title":"Control de buzzer","text":"<p>Vamos a realizar un control de un buzzer activo (es decir, que con alimentaci\u00f3n emita un sonido), cuando no se presione el bot\u00f3n, simplemente parpadea un led a 250mS, cuando sea presionado el bot\u00f3n el buzzer sonara y al mismo tiempo el LED va a encender a la misma velocidad</p> <p>Material</p> Cantidad Descripci\u00f3n 1 Placa ESP32 1 LED 1 R330 1 push button 1 R1K 1 Buzzer activo <p>Diagrama pict\u00f3rico</p> <p></p> <p>C\u00f3digo</p> <pre><code>const int LED = 33; // declaro una variable con el n\u00famero del pin en donde tengo el led\nconst int BUZZER = 25; // declaro la variable con el numero del pin en donde tendr\u00e9 el buzzer\nconst int BTN = 34; // declaro una variable para identificar el pin en donde estar\u00e1 el bot\u00f3n\n\n// the setup function runs once when you press reset or power the board\nvoid setup() {\n  pinMode(LED, OUTPUT);   // configuro el pin 33 como salida\n  pinMode(BUZZER, OUTPUT);   // configuro el pin 25 como salida\n  pinMode(BTN, INPUT); // configuro el pin 34 como entrada\n  digitalWrite(LED, LOW); // indico que el pin 33 se ponga en estado BAJO, es decir, manda un 0 a la salida\n}\n\n// the loop function runs over and over again forever\nvoid loop() {\n\n  int status = digitalRead(BTN); //leo el estado del bot\u00f3n y lo guardo en la variable status\n\n  if ( status == 1) { //si el bot\u00f3n esta siendo presionado mando entro\n    digitalWrite(LED, HIGH);   // enciendo el LED\n    digitalWrite(BUZZER, HIGH);   // enciendo el BUZZER\n    delay(100); // espero este tiempo escuchar el sonido correcto\n    digitalWrite(LED, LOW);   // enciendo el LED\n    digitalWrite(BUZZER, LOW);   // enciendo el BUZZER\n    delay(100); // espero este tiempo escuchar el sonido correcto\n  } else {\n    digitalWrite(LED, HIGH);   // enciendo el LED\n    delay(250); //parpadea el LED\n    digitalWrite(LED, LOW);   // enciendo el LED\n    delay(250); //parpadea el LED\n  }\n}\n</code></pre>"},{"location":"Capitulo%202/03_io/#display-de-7-segmentos","title":"Display de 7 segmentos","text":"<p>Note</p> <p>Se estar\u00e1 usando un display de 7 segmentos de C\u00e1todo com\u00fan en todos los ejemplos, en caso de contar con uno de \u00e1nodo com\u00fan, hacer los ajuste necesarios en el c\u00f3digo</p>"},{"location":"Capitulo%202/03_io/#contador-basico-con-display-de-7-segmentos","title":"Contador b\u00e1sico con display de 7 segmentos","text":"Im\u00e1genes ejemplo <p>Material</p> Cantidad Descripci\u00f3n 1 Placa ESP32 1 LED 7 R330 1 Display de 7 segmentos de c\u00e1todo com\u00fan <p>Diagrama pict\u00f3rico</p> <p></p> <p>C\u00f3digo</p> <pre><code>const int A = 25;\nconst int B = 26;\nconst int C = 27;\nconst int D = 14;\nconst int E = 12;\nconst int F = 19;\nconst int G = 18;\n\nvoid display(int a, int b, int c, int d, int e, int f, int g);\n\nvoid display(int a, int b, int c, int d, int e, int f, int g)\n{\n  digitalWrite(A, a);\n  digitalWrite(B, b);\n  digitalWrite(C, c);\n  digitalWrite(D, d);\n  digitalWrite(E, e);\n  digitalWrite(F, f);\n  digitalWrite(G, g);\n}\n\nvoid setup()\n{\n  Serial.begin(115200);\n  pinMode(A, OUTPUT);\n  pinMode(B, OUTPUT);\n  pinMode(C, OUTPUT);\n  pinMode(D, OUTPUT);\n  pinMode(E, OUTPUT);\n  pinMode(F, OUTPUT);\n  pinMode(G, OUTPUT);\n}\n\n// the loop function runs over and over again forever\n\nvoid loop()\n{\n\n  display(1, 1, 1, 1, 1, 1, 0); // 0\n  delay(500);\n  display(0, 1, 1, 0, 0, 0, 0); // 1\n  delay(500);\n  display(1, 1, 0, 1, 1, 0, 1); // 2\n  delay(500);\n  display(1, 1, 1, 1, 0, 0, 1); // 3\n  delay(500);\n  display(0, 1, 1, 0, 0, 1, 1); // 4\n  delay(500);\n  display(1, 0, 1, 1, 0, 1, 1); // 5\n  delay(500);\n  display(1, 0, 1, 1, 1, 1, 1); // 6\n  delay(500);\n  display(1, 1, 1, 0, 0, 0, 0); // 7\n  delay(500);\n  display(1, 1, 1, 1, 1, 1, 1); // 8\n  delay(500);\n  display(1, 1, 1, 0, 0, 1, 1); // 9\n  delay(500);\n  display(1, 1, 1, 0, 1, 1, 1); // A\n  delay(500);\n  display(0, 0, 1, 1, 1, 1, 1); // B\n  delay(500);\n  display(1, 0, 0, 1, 1, 1, 0); // C\n  delay(500);\n  display(0, 1, 1, 1, 1, 0, 1); // D\n  delay(500);\n  display(1, 0, 0, 1, 1, 1, 1); // E\n  delay(500);\n  display(1, 0, 0, 0, 1, 1, 1); // F\n  delay(500);\n}\n</code></pre>"},{"location":"Capitulo%202/03_io/#contador-basico-con-boton-display-de-7-segmentos","title":"Contador b\u00e1sico con bot\u00f3n, display de 7 segmentos","text":"<p>Ahora vamos a controlar el display haciendo el incremento de manera manual, cada que se presione el bot\u00f3n se har\u00e1 el cambio de d\u00edgito, una vez llegue al final se reiniciara el contador.</p> <p>Material</p> Cantidad Descripci\u00f3n 1 Placa ESP32 1 LED 7 R330 1 Display de 7 segmentos de c\u00e1todo com\u00fan 1 Push button 1 R1k <p>Diagrama pict\u00f3rico</p> <p></p> <p>C\u00f3digo</p> <pre><code>const int A = 25;\nconst int B = 26;\nconst int C = 27;\nconst int D = 14;\nconst int E = 12;\nconst int F = 19;\nconst int G = 18;\nconst int BTN = 34;\n\nvoid display(int a, int b, int c, int d, int e, int f, int g);\n\nvoid display(int a, int b, int c, int d, int e, int f, int g)\n{\n  digitalWrite(A, a);\n  digitalWrite(B, b);\n  digitalWrite(C, c);\n  digitalWrite(D, d);\n  digitalWrite(E, e);\n  digitalWrite(F, f);\n  digitalWrite(G, g);\n}\n\nvoid setup()\n{\n  Serial.begin(115200);\n  pinMode(A, OUTPUT);\n  pinMode(B, OUTPUT);\n  pinMode(C, OUTPUT);\n  pinMode(D, OUTPUT);\n  pinMode(E, OUTPUT);\n  pinMode(F, OUTPUT);\n  pinMode(G, OUTPUT);\n}\n\n// the loop function runs over and over again forever\nint count = 0; //variable que me ayuda a conocer en que digito hay que desplegar\nvoid loop() {\n\n  if (digitalRead(BTN) == 1) {\n    delay(250);\n    if (count &lt; 15) {\n      count++;\n    }\n    else {\n      count = 0;\n    }\n  }\n\n  if (count == 0)\n    display(1, 1, 1, 1, 1, 1, 0); // 0\n  if (count == 1)\n    display(0, 1, 1, 0, 0, 0, 0); // 1\n  if (count == 2)\n    display(1, 1, 0, 1, 1, 0, 1); // 2\n  if (count == 3)\n    display(1, 1, 1, 1, 0, 0, 1); // 3\n  if (count == 4)\n    display(0, 1, 1, 0, 0, 1, 1); // 4\n  if (count == 5)\n    display(1, 0, 1, 1, 0, 1, 1); // 5\n  if (count == 6)\n    display(1, 0, 1, 1, 1, 1, 1); // 6\n  if (count == 7)\n    display(1, 1, 1, 0, 0, 0, 0); // 7\n  if (count == 8)\n    display(1, 1, 1, 1, 1, 1, 1); // 8\n  if (count == 9)\n    display(1, 1, 1, 0, 0, 1, 1); // 9\n  if (count == 10)\n    display(1, 1, 1, 0, 1, 1, 1); // A\n  if (count == 11)\n    display(0, 0, 1, 1, 1, 1, 1); // B\n  if (count == 12)\n    display(1, 0, 0, 1, 1, 1, 0); // C\n  if (count == 13)\n    display(0, 1, 1, 1, 1, 0, 1); // D\n  if (count == 14)\n    display(1, 0, 0, 1, 1, 1, 1); // E\n  if (count == 15)\n    display(1, 0, 0, 0, 1, 1, 1); // F\n\n  delay(10);\n}\n</code></pre>"},{"location":"Capitulo%202/03_io/#giro-en-dos-sentidos-motor-dc","title":"Giro en dos sentidos Motor DC","text":"<p>Realizaremos un control b\u00e1sico de un control DC, haci\u00e9ndolo girar en un sentido con un bot\u00f3n y se invertir\u00e1 el sentido presionando el 2o bot\u00f3n. Tendr\u00e1 un LED indicativo del giro.</p> <p>Material</p> Cantidad Descripci\u00f3n 1 Placa ESP32 2 LED 2 R330 2 Push button 2 R1k 1 Driver para motor DC (MX1580, L298 o L293) 1 Motor DC (6V) 1 Fuente externa para el motor, de 1A (m\u00ednimo) <p>Diagrama pict\u00f3rico</p> <p></p> <p></p> <p>C\u00f3digo</p> <pre><code>//Configuro los pines f\u00edsicos para las entradas y salidas\nconst byte LED_I = 25;\nconst byte LED_D = 26;\nconst byte MOTOR_1 = 18;\nconst byte MOTOR_2 = 19;\nconst byte BTN_D = 34;\nconst byte BTN_I = 35;\n\nvoid setup() {\n  // configurando los pines como entradas y salidas\n  pinMode(LED_I, OUTPUT);\n  pinMode(LED_D, OUTPUT);\n  pinMode(MOTOR_1, OUTPUT);\n  pinMode(MOTOR_2, OUTPUT);\n  pinMode(BTN_I, INPUT);\n  pinMode(BTN_D, INPUT);\n}\n\nvoid loop() {\n\n  if (digitalRead(BTN_I) == 1) {\n    delay(100);\n    // Motor\n    digitalWrite(MOTOR_1, HIGH);\n    digitalWrite(MOTOR_2, LOW);\n    //Leds\n    digitalWrite(LED_I,HIGH);\n    digitalWrite(LED_D,LOW);\n  } else if (digitalRead(BTN_D) == 1) {\n    delay(100);\n    // Motor\n    digitalWrite(MOTOR_1, LOW);\n    digitalWrite(MOTOR_2, HIGH);\n    //Leds\n    digitalWrite(LED_I,LOW);\n    digitalWrite(LED_D,HIGH);\n  } else {\n     // Motor apagado\n    digitalWrite(MOTOR_1, LOW);\n    digitalWrite(MOTOR_2, LOW);\n    //Hago un blink con los leds\n    //Leds\n    digitalWrite(LED_I,LOW);\n    digitalWrite(LED_D,LOW);\n    delay(250);    \n    digitalWrite(LED_I,HIGH);\n    digitalWrite(LED_D,HIGH);\n    delay(250);\n  }\n}\n</code></pre>"},{"location":"Capitulo%202/03_io/#control-de-motor-pap","title":"Control de Motor PAP","text":"<p>Vamos a realizar el control de un motor Paso a Paso, en sus diferentes combinaciones de secuencias, es decir, medio paso, paso completo</p> <p>Material</p> Cantidad Descripci\u00f3n 1 Placa ESP32 2 LED 2 R330 2 Push button 2 R1k 1 M\u00f3dulo de driver para Motor PAP (ULN2003) 1 Motor PAP 28BYJ-48 1 Fuente externa para el motor, de 1A (m\u00ednimo) <p>Descripci\u00f3n del Motor PAP 28BYJ-48 y Driver ULN</p> <p></p> <ul> <li>Total de pasas por revoluci\u00f3n = 2048 steps</li> <li>\u00c1ngulo del paso = 0.18\u00ba/step</li> </ul> <p></p> <p>Diagrama pict\u00f3rico</p> <p></p> <p></p> <p>C\u00f3digo</p> <pre><code>#include &lt;Stepper.h&gt;\n\n#define stepsPerRevolution 512  //\n\n//se crea el objeto de la librer\u00eda para ser configurada\nStepper myStepper(stepsPerRevolution, 25, 26, 27, 14);\n\nconst int BTN_I = 34;\nconst int BTN_D = 35;\n\nvoid setup() {\n  // set the speed at 60 rpm:\n  myStepper.setSpeed(60);\n  // initialize the serial port:\n  Serial.begin(15200);\n  pinMode(BTN_I, INPUT);\n  pinMode(BTN_D, INPUT);\n}\n\nvoid loop() {\n\n  if (digitalRead(BTN_I) == 1) {\n    // step one revolution  in one direction:\n    Serial.println(\"clockwise\");\n    myStepper.step(stepsPerRevolution);\n    delay(10);\n\n  }else if (digitalRead(BTN_D) == 1) {\n    // step one revolution in the other direction:\n    Serial.println(\"counterclockwise\");\n    myStepper.step(-stepsPerRevolution);\n    delay(10);\n  }\n\n}\n</code></pre>"},{"location":"Capitulo%202/03_io/#control-de-carga-ac-modulo-de-relay","title":"Control de carga AC - Modulo de Relay","text":"<p>Realizaremos un control b\u00e1sico de un control DC, haci\u00e9ndolo girar en un sentido con un bot\u00f3n y se invertir\u00e1 el sentido presionando el 2o bot\u00f3n. Tendr\u00e1 un LED indicativo del giro.</p> <p>Material</p> Cantidad Descripci\u00f3n 1 Placa ESP32 2 LED 2 R330 2 Push button 2 R1k 1 Fuente externa para el motor, de 1A (m\u00ednimo) 1 M\u00f3dulo de Relay 1 Foco (puede ser cualquier otra Carga AC ligera) con su clavija <p>Diagrama pict\u00f3rico</p> <p>Para el modulo de un Relay</p> <p></p> <p>Para el modulo doble Relay</p> <p></p> <p>C\u00f3digo</p> <pre><code>//creo las constantes de los pines en donde se colocaran los elementos de entrada y salida\n\n#define MODULE_SINGLE 2  // SI ESTAS USANDO EL MODULO DE DOBLE RELAY, CAMBIA EL VALOR A 2\n\n\nconst byte BTN = 34;\nconst byte RELAY = 25;\n\nvoid setup() {\n  //configuro los pines como entrada y salida\n  pinMode(BTN, INPUT);\n  pinMode(RELAY, OUTPUT);\n\n  if(MODULE_SINGLE == 2){\n    digitalWrite(RELAY, HIGH);\n  }else{\n    digitalWrite(RELAY, LOW);\n  }\n}\n\nvoid loop() {\n\n  if (digitalRead(BTN) == 1) {\n    //invierto el estado de la salida, es decir, si esta apagado se enciende\n    digitalWrite(RELAY, !digitalRead(RELAY));\n    delay(250);\n  }\n}\n</code></pre>"},{"location":"Capitulo%202/03_io/#control-rf-315-mhz","title":"Control RF 315 MHz","text":"<p>El control RF ya incluye un decodificador, es decir, este IC es el encargado de decirnos qu\u00e9 bot\u00f3n fue presionado en el control y con ello sabremos la acci\u00f3n a realizar.</p> <p></p> <p>Descripci\u00f3n del receptor </p> <p></p> <p>Cuando se pulsa un bot\u00f3n el control remoto, si la comunicaci\u00f3n es correcta levanta el pin VT para indicar que ha detectado una transmisi\u00f3n valida (Valid Trans).</p> <p></p> <p>Probando el funcionamiento del Control con receptor</p> <p>C\u00f3digo</p> <pre><code>///defino los pines de entrada y salida\n#define D0 34\n#define D1 35\n#define D2 32\n#define D3 33\n\n#define LED1 26\n#define LED2 27\n#define LED3 14\n#define LED4 12\n\nvoid setup() {\n  pinMode(D0, INPUT);\n  pinMode(D1, INPUT);\n  pinMode(D2, INPUT);\n  pinMode(D3, INPUT);\n  pinMode(LED1, OUTPUT);\n  pinMode(LED2, OUTPUT);\n  pinMode(LED3, OUTPUT);\n  pinMode(LED4, OUTPUT);\n  // inicializamos la pantalla para comunicaci\u00f3n\n  Serial.begin(115200);\n\n}\n\nvoid loop() {\n\n  if (digitalRead(D0) == 1) {\n    Serial.println(\"D0\");\n    digitalWrite(LED1, !digitalRead(LED1));\n  }\n  if (digitalRead(D1) == 1) {\n    Serial.println(\"D1\");\n    digitalWrite(LED2, !digitalRead(LED2));\n  }\n  if (digitalRead(D2) == 1) {\n    Serial.println(\"D2\");\n    digitalWrite(LED3, !digitalRead(LED3));\n  }\n  if (digitalRead(D3) == 1) {\n    Serial.println(\"D3\");\n    digitalWrite(LED4, !digitalRead(LED4));\n  }\n  delay(250);\n}\n</code></pre>"},{"location":"Capitulo%202/03_io/#mini-proyecto","title":"Mini proyecto","text":""},{"location":"Capitulo%202/03_io/#seguidor-de-luz","title":"Seguidor de Luz","text":"<p>Es un carrito seguidor de Luz, cuando se recibe la luz en el sensor izquierdo, se activa el motor derecho, cuando recibe luz el sensor derecho se activa el motor izquierdo, si se recibe la luz en ambos se activan los 2 motores al mismo tiempo.</p> <p></p> <p>Abrir la imagen</p> <p><code>Nota: Solo se cambia la secci\u00f3n de control por la placa ESP32</code></p> <p></p> <p>C\u00f3digo</p> <pre><code>//Se uso el ESP32 version Wemos\nconst byte sensorD = 19; //\nconst byte sensorI = 23;\nconst byte motorD_1 = 26; // 26\nconst byte motorD_2 = 25; // 25\nconst byte motorI_1 = 17; // 17\nconst byte motorI_2 = 16; //1 6\n\nvoid setup() {\n  // put your setup code here, to run once:\n  Serial.begin(115200);\n  Serial.println(\"inicio\");\n  pinMode(sensorD, INPUT);\n  pinMode(sensorI, INPUT);\n  pinMode(motorD_1, OUTPUT);\n  pinMode(motorD_2, OUTPUT);\n  pinMode(motorI_1, OUTPUT);\n  pinMode(motorI_2, OUTPUT);\n  digitalWrite(motorD_2, LOW);\n  digitalWrite(motorI_2, LOW);\n\n}\n\nvoid loop() {\n\n  if (digitalRead(sensorD) == 1 &amp;&amp; digitalRead(sensorI) == 1) {\n    Serial.println(\"derecho e izquierdo\");\n    digitalWrite(motorD_1, HIGH);\n    digitalWrite(motorI_1, HIGH);\n    delay(10);\n  } else if (digitalRead(sensorI) == 1) {\n    Serial.println(\"izquierdo\");\n    digitalWrite(motorD_1, HIGH);\n    digitalWrite(motorI_1, LOW);\n    delay(10);\n  } else if (digitalRead(sensorD) == 1) {\n    Serial.println(\"derecho\");\n    digitalWrite(motorD_1, LOW);\n    digitalWrite(motorI_1, HIGH);\n    delay(10);\n  } else {\n    Serial.println(\"nada\");\n    digitalWrite(motorD_1, LOW);\n    digitalWrite(motorI_1, LOW);\n    delay(10);\n  }\n\n}\n</code></pre>"},{"location":"Capitulo%202/04_io_ex/","title":"Ejercicios con IO Digitales","text":""},{"location":"Capitulo%202/04_io_ex/#display-de-7-segmentos","title":"Display de 7 Segmentos","text":"<p>Realizar el siguiente ejercicio, como se ve en la animaci\u00f3n</p> <p></p> <p>Funcionamiento</p> <ol> <li>Contador hexadecimal, es decir, va desde el 0 hasta la F</li> <li>0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F</li> <li>Cada que se presione un bot\u00f3n, debe incrementar el d\u00edgito</li> <li>Cada que se presione otro bot\u00f3n, se decrementa en uno el d\u00edgito</li> <li>Hay un tercer bot\u00f3n, para el reset del conteo</li> <li>Cuando llegue al topo superior (F) o inferior (cero), no debe pasar nada</li> </ol>"},{"location":"Capitulo%202/04_io_ex/#control-de-motor-dc-con-lcd","title":"Control de Motor DC con LCD","text":"<p>Realizar el siguiente ejercicio, como se ve en la animaci\u00f3n</p> <p></p> <p>Funcionamiento</p> <ol> <li>Cuando el no se este presionando ning\u00fan bot\u00f3n, debe estar parpadeando los 2 leds y en la pantalla indicar \"MOTOR DETENIDO\"</li> <li>Cuando sea presionado un bot\u00f3n debe encender solamente el LED indicativo a dicha direcci\u00f3n, e indicar en la pantalla \"MOTOR A LA DERECHA\"</li> <li>Cuando sea presionado el otro bot\u00f3n debe encender solamente el LED indicativo a dicha direcci\u00f3n, e indicar en la pantalla \"MOTOR A LA IZQUIERDA\"</li> </ol>"},{"location":"Capitulo%202/05_adc_pwm/","title":"Entradas y Salidas anal\u00f3gicas (ADC y PWM)","text":""},{"location":"Capitulo%202/05_adc_pwm/#entradas-analogicas","title":"Entradas anal\u00f3gicas","text":"<p>El ADC es un modulo interno que tiene el microcontrolador ESP32, el cual su funci\u00f3n es convertir unas se\u00f1al de voltaje a un valor equivalente en binario, este valor determinado por la resoluci\u00f3n del convertidor.</p> <p>Caracter\u00edsticas del ADC</p> <ul> <li>Voltaje de entrada <code>0V</code> a <code>3.3V</code></li> <li>Resoluci\u00f3n de 12 bits</li> <li>Valor en decimal de <code>0</code> a <code>4095</code></li> <li>El valor mas peque\u00f1o que podemos medir es de 0.8mV o 800uV (en teor\u00eda)</li> <li>Tenemos 11 canales disponibles para utilizar (los dem\u00e1s no los podemos usar si usamos el framework de Arduino)</li> </ul> <p>Los pines a los que se puede conectar son los que indican <code>ADCx CHx</code>, lo cual significa Canal <code>X</code> ADC. Nota: Recuerda que hay pines que no podemos utilizar.</p> <p></p> <p>Note</p> <p>No se necesita inicializar el pin como entrada, solo se usa la funci\u00f3n <code>analogRead(pin)</code>.  <pre><code>// de esta manera utilizar\u00edamos la funci\u00f3n y guarda el dato en una variable\nint valueADC = analogRead(noPin);\n</code></pre></p> <p>Note</p> <p>Se recomienda colocar un capacitor de 0.1uF en la entrada del ADC para reducir el ruido, junto con multimuestra para reducirlo lo m\u00e1ximo posible. Ir a documentaci\u00f3n oficial</p> <p>Danger</p> <p>NUNCA se debe exceder de 3.3V a la entrada del ADC, ni voltajes negativos, esto da\u00f1ar\u00eda de manera parcial o total el microcontrolador.</p> <p>Hay varias caracter\u00edsticas avanzadas relacionadas al ADC que no se van a tratar.</p>"},{"location":"Capitulo%202/05_adc_pwm/#leyendo-una-entrada-analogica","title":"Leyendo una entrada anal\u00f3gica","text":"<p>Vamos a realizar una lectura b\u00e1sica de un ADC y mandar ese valor a la monitor serial.</p> <p>Material</p> Cantidad Descripci\u00f3n 1 Placa ESP32 1 LED 1 Pot 10k <p>Diagrama pict\u00f3rico</p> <p></p> <p>C\u00f3digo</p> <pre><code>const byte pinADC = 34; //pin que sera le\u00eddo del ADC\n\n// the setup routine runs once when you press reset:\nvoid setup() {\n  // inicializamos el monitor serial a 115200 baudios\n  Serial.begin(115200);\n}\n\n// the loop routine runs over and over again forever:\nvoid loop() {\n  //se lee el pin del ADC y se guarda en la variable valueADC\n  int valueADC = analogRead(pinADC);\n  Serial.println(valueADC);// se imprime el valor del ADC\n  delay(10);        // para la estabilidad del valor de entrada\n}\n</code></pre>"},{"location":"Capitulo%202/05_adc_pwm/#barra-de-leds-con-potenciometro","title":"Barra de LEDs con potenci\u00f3metro","text":"<p>Vamos a realizar una lectura del ADC e ir encendiendo los LEDs en funci\u00f3n del valor que tengamos de entrada, es decir, entre mas valores, mas se prender\u00e1n, y entre menor sea el valor, menos encender\u00e1n.</p> <p>Material</p> Cantidad Descripci\u00f3n 1 Placa ESP32 1 LED 1 Pot 10k 3 LEDs 3 R330 <p>Diagrama pict\u00f3rico</p> <p></p> <p>C\u00f3digo</p> <pre><code>const byte pinADC = 34;  //pin que sera le\u00eddo del ADC\nconst byte LED1 = 33;    //Configuro el pin en donde colocar\u00e9 el LED\nconst byte LED2 = 25;    //Configuro el pin en donde colocar\u00e9 el LED\nconst byte LED3 = 26;    //Configuro el pin en donde colocar\u00e9 el LED\n\n// the setup routine runs once when you press reset:\nvoid setup() {\n  // inicializamos el monitor serial a 115200 baudios\n  Serial.begin(115200);\n  pinMode(LED1, OUTPUT);  //configuro como salida el pin para el led\n  pinMode(LED2, OUTPUT);  //configuro como salida el pin para el led\n  pinMode(LED3, OUTPUT);  //configuro como salida el pin para el led\n}\n\n// the loop routine runs over and over again forever:\nvoid loop() {\n  //se lee el pin del ADC y se guarda en la variable valueADC\n  int valueADC = analogRead(pinADC);\n  Serial.println(valueADC);  // se imprime el valor del ADC\n  if (valueADC &lt; 100) {      // si esta por debajo de este valor, se apagando todos los LEDs\n    digitalWrite(LED1, LOW);\n    digitalWrite(LED2, LOW);\n    digitalWrite(LED3, LOW);\n  } else if (valueADC &gt; 100 &amp;&amp; valueADC &lt;= 1500) {  // si esta en este rango prender\u00e1 los leds indicados\n    digitalWrite(LED1, HIGH);\n    digitalWrite(LED2, LOW);\n    digitalWrite(LED3, LOW);\n  } else if (valueADC &gt; 1500 &amp;&amp; valueADC &lt;= 3000) {  // si esta en este rango prender\u00e1 los leds indicados\n    digitalWrite(LED1, HIGH);\n    digitalWrite(LED2, HIGH);\n    digitalWrite(LED3, LOW);\n  } else {  //si es mayor a 3000, se encienden todos los leds\n    digitalWrite(LED1, HIGH);\n    digitalWrite(LED2, HIGH);\n    digitalWrite(LED3, HIGH);\n  }\n  delay(10);  // para la estabilidad del valor de entrada\n}\n</code></pre>"},{"location":"Capitulo%202/05_adc_pwm/#control-crepuscular-sensor-de-luz","title":"Control crepuscular (Sensor de luz)","text":"<p>Vamos a encender el LED cuando hay poco luz, de lo contrario se debe apagar.</p> <p>Material</p> Cantidad Descripci\u00f3n 1 Placa ESP32 1 LED 1 R330 1 R10k 1 LDR <p>Diagrama pict\u00f3rico</p> <p></p> <p>C\u00f3digo</p> <pre><code>const byte pinADC = 34;  //pin que sera le\u00eddo del ADC\nconst byte LED1 = 25;    //Configuro el pin en donde colocar\u00e9 el LED\n#define LIMIT 2500       //ESTE VALOR SE CAMBIA CON BASE AL AJUSTE DEL SENSOR\n\n// the setup routine runs once when you press reset:\nvoid setup() {\n  // inicializamos el monitor serial a 115200 baudios\n  Serial.begin(115200);\n  pinMode(LED1, OUTPUT);  //configuro como salida el pin para el led\n}\n\nvoid loop() {\n  int valueLDR = analogRead(pinADC);  //leemos el pin del ADC\n  Serial.print(\"Valor del ADC: \");\n  Serial.println(valueLDR);\n\n  if (valueLDR &gt; LIMIT) {\n    digitalWrite(LED1, HIGH);\n  } else {\n    digitalWrite(LED1, LOW);\n  }\n\n  delay(10);  // para la estabilidad del valor de entrada\n}\n</code></pre>"},{"location":"Capitulo%202/05_adc_pwm/#salida-analogica-pwm","title":"Salida Anal\u00f3gica (PWM)","text":"<p>Modulaci\u00f3n de Ancho de Pulso (<code>Pulse width modulation</code> (<code>PWM</code>)) es una manera artificial de generar una salida anal\u00f3gica en un pin digital. Existen dos par\u00e1metros asociados al PWM que son la frecuencia y el ciclo de trabajo (duty cycle). El ciclo de trabajo define que tan largo sera el estado del pin en alto de <code>un periodo</code>. El m\u00e1ximo ciclo de trabajo es cuando el pin esta todo el tiempo en alto (100%) y el m\u00ednimo todo el tiempo en bajo (0%).</p> <p>En el ESP8266 todos los pines (excepto el GPIO16 o el pin 0) soportan PWM en su salida. </p> <p>Limitaci\u00f3n del PWM</p> <p>La limitaci\u00f3n es que todos deben correr a la misma frecuencia de trabajo, la cual esta entre 1Hz y 1kHz</p> <p></p> <p></p>"},{"location":"Capitulo%202/05_adc_pwm/#configuracion-de-pwm-en-esp32","title":"Configuraci\u00f3n de PWM en ESP32","text":"<p>Caracter\u00edsticas del PWM en el ESP32</p> <ul> <li>16 Canales. <code>Canal 0 - 15</code> (excepto los pines GPIO36, GPIO39, GPIO34, y GPIO35)</li> <li>Resoluci\u00f3n de 1 - 16 bits. </li> <li>3 Funciones para control y configuraci\u00f3n</li> </ul> <p></p> <p>Las funciones para el PWM</p> <ul> <li><code>ledcSetup</code>: Para configuraci\u00f3n de inicio del PWM</li> <li><code>ledcAttachPin</code>: Asigna la configuraci\u00f3n al pin indicado</li> <li><code>ledcWrite</code>: Escribe el valor que saldr\u00e1 por el pin.</li> </ul> <p>Detalles de la funciones</p> <ul> <li><code>ledcSetup(canal_PWM, frecuencia, resolucion)</code>: Es la primera funcion que se debe llamar y solo una vez para configurar el comportamiento del PWM</li> <li><code>canal_PWM</code>: Es un valor del 0 al 15, donde se selecciona el canal que usaremos del uC</li> <li><code>frecuencia</code>: Es la frecuencia de trabajo del PWM. Vamos a manejar por default 1000 (1kHz)</li> <li><code>resolucion</code>: Tenemos desde 1 a 16 bits de resoluci\u00f3n, en la mayoria de aplicaciones con 8 bits es suficiente o hasta 10 bits. Recordemos que para saber cual sera el valor minimo debemos de aplicar \\(3.3V/resolucion_{bits}\\). Con 8 bits ser\u00eda \\(3.3/256=0.012V\\)</li> <li><code>ledcAttachPin(pin, canal_PWM)</code>:</li> <li><code>pin</code>: Es el numero del pin que vamos a usar como salida PWM (ver el esquema de los pines que podemos usar)</li> <li><code>canal_PWM</code>: El canal que colocamos en la funci\u00f3n anterior</li> <li><code>ledcWrite(canal_PWM, valorPWM)</code>: La funci\u00f3n que se encarga de poner el valor en el pin indicado con un cierto ciclo de trabajo.</li> <li><code>canal_PWM</code>: El canal que estamos usando para el PWM</li> <li><code>valorPWM</code>: El valor que queremos asignar. Recordar que el valor esta en funci\u00f3n de la resoluci\u00f3n. Por ejemplo, si estamos usando 8 bits, los valores van desde 0 a 255.</li> </ul> <p>Ver mas detalles en la documentaci\u00f3n oficial</p>"},{"location":"Capitulo%202/05_adc_pwm/#control-led-rgb","title":"Control LED RGB","text":"<p>Haremos un simple cambio de color, incrementando el brillo de cada uno.</p> <p>Warning</p> <p>Se esta utilizando en LED RGB de c\u00e1todo com\u00fan, si usas uno de \u00c1nodo com\u00fan, haz tu ajuste en el c\u00f3digo y las conexiones</p> <p>Diagrama pict\u00f3rico</p> <p></p> Animaci\u00f3n <p></p> <p></p> C\u00f3digo <pre><code>#define LED_R 25  // PIN LED ROJO\n#define LED_G 26  // PIN LED VERDE\n#define LED_B 27  // PIN LED AZUL\n\n#define FREQ        1000  // frecuencia de trabajo para el PWM a 1KHz\n#define ledChannel0 0     //defino el canal 0, que usaremos para el color Rojo\n#define ledChannel1 1     //defino el canal 1, que usaremos para el color Verde\n#define ledChannel2 2     //defino el canal 2, que usaremos para el color Azul\n#define resolution  8     // 8-bit de resoluci\u00f3n (para Leds es ideal)\n\nvoid setup() {\n  // configuro el comportamiento del canal\n  ledcSetup(ledChannel0, FREQ, resolution);\n  ledcSetup(ledChannel1, FREQ, resolution);\n  ledcSetup(ledChannel2, FREQ, resolution);\n\n  //se asigna el Pin al canal configurado previamente\n  ledcAttachPin(LED_R, ledChannel0);\n  ledcAttachPin(LED_G, ledChannel1);\n  ledcAttachPin(LED_B, ledChannel2);\n}\n\nvoid loop() {\n  //se apagan todos los Leds\n  ledcWrite(ledChannel0, 0);\n  ledcWrite(ledChannel1, 0);\n  ledcWrite(ledChannel2, 0);\n  delay(15);\n\n  // Incrementa el brillo del rojo\n  for (int dutyCycle = 0; dutyCycle &lt;= 255; dutyCycle++) {\n    ledcWrite(ledChannel0, dutyCycle);\n    delay(15);\n  }\n  // Incrementa el brillo del verde\n  for (int dutyCycle = 0; dutyCycle &lt;= 255; dutyCycle++) {\n    ledcWrite(ledChannel1, dutyCycle);\n    delay(15);\n  }\n  // Incrementa el brillo del azul\n  for (int dutyCycle = 0; dutyCycle &lt;= 255; dutyCycle++) {\n    ledcWrite(ledChannel2, dutyCycle);\n    delay(15);\n  }\n}\n</code></pre>"},{"location":"Capitulo%202/05_adc_pwm/#control-de-intensidad-de-un-led-botones","title":"Control de Intensidad de un LED botones","text":"<p>Haremos un simple cambio de color con botones, incrementando el brillo de cada uno cuando se presione un bot\u00f3n, para su respectivo color.</p> <p>Warning</p> <p>Se esta utilizando en LED RGB de c\u00e1todo com\u00fan, si usas uno de \u00c1nodo com\u00fan, haz tu ajuste en el c\u00f3digo y las conexiones</p> <p>Diagrama pict\u00f3rico</p> <p></p> Animaci\u00f3n <p></p> C\u00f3digo <pre><code>#define LED_R 25  // PIN LED ROJO\n#define LED_G 26  // PIN LED VERDE\n#define LED_B 27  // PIN LED AZUL\n\n#define BTN_R 34  // PIN LED ROJO\n#define BTN_G 35  // PIN LED VERDE\n#define BTN_B 32  // PIN LED AZUL\n\n#define FREQ        1000  // frecuencia de trabajo para el PWM a 1KHz\n#define ledChannel0 0     //defino el canal 0, que usaremos para el color Rojo\n#define ledChannel1 1     //defino el canal 1, que usaremos para el color Verde\n#define ledChannel2 2     //defino el canal 2, que usaremos para el color Azul\n#define resolution  8     // 8-bit resolution\n\nvoid setup() {\n  pinMode(BTN_R, INPUT);\n  pinMode(BTN_G, INPUT);\n  pinMode(BTN_B, INPUT);\n  // configuro el comportamiento del canal\n  ledcSetup(ledChannel0, FREQ, resolution);\n  ledcSetup(ledChannel1, FREQ, resolution);\n  ledcSetup(ledChannel2, FREQ, resolution);\n\n  //se asigna el Pin al canal configurado previamente\n  ledcAttachPin(LED_R, ledChannel0);\n  ledcAttachPin(LED_G, ledChannel1);\n  ledcAttachPin(LED_B, ledChannel2);\n  //se apagan todos los Leds\n  ledcWrite(ledChannel0, 0);\n  ledcWrite(ledChannel1, 0);\n  ledcWrite(ledChannel2, 0);\n  Serial.begin(115200);\n}\n\nunsigned char red = 0;\nunsigned char blue = 0;\nunsigned char green = 0;\nunsigned char inc = 5;\n\nvoid loop() {\n  // Incrementa el brillo del rojo\n  if (digitalRead(BTN_R) == 1) {\n    if (red &gt; 254) {\n      red = 0;\n    } else {\n      red += inc;\n    }\n    ledcWrite(ledChannel0, red);\n    Serial.print(\"Rojo: \");\n    Serial.println(red);\n    delay(200);\n  }\n\n  if (digitalRead(BTN_G) == 1) {\n    if (green &gt; 254) {\n      green = 0;\n    } else {\n      green += inc;\n    }\n    ledcWrite(ledChannel1, green);\n    Serial.print(\"Verde: \");\n    Serial.println(green);\n\n    delay(200);\n  }\n\n\n  if (digitalRead(BTN_B) == 1) {\n    if (blue &gt; 254) {\n      blue = 0;\n    } else {\n      blue += inc;\n    }\n    ledcWrite(ledChannel2, blue);\n    Serial.print(\"Azul: \");\n    Serial.println(blue);\n    delay(200);\n  }\n\n}\n</code></pre>"},{"location":"Capitulo%202/05_adc_pwm/#control-de-intensidad-de-un-led-con-potenciometro","title":"Control de intensidad de un LED con potenci\u00f3metro","text":"<p>Haremos un simple cambio de color con botones, incrementando el brillo de cada uno cuando moviendo el v\u00e1stago de un potenci\u00f3metro, cada uno har\u00e1 el cambio de su respectivo color.</p> <p>Warning</p> <p>Se esta utilizando en LED RGB de c\u00e1todo com\u00fan, si usas uno de \u00c1nodo com\u00fan, haz tu ajuste en el c\u00f3digo y las conexiones</p> <p>Diagrama pict\u00f3rico</p> <p></p> Animaci\u00f3n <p></p> C\u00f3digo <pre><code>#define LED_R 25  // PIN LED ROJO\n#define LED_G 26  // PIN LED VERDE\n#define LED_B 27  // PIN LED AZUL\n\n#define POT_R 34  // PIN LED ROJO\n#define POT_G 35  // PIN LED VERDE\n#define POT_B 32  // PIN LED AZUL\n\n#define FREQ        1000  // frecuencia de trabajo para el PWM a 1KHz\n#define ledChannel0 0     //defino el canal 0, que usaremos para el color Rojo\n#define ledChannel1 1     //defino el canal 1, que usaremos para el color Verde\n#define ledChannel2 2     //defino el canal 2, que usaremos para el color Azul\n#define resolution  8     // 8-bit resolution\n\nvoid setup() {\n  // configuro el comportamiento del canal\n  ledcSetup(ledChannel0, FREQ, resolution);\n  ledcSetup(ledChannel1, FREQ, resolution);\n  ledcSetup(ledChannel2, FREQ, resolution);\n\n  //se asigna el Pin al canal configurado previamente\n  ledcAttachPin(LED_R, ledChannel0);\n  ledcAttachPin(LED_G, ledChannel1);\n  ledcAttachPin(LED_B, ledChannel2);\n  //se apagan todos los Leds\n  ledcWrite(ledChannel0, 0);\n  ledcWrite(ledChannel1, 0);\n  ledcWrite(ledChannel2, 0);\n  Serial.begin(115200);\n}\n\n\nvoid loop() {\n  int red = analogRead(POT_R);\n  int blue = analogRead(POT_B);\n  int green = analogRead(POT_G);\n\n  red = map(red, 0, 4095, 0, 255); //se esta convirtiendo el valor del ADC de 0 a 4095 a un valor de 8 bits, es decir, de 0 a 255\n  blue = map(blue, 0, 4095, 0, 255); //se esta convirtiendo el valor del ADC de 0 a 4095 a un valor de 8 bits, es decir, de 0 a 255\n  green = map(green, 0, 4095, 0, 255); //se esta convirtiendo el valor del ADC de 0 a 4095 a un valor de 8 bits, es decir, de 0 a 255\n\n  // Incrementa el brillo del rojo\n  ledcWrite(ledChannel0, red);\n  Serial.print(\"Rojo: \");\n  Serial.println(red);\n\n  ledcWrite(ledChannel1, green);\n  Serial.print(\"Verde: \");\n  Serial.println(green);\n\n  ledcWrite(ledChannel2, blue);\n  Serial.print(\"Azul: \");\n  Serial.println(blue);\n\n  delay(15);\n}\n</code></pre>"},{"location":"Capitulo%202/05_adc_pwm/#servomotor","title":"Servomotor","text":"<p>El servomotor que utilizaremos el SG-90, es un servomotor b\u00e1sico.</p> <p></p> <p>Este motor necesita la siguiente se\u00f1al para poder generar su desplazamiento:</p> <p></p> <p>Atenci\u00f3n</p> <p>Un servomotor solo se puede desplazar desde 0\u00b0 hasta 180\u00b0. Por default siempre esta en 90\u00b0. Pero, com\u00fanmente se considera 0\u00b0, dado que gira hasta 90\u00b0 y -90\u00b0.</p> <p>Fuente adicional de 5V</p> <p>Para hacer funcionar el servomotor se debe implementar una fuente adicional de 5V, ya que la propia placa NodeMCU no puede dar la suficiente corriente al motor y su sistema para funcionar adecuadamente.</p> <p>Note</p> <p>El dato m\u00ednimo que equivale a 0 grados es 25 en el valor de PWM, y para los 180 grados o m\u00e1ximo es de 127. Estos valores los obtuve haciendo experimentos y pruebas con estos elementos.</p> Angulo PWM 0 grados 25 90 grados 76 180 grados 127 <p>Note</p> <p>Descargar librer\u00eda. Dar click aqui</p> <p>Note</p> <p></p>"},{"location":"Capitulo%202/05_adc_pwm/#servomotor-basico","title":"Servomotor b\u00e1sico","text":"<p>Se realiza un movimiento de ida y vuelta en el servomotor, de manera autom\u00e1tica.</p> <p>Warning</p> <p>Se necesita un fuente externa de 5V para el correcto funcionamiento del servomotor.</p> <p>Animaci\u00f3n</p> <p></p> <p>Diagrama pict\u00f3rico</p> <p></p> <p>C\u00f3digo</p> <pre><code>#include &lt;ESP32Servo.h&gt;\n\nint pos = 0;    // variable que guarda la posicion del servo\n\n#define SERVO_PIN 25\n\n// Los GPIO recomendados para colocar el Servo en ESP32 2,4,12-19,21-23,25-27,32-33\nServo myservo;  // Crea el objeto para el control del servomotor\n// Puede controlar hasta 16 servos\n\nvoid setup() {\n  // permite el uso de todos los timer, simpre deja esta seccion, y no preguntes por qu\u00e9\n  ESP32PWM::allocateTimer(0);\n  ESP32PWM::allocateTimer(1);\n  ESP32PWM::allocateTimer(2);\n  ESP32PWM::allocateTimer(3);\n  myservo.setPeriodHertz(50);    // estandar de trabajo del servo es a 50 hz\n  myservo.attach(SERVO_PIN, 500, 2400); // configuramos el objeto del servo\n  // por default se usa min/max de 1000us and 2000us\n  // Si usas otro servo se deben ajustar los tiempos para el giro de 180 grados\n}\n\nvoid loop() {\n\n  for (pos = 0; pos &lt;= 180; pos += 1) { // va desde 0 a 180 grados\n    // in steps of 1 degree\n    myservo.write(pos);    // le indica al servo en donde colocarse\n    delay(15);             // espera 15ms para la siguiente posicion\n  }\n  for (pos = 180; pos &gt;= 0; pos -= 1) { // va desde 180 a 0 grados\n    myservo.write(pos);    // le indica al servo en donde colocarse\n    delay(15);             // espera 15ms para la siguiente posicion\n  }\n}\n</code></pre>"},{"location":"Capitulo%202/05_adc_pwm/#control-de-giro-de-servomotor-con-potenciometro","title":"Control de giro de Servomotor con potenci\u00f3metro","text":"<p>Se va a realizar un control de la posici\u00f3n del servo en funci\u00f3n de la posici\u00f3n de un potenci\u00f3metro</p> <p>Warning</p> <p>Se necesita un fuente externa de 5V para el correcto funcionamiento del servomotor.</p> <p>Diagrama pict\u00f3rico</p> <p></p> <p>Animaci\u00f3n</p> <p></p> <p>C\u00f3digo</p> <pre><code>#include &lt;ESP32Servo.h&gt;\n\nServo myservo;  // Crea el objeto para el control del servomotor\n\n#define SERVO 25 // pin donde colocamos el servo\n#define POT  34\n\nvoid setup() {\n  // permite el uso de todos los timer, simpre deja esta seccion, y no preguntes por qu\u00e9\n  ESP32PWM::allocateTimer(0);\n  ESP32PWM::allocateTimer(1);\n  ESP32PWM::allocateTimer(2);\n  ESP32PWM::allocateTimer(3);\n  myservo.setPeriodHertz(50);// est\u00e1ndar de trabajo del servo es a 50 hz\n  myservo.attach(SERVO, 500, 2400);   // usando el SG90 servo min/max de 500us y 2400us\n  // para MG995 servo, usa 1000us y 2000us\n}\n\nvoid loop() {\n\n  int val = analogRead(POT);            // Lee el valor del potenci\u00f3metro\n  val = map(val, 0, 4096, 0, 180);     // Convierte el valor de ADC a grados\n  myservo.write(val);                  // ajusta los grados que colocara el servo\n  delay(200);                          //espera 200mS para hacer el cambio\n}\n</code></pre>"},{"location":"Capitulo%202/05_adc_pwm/#control-de-velocidad-de-motor-dc","title":"Control de velocidad de Motor DC","text":"<p>Vamos a realizar un control de velocidad con un motor DC, utilizando un potenci\u00f3metro para definir la velocidad y mostrando la velocidad en una pantalla LCD</p> <p>Diagrama pict\u00f3rico</p> <p>Animaci\u00f3n</p> <p>C\u00f3digo</p>"},{"location":"Capitulo%202/06_analog_ex/","title":"Ejercicios con IO Anal\u00f3gicas","text":""},{"location":"Capitulo%202/06_analog_ex/#lamparas-del-parque","title":"L\u00e1mparas del parque","text":"<p>Realizar el siguiente ejercicio, ver la animaci\u00f3n</p> <p></p> <p></p> <p>Funcionamiento</p> <ol> <li>Cuando exista poca luz en el sensor (esto definido por el programador), se deben encender todas las lamparas (los LEDs), de forma secuencial e ir quedando encendidas hasta que est\u00e9n todas prendidas.</li> <li>Si hay una luz intermedia, solo deben estar encendidas 2 lamparas.</li> <li>Si hay suficiente luz en el ambiente, deben continuar apagadas.</li> <li>Al momento en apagarse, se ir\u00e1n apagando una a una, hasta que al final queden apagadas.</li> </ol>"},{"location":"Capitulo%202/07_teoria_sensores/","title":"Sensores - Introducci\u00f3n","text":"<p>Un sensor en es un sistema el cual capta una variable f\u00edsica y reacciona para la activaci\u00f3n de un actuador. Las partes generales de un sensor son:</p> <ul> <li>Transductor</li> <li>Acoplamiento de se\u00f1al del transductor</li> <li>Salida (Pasa la se\u00f1al o acciona un actuador)</li> </ul> <p></p> <p>Un sensor es todo aquello que tiene una propiedad sensible a una magnitud del medio, y al variar esta magnitud tambi\u00e9n var\u00eda con cierta intensidad la propiedad, es decir, manifiesta la presencia de dicha magnitud, y tambi\u00e9n su medida...wikipedia</p>"},{"location":"Capitulo%202/07_teoria_sensores/#variable-fisica","title":"Variable f\u00edsica","text":"<p>Existen 6 variables fundamentales que podemos captar que son:</p> <ul> <li>Temperatura (Calor, frio)</li> <li>Caudal (Flujo)</li> <li>Presi\u00f3n (Masa)</li> <li>Radiaci\u00f3n (Luz,...)</li> <li>Velocidad (velocidad, aceleraci\u00f3n)</li> <li>Nivel</li> </ul> <p>Existen muchas m\u00e1s, pero solo hago menci\u00f3n de las mas b\u00e1sicas en instrumentaci\u00f3n.</p>"},{"location":"Capitulo%202/07_teoria_sensores/#transductor","title":"Transductor","text":"<p>Un transductor es un elemento que es capaz de captar una variable f\u00edsica (temperatura, presi\u00f3n, flujo, etc..) convirti\u00e9ndola en una se\u00f1al el\u00e9ctrica (corriente o voltaje). Sin embargo, normalmente la se\u00f1al generada es muy peque\u00f1a, por ende, se debe mandar a una etapa de amplificaci\u00f3n. La se\u00f1al el\u00e9ctrica o su variaci\u00f3n siempre se da por alg\u00fan efecto qu\u00edmico en su interior por su constituci\u00f3n f\u00edsica.</p> <p>Ejemplos:</p> <ul> <li>LDR (Resistencia dependiente de luz): En funci\u00f3n de la luz que incide por su ventana es el valor ohmico que representa al pasar la corriente</li> </ul> <p></p> <ul> <li>Termocupla o termopar: Es la union de dos conductores de diferente composici\u00f3n qu\u00edmica.</li> </ul> <p></p> <ul> <li>Pizoelectrico: Es una lamina o material que al deformarse genera un nivel de voltaje.</li> </ul> <p></p>"},{"location":"Capitulo%202/07_teoria_sensores/#transductor-pasivo-vs-activo","title":"Transductor Pasivo vs Activo","text":"<p>Existen dos tipos de transductores los cuales pueden ser pasivos o activos esto significa la forma en c\u00f3mo vamos a leer su se\u00f1al o adquirirla, en funci\u00f3n de ello vamos a acoplar, qu\u00e9 tipo es y amplificaci\u00f3n.</p>"},{"location":"Capitulo%202/07_teoria_sensores/#pasivos","title":"Pasivos","text":"<p>Los <code>transductores pasivos</code> son aquellos los cuales para poder leer o conocer la variable f\u00edsica, se le debe aplicar un voltaje o corriente constante, para que en funci\u00f3n de la variaci\u00f3n de este voltaje o corriente que aplicamos podamos calcular su equivalencia o proporci\u00f3n a dicha variable. Es decir, este tipo de transductor no es capaz de generar un voltaje o corriente la cual nos indique el valor de la magnitud f\u00edsica.</p> <p>El ejemplo m\u00e1s com\u00fan es una LDR, la cual se debe aplicar en un divisor de tensi\u00f3n, y en funci\u00f3n de la variaci\u00f3n del luz har\u00e1 variar el voltaje de la salida del voltaje.</p> <p></p> <p>Como se puede observar en el circuito tenemos un divisor de tension din\u00e1mico que oscila el voltaje en funci\u00f3n de la entrada de luz, esta salida normalmente va a otra etapa de amplificaci\u00f3n.</p>"},{"location":"Capitulo%202/07_teoria_sensores/#activos","title":"Activos","text":"<p>Los <code>transductores activos</code> generan energ\u00eda de forma natural, generando un voltaje o corriente al ser expuesto al contexto. Sin embargo, esta se\u00f1al es demasiado peque\u00f1a para poder ser le\u00eddo o un elemento digital o cualquier otro elemento.</p> <p>El ejemplo m\u00e1s com\u00fan es un termopar o termocupla, la cual esta constituida por 2 alambres de diferentes elementos qu\u00edmicos. Al se expuesto a altas temperatura genera un mili voltaje.</p> <p></p> <p>Como podemos observar al unir dos alambres de elementos distintos, al calentarse estos generan una diferencia de potencial.</p> <p>Aqu\u00ed tenemos un circuito de ejemplo de acoplamiento de una termocupla con su etapa de amplificaci\u00f3n.</p> <p></p>"},{"location":"Capitulo%202/07_teoria_sensores/#sensores-digitales-vs-analogicos","title":"Sensores Digitales vs Anal\u00f3gicos","text":"<p>En general todos los transductores son anal\u00f3gicos, pero generan una se\u00f1al muy peque\u00f1a, se necesita acoplar una o dos etapas de amplificaci\u00f3n para tener un voltaje mayor equivalente. Pero justamente aqu\u00ed al final de esa etapa la se\u00f1al se puede enfocar para generar solo <code>se\u00f1ales digitales</code>, es decir, <code>un nivel alto o bajo</code>, o en su defecto generar un <code>rango de voltaje</code>, estos ser\u00edan los <code>anal\u00f3gicos</code></p>"},{"location":"Capitulo%202/07_teoria_sensores/#sensores-digitales","title":"Sensores Digitales","text":"<p>Los sensores digitales solo pueden generar 2 tipos de se\u00f1al, sea un <code>1</code> o un <code>0</code>. Existen rangos de voltajes que si est\u00e1n en un rango se consideran <code>1 l\u00f3gico</code> o <code>0 l\u00f3gico</code>. A un rango se le conoce como voltajes TTL.</p> Nivel l\u00f3gico Voltaje 1 3V a 5V 0 0V a 0.8V <p>Debemos conocer que tipo de sistema digital estamos empleando y verificar nuestro sensor para asegurar que se puede acoplar directamente o tendremos que acoplar esta se\u00f1al al nivel que deseamos.</p> <p></p>"},{"location":"Capitulo%202/07_teoria_sensores/#sensores-digitales-basicos-vs-protocolos","title":"Sensores digitales b\u00e1sicos vs protocolos","text":"<p>Los sensores digitales b\u00e1sicos solo nos da una se\u00f1al l\u00f3gica, esto significa que tiene 2 estados, indicando si existe o no existe la variable o la magnitud f\u00edsica, si m\u00e1s.</p> <p>Sensores b\u00e1sicos </p> <p>Ejemplo:</p> <ul> <li>Sensor PIR: Indica si existe presencia o no.</li> </ul> <p></p> <ul> <li>Sensor de Flama: Indica si existe flama o no. Este por su naturaleza da un rango de voltaje, entonces se debe calibrar en que punto se dispara indicando si sobrepasa este punto o no.</li> </ul> <p></p> <ul> <li>Sensor de luz: Indica si existe luz o no. Este por su naturaleza da un rango de voltaje, entonces se debe calibrar en que punto se dispara indicando si sobrepasa este punto o no.</li> </ul> <p></p>"},{"location":"Capitulo%202/07_teoria_sensores/#los-sensores-digitales-con-comunicacion-por-protocolo","title":"Los sensores digitales con comunicaci\u00f3n por protocolo","text":"<p>Son sensores que internamente son mas complejos, estos ademas de contener su etapa del transductor, amplificaci\u00f3n, acoplamiento, tienen un etapa de comunicaci\u00f3n por medio de alg\u00fan protocolo de comunicaci\u00f3n:</p> <p>Sensores con protocolo de comunicaci\u00f3n:</p> <ul> <li>DS18B20: Sensor de temperatura con protocolo 1 Wire</li> </ul> <p></p> <ul> <li>BME280:: Sensor de presi\u00f3n, humedad y temperatura con protocolo I2C.</li> </ul> <p></p> <ul> <li>MAX31855K: Sensor de temperatura con protocolo SPI</li> </ul> <p></p>"},{"location":"Capitulo%202/07_teoria_sensores/#sensores-analogicos","title":"Sensores Anal\u00f3gicos","text":"<p>Los sensores anal\u00f3gicos nos proveen un rango de voltaje en el que operan, este voltaje es proporcional la variable o magnitud f\u00edsica que esta censando. Los sensores que son empleados a sistemas digitales trabajan habitualmente en un rango de <code>0V a 5V</code> o <code>0V a 3.3V</code>, estos rangos son comunes pero no los \u00fanicos. En ocasiones tenemos que amplificar este rango para que se pueda aprovechar de mejor manera.</p> <p></p> <p>Pero este rango de voltaje no se puede mandar directamente al sistema digital antes debe pasar por otro elemento que haga la conversion a un sistema digital, estos elementos se llaman ADC, este elemento hace posible que el microcontrolador pueda entender la se\u00f1al anal\u00f3gica.</p> <p></p>"},{"location":"Capitulo%202/07_teoria_sensores/#actuadores-electricos-o-electronicos","title":"Actuadores el\u00e9ctricos o electr\u00f3nicos","text":"<p>El actuador es el elemento que act\u00faa o realiza una acci\u00f3n a la salida de un sensor, no siempre viene el actuador incorporado al sensor.</p> <p>Los actuadores m\u00e1s comunes son:</p> <ul> <li>Relay</li> <li>Solenoide</li> <li>Bocina</li> <li>LED</li> <li>Buzzer</li> </ul> <p>Aqu\u00ed se pueden ver varios circuitos de sensores:</p> <p>Sensor crepuscular</p> <p></p> <p>Sensor de temperatura</p> <p></p>"},{"location":"Capitulo%202/07_teoria_sensores/#lista-de-sensores-comunes","title":"Lista de sensores comunes","text":"<p>Realizado por Docente: Alejandro Leyva</p> <p>Mecatr\u00f3nica 85</p> <p>fb/mecatronica85</p>"},{"location":"Capitulo%202/08_sensores/","title":"Sensores - Aplicaci\u00f3n","text":""},{"location":"Capitulo%202/08_sensores/#sensores-digitales","title":"Sensores digitales","text":"<p>Usaremos diversos sensores para controlar distintos elementos.</p>"},{"location":"Capitulo%202/08_sensores/#teclado-matricial-4x4","title":"Teclado matricial 4x4","text":"<p>Note</p> <p>En ocasiones NO se encuentra la librer\u00eda en el IDE, puedes instalarla desde el \"Gestor de bibliotecas\"</p> <p></p> <p>Note</p> <p>De otra forma, puedes descarga la librer\u00eda y realizar la instalaci\u00f3n manual. Dar click aqu\u00ed</p> <p>Aqu\u00ed vamos a probar el correcto conexionado y funcionamiento del teclado, imprimiendo por monitor serial la tecla presionada.</p> <p>Diagrama pict\u00f3rico</p> <p></p> <p>C\u00f3digo</p> <pre><code>#include &lt;Keypad.h&gt; // importamos la librer\u00eda para utilizar el teclado\n\n#define ROW_NUM     4 // indicamos el numero de renglones del teclado\n#define COLUMN_NUM  4 // indicamos el numero de columnas del teclado\n\nchar keys[ROW_NUM][COLUMN_NUM] = { // indicamos las letras que tiene el teclado, estas se pueden cambiar\n  {'1', '2', '3', 'A'},\n  {'4', '5', '6', 'B'},\n  {'7', '8', '9', 'C'},\n  {'*', '0', '#', 'D'}\n};\n\nbyte pin_rows[ROW_NUM]      = {19, 18, 5, 17}; // indicamos los pines que se usaran para los renglones\nbyte pin_column[COLUMN_NUM] = {16, 4, 0, 2};   // indicamos los pines que se usaran para las columnas\n\nKeypad keypad = Keypad( makeKeymap(keys), pin_rows, pin_column, ROW_NUM, COLUMN_NUM ); // se crea y configura el objeto para el uso del teclado\n\nvoid setup() {\n  Serial.begin(115200);\n}\n\nvoid loop() {\n  char key = keypad.getKey(); // esperemos la tecla que se presiono\n\n  if (key) { // si presionaron una tecla, entra al bloque del if\n    Serial.println(key); // se imprime la tecla que fue presionada\n  }\n}\n</code></pre>"},{"location":"Capitulo%202/08_sensores/#cerradura-basica","title":"Cerradura b\u00e1sica","text":"<p>Haremos una cerradura b\u00e1sica, en la cual si se colocar la contrase\u00f1a correcta se encender\u00e1 un led 3 veces cada medio segundo, esto indica que la contrase\u00f1a fue correctamente colocada. En caso que la contrase\u00f1a se incorrecta, parpadeara el led, indicando que la contrase\u00f1a fue incorrecta. Tendremos todo el feedback en el monitor serial.</p> <p>Diagrama pict\u00f3rico</p> <p></p> <p>C\u00f3digo</p> <pre><code>#include &lt;Keypad.h&gt; // importamos la librer\u00eda para utilizar el teclado\n\n#define ROW_NUM     4 // indicamos el numero de renglones del teclado\n#define COLUMN_NUM  4 // indicamos el numero de columnas del teclado\n\nchar keys[ROW_NUM][COLUMN_NUM] = { // indicamos las letras que tiene el teclado, estas se pueden cambiar\n  {'1', '2', '3', 'A'},\n  {'4', '5', '6', 'B'},\n  {'7', '8', '9', 'C'},\n  {'*', '0', '#', 'D'}\n};\n\nbyte pin_rows[ROW_NUM]      = {19, 18, 5, 17}; // indicamos los pines que se usaran para los renglones\nbyte pin_column[COLUMN_NUM] = {16, 4, 0, 2};   // indicamos los pines que se usaran para las columnas\n\nKeypad keypad = Keypad( makeKeymap(keys), pin_rows, pin_column, ROW_NUM, COLUMN_NUM );  // se crea y configura el objeto para el uso del teclado\n\n\nconst String password = \"7890\"; // Aqu\u00ed el password super secreto\nString input_password;\n\n#define LED 25\n\nvoid setup() {\n  Serial.begin(115200);\n  pinMode(LED, OUTPUT);\n  Serial.println(\"------------------------\");\n  Serial.println(\"El password es de 4 digitos\");\n  Serial.println(\"Presionar # para aceptar el password\");\n  Serial.println(\"Presionar * para cancelar y volver a escribir el password\");\n  Serial.println(\"------------------------\");\n  Serial.println(\"Introduccir el password\");\n  Serial.println(\"------------------------\");\n}\n\nvoid loop() {\n  char key = keypad.getKey(); // esperemos la tecla que se presiono\n\n  if (key) {\n    Serial.print(key);\n\n    if (key == '*') {\n      input_password = \"\"; // clear input password\n      Serial.println(\"cancelado\");\n      Serial.println(\"\");\n    } else if (key == '#') {\n      Serial.println(\"\");\n      if (password == input_password) {\n        Serial.println(\"The password CORRECTO!!\");\n        digitalWrite(LED, HIGH);\n        delay(500);\n        digitalWrite(LED, LOW);\n        delay(500);\n        digitalWrite(LED, HIGH);\n        delay(500);\n        digitalWrite(LED, LOW);\n        delay(500);\n        digitalWrite(LED, HIGH);\n        delay(500);\n        digitalWrite(LED, LOW);\n        delay(500);\n      } else {\n        Serial.println(\"The password INCORRECTO!\");\n        digitalWrite(LED, HIGH);\n        delay(250);\n        digitalWrite(LED, LOW);\n        delay(250);\n        digitalWrite(LED, HIGH);\n        delay(250);\n        digitalWrite(LED, LOW);\n        delay(250);\n        digitalWrite(LED, HIGH);\n        delay(250);\n        digitalWrite(LED, LOW);\n        delay(250);\n      }\n      Serial.println(\"------------------------\");\n      Serial.println(\"El password es de 4 digitos\");\n      Serial.println(\"Presionar # para aceptar el password\");\n      Serial.println(\"Presionar * para cancelar y volver a escribir el password\");\n      Serial.println(\"------------------------\");\n      Serial.println(\"Introduccir el password\");\n      Serial.println(\"------------------------\");\n      input_password = \"\"; // se limpia el contenido\n    } else {\n      input_password += key; // va juntando los caracteres\n    }\n  }\n}\n</code></pre>"},{"location":"Capitulo%202/08_sensores/#sensor-de-flama","title":"Sensor de flama","text":"<p>El sensor de flama va detectar cuando exista fuego, haciendo sonar una alarma y una lampara de emergencia (LED). Cuando ya no detecte peligro se apagar\u00e1.</p> <p>Diagrama pict\u00f3rico</p> <p></p> <p>C\u00f3digo</p> <pre><code>// defino los pines que se usaran para el sensor, buzzer y l\u00e1mpara\n#define BUZZER 25\n#define LAMP 26\n#define FLAME_SENSOR 34\n\nvoid setup() {\n  //configuro e inicio la comunicacion serial\n  Serial.begin(115200);\n\n  //configuro los pines como entradas y salidas\n  pinMode(BUZZER, OUTPUT);\n  pinMode(LAMP, OUTPUT);\n  pinMode(FLAME_SENSOR, INPUT);\n\n}\n\nvoid loop() {\n\n  // si detecta flama enciende la lampara y suena la alarma\n  if (digitalRead(FLAME_SENSOR) == 1 ) {\n    digitalWrite(LAMP, HIGH);\n    digitalWrite(BUZZER, HIGH);\n    delay(250);\n    digitalWrite(BUZZER, LOW);\n    delay(250);\n    digitalWrite(BUZZER, HIGH);\n    delay(250);\n    digitalWrite(BUZZER, LOW);\n    delay(250);\n    digitalWrite(BUZZER, HIGH);\n    delay(250);\n    digitalWrite(BUZZER, LOW);\n    delay(250);\n  } else { // de lo contrario esta apagado todo\n    digitalWrite(LAMP, LOW);\n    digitalWrite(BUZZER, LOW);\n    delay(1000); //espero 1 segundo para volver a detectar el sensor\n  }\n  delay(250);\n}\n</code></pre>"},{"location":"Capitulo%202/08_sensores/#sensor-pir-hc-sr501-sensor-de-presencia","title":"Sensor PIR HC-SR501 (Sensor de presencia)","text":"<p>C\u00f3digo</p> <pre><code>#define PIR 34 //defino el pin para el sensor PIR\n#define LED 25 //defino el pin para el LED\n\nvoid setup() {\n  Serial.begin(115200);\n  pinMode(PIR, INPUT);\n  pinMode(LED, OUTPUT);\n\n}\n\nvoid loop() {\n  if(digitalRead(PIR) == 1){\n    digitalWrite(LED, HIGH);\n    Serial.println(\"Hay presencia\");\n    delay(1000);\n  }else{\n    digitalWrite(LED, LOW);\n  }\n  delay(10);\n}\n</code></pre>"},{"location":"Capitulo%202/08_sensores/#sensor-de-temperatura-y-humedad-dth11","title":"Sensor de Temperatura y Humedad DTH11","text":"<p>Warning</p> <p>Se deben agregar una librer\u00edas para usar este sensor. Click aqu\u00ed, agregarlas a tu IDE, de lo contrario no funcionara el c\u00f3digo de ejemplo.</p> <p></p> <p></p> <pre><code>#include &lt;Adafruit_Sensor.h&gt;\n#include &lt;DHT.h&gt;\n#include &lt;DHT_U.h&gt;\n\n#define DHTPIN 2     // El pin que se usara para comunicar al sensor con el micro\n\n#define DHTTYPE    DHT11   // se define que sensor se usara (tenemos el DHT22, FHT21)\n\nDHT_Unified dht(DHTPIN, DHTTYPE); // Se crea el objeto con los valores indicados para que se configure el sensor a usar\n\nuint32_t delayMS;\n\nvoid setup() {\n  Serial.begin(115200);\n  // Initialize device.\n  dht.begin(); //inicializamos al sensor\n  Serial.println(F(\"Sensor DHT11\"));\n  // Print temperature sensor details.\n  sensor_t sensor;\n  dht.temperature().getSensor(&amp;sensor);\n  Serial.println(F(\"------------------------------------\"));\n  Serial.println(F(\"Temperature Sensor\"));\n  Serial.print  (F(\"Sensor Tipo: \")); Serial.println(sensor.name);\n  Serial.print  (F(\"Driver Ver:  \")); Serial.println(sensor.version);\n  Serial.print  (F(\"ID:   \")); Serial.println(sensor.sensor_id);\n  Serial.print  (F(\"Valor Max:   \")); Serial.print(sensor.max_value); Serial.println(F(\"\u00b0C\"));\n  Serial.print  (F(\"Valor Min:   \")); Serial.print(sensor.min_value); Serial.println(F(\"\u00b0C\"));\n  Serial.print  (F(\"Resolution:  \")); Serial.print(sensor.resolution); Serial.println(F(\"\u00b0C\"));\n  Serial.println(F(\"------------------------------------\"));\n  // Print humidity sensor details.\n  dht.humidity().getSensor(&amp;sensor);\n  Serial.println(F(\"Humidity Sensor\"));\n  Serial.print  (F(\"Sensor Type: \")); Serial.println(sensor.name);\n  Serial.print  (F(\"Driver Ver:  \")); Serial.println(sensor.version);\n  Serial.print  (F(\"Unique ID:   \")); Serial.println(sensor.sensor_id);\n  Serial.print  (F(\"Max Value:   \")); Serial.print(sensor.max_value); Serial.println(F(\"%\"));\n  Serial.print  (F(\"Min Value:   \")); Serial.print(sensor.min_value); Serial.println(F(\"%\"));\n  Serial.print  (F(\"Resolution:  \")); Serial.print(sensor.resolution); Serial.println(F(\"%\"));\n  Serial.println(F(\"------------------------------------\"));\n  // Set delay between sensor readings based on sensor details.\n  delayMS = sensor.min_delay / 1000;\n}\n\nvoid loop() {\n  // Delay between measurements.\n  delay(delayMS);\n  // Get temperature event and print its value.\n  sensors_event_t event;\n  dht.temperature().getEvent(&amp;event);\n  if (isnan(event.temperature)) {\n    Serial.println(F(\"Error reading temperature!\"));\n  }\n  else {\n    Serial.print(F(\"Temperature: \"));\n    Serial.print(event.temperature);\n    Serial.println(F(\"\u00b0C\"));\n  }\n  // Get humidity event and print its value.\n  dht.humidity().getEvent(&amp;event);\n  if (isnan(event.relative_humidity)) {\n    Serial.println(F(\"Error reading humidity!\"));\n  }\n  else {\n    Serial.print(F(\"Humidity: \"));\n    Serial.print(event.relative_humidity);\n    Serial.println(F(\"%\"));\n  }\n}\n</code></pre>"},{"location":"Capitulo%202/08_sensores/#sensor-ultrasonico-hc-sr04","title":"Sensor Ultras\u00f3nico HC-SR04","text":"<p>Note</p> <p>Agregar la librer\u00eda de manera manual. Dar click aqu\u00ed</p> <p>Note</p> <p>Abrir el \"Gestor de Librer\u00edas\" y buscar como se muestra.</p> <p></p>"},{"location":"Capitulo%202/08_sensores/#distancia-con-sensor-ultrasonico","title":"Distancia con sensor Ultras\u00f3nico","text":"<p>Diagrama pict\u00f3rico</p> <p></p> <p>Animaci\u00f3n</p> <p></p> <pre><code>#include &lt;NewPing.h&gt;\n\n#define TRIGGER_PIN  4  // Pin que se usara para el TRIGGER que recibe el sensor\n#define ECHO_PIN     2  // Pin que se usara el el ECHO que enviara el sensor\n#define MAX_DISTANCE 400 // Distancia maxima que puede medir el sensor\n\nNewPing ultrasonico(TRIGGER_PIN, ECHO_PIN, MAX_DISTANCE); // Se configura el objeto del sensor que usara los datos\n\nvoid setup() {\n  Serial.begin(115200);\n}\n\nfloat duracion, distancia;\n\nvoid loop() {\n\n  duracion = ultrasonico.ping();\n\n  distancia = (duracion / 2) * 0.0343;\n  Serial.print(\"Distancia: \");\n\n  if (distancia &gt;= 400 || distancia &lt;= 2) {\n    Serial.println(\"Fuera de rango\");\n  } else {\n    Serial.print(distancia);\n    Serial.println(\" cm\");\n    delay(500);\n  }\n\n  delay(500);\n}\n</code></pre>"},{"location":"Capitulo%202/08_sensores/#barra-de-leds-con-ultrasonico","title":"Barra de leds con Ultrasonico","text":"<p>Diagrama pict\u00f3rico</p> <p></p> <p>Animaci\u00f3n</p> <p></p> <pre><code>#include &lt;NewPing.h&gt;\n\n#define TRIGGER_PIN  4  // Pin que se usara para el TRIGGER que recibe el sensor\n#define ECHO_PIN     2  // Pin que se usara el el ECHO que enviara el sensor\n#define MAX_DISTANCE 400 // Distancia maxima que puede medir el sensor\n\nNewPing ultrasonico(TRIGGER_PIN, ECHO_PIN, MAX_DISTANCE); // Se configura el objeto del sensor que usara los datos\n\n#define NO_LEDS 7\nconst int PINS[] = {32, 33, 25, 26, 27, 12, 14}; //pines para leds\n\n\nvoid setup() {\n  Serial.begin(115200);\n  for (char x = 0; x &lt; NO_LEDS; x++) {\n    pinMode(PINS[x], OUTPUT);\n  }\n}\n\nvoid loop() {\n\n  float distancia = (ultrasonico.ping() / 2) * 0.0343;\n  Serial.print(\"Distancia: \");\n\n  if (distancia &gt;= 400 || distancia &lt;= 2) {\n    Serial.println(\"Fuera de rango\");\n\n    for (char x = 0; x &lt; NO_LEDS; x++) {\n      digitalWrite(PINS[x], HIGH);\n    }\n    delay(250);\n    for (char x = 0; x &lt; NO_LEDS; x++) {\n      digitalWrite(PINS[x], LOW);\n    }\n    delay(250);\n\n  } else {\n    Serial.print(distancia);\n    Serial.println(\" cm\");\n\n    if (distancia &lt; 50) {\n      const int LEVEL = 1;\n\n      for (char x = 0; x &lt; LEVEL; x++) {\n        digitalWrite(PINS[x], HIGH);\n      }\n      delay(100);\n      for (char x = LEVEL; x &lt; NO_LEDS; x++) {\n        digitalWrite(PINS[x], LOW);\n      }\n    } else if (distancia &gt;= 50 &amp;&amp; distancia &lt; 100) {\n      const int LEVEL = 2;\n\n      for (char x = 0; x &lt; LEVEL; x++) {\n        digitalWrite(PINS[x], HIGH);\n      }\n      delay(100);\n      for (char x = LEVEL; x &lt; NO_LEDS; x++) {\n        digitalWrite(PINS[x], LOW);\n      }\n    } else if (distancia &gt;= 100 &amp;&amp; distancia &lt; 150) {\n      const int LEVEL = 3;\n\n      for (char x = 0; x &lt; LEVEL; x++) {\n        digitalWrite(PINS[x], HIGH);\n      }\n      delay(100);\n      for (char x = LEVEL; x &lt; NO_LEDS; x++) {\n        digitalWrite(PINS[x], LOW);\n      }\n    } else if (distancia &gt;= 150 &amp;&amp; distancia &lt; 200) {\n      const int LEVEL = 4;\n\n      for (char x = 0; x &lt; LEVEL; x++) {\n        digitalWrite(PINS[x], HIGH);\n      }\n      delay(100);\n      for (char x = LEVEL; x &lt; NO_LEDS; x++) {\n        digitalWrite(PINS[x], LOW);\n      }\n    } else if (distancia &gt;= 200 &amp;&amp; distancia &lt; 250) {\n      const int LEVEL = 5;\n\n      for (char x = 0; x &lt; LEVEL; x++) {\n        digitalWrite(PINS[x], HIGH);\n      }\n      delay(100);\n      for (char x = LEVEL; x &lt; NO_LEDS; x++) {\n        digitalWrite(PINS[x], LOW);\n      }\n    } else if (distancia &gt;= 250 &amp;&amp; distancia &lt; 300) {\n      const int LEVEL = 6;\n\n      for (char x = 0; x &lt; LEVEL; x++) {\n        digitalWrite(PINS[x], HIGH);\n      }\n      delay(100);\n      for (char x = LEVEL; x &lt; NO_LEDS; x++) {\n        digitalWrite(PINS[x], LOW);\n      }\n    } else {\n      const int LEVEL = 7;\n\n      for (char x = 0; x &lt; LEVEL; x++) {\n        digitalWrite(PINS[x], HIGH);\n      }\n      delay(100);\n      for (char x = LEVEL; x &lt; NO_LEDS; x++) {\n        digitalWrite(PINS[x], LOW);\n      }\n    }\n    delay(500);\n  }\n\n  delay(10);\n}\n</code></pre>"},{"location":"Capitulo%202/08_sensores/#sensor-ds18b20-sensor-de-temperatura","title":"Sensor DS18B20 - Sensor de temperatura","text":"<p>Note</p> <p>Agregar la librer\u00eda de manera manual. Dar click aqu\u00ed</p> <p>Note</p> <p>Abrir el \"Gestor de Librer\u00edas\" y buscar como se muestra.</p> <p></p> <p></p> <p>Warning</p> <p>Se necesita agregarle una resistencia de pull-up al pin de se\u00f1al, de lo contrario funcionara mal. <code>La resistencia es de</code> \\(4.7k\\Omega\\)</p> Pines DS18B20 <p>Descripci\u00f3n del encapsulado. Hacer los ajustes necesarios</p> <p></p> <p>Vamos a realizar un lectura b\u00e1sica de la temperatura con el sensor de Dallas DS18B20 y mandar el valor al monitor serial</p> <p>Diagrama pict\u00f3rico</p> <p></p> <p>C\u00f3digo</p> <pre><code>// Se deben incluir estas librer\u00edas para el control del sensor\n#include &lt;OneWire.h&gt; // conexi\u00f3n de one wire para la comunicaci\u00f3n\n#include &lt;DallasTemperature.h&gt; // lib que se encarga de transformar el dato al valor de temperatura\n\n// definimos el pin que usaremos para la comunicaci\u00f3n con el sensor\n#define ONE_WIRE_BUS 25\n\n// se configura la instancia (el objeto) para la comunicaci\u00f3n con el protocolo one wire\nOneWire oneWire(ONE_WIRE_BUS);\n\n// se pasa la referencia a la lib de Dallas, que recibir\u00e1 los datos del sensor y hacer la conversi\u00f3n\nDallasTemperature sensors(&amp;oneWire);\n\nvoid setup(void) {\n  Serial.begin(115200); // Se configura la comunicaci\u00f3n serial\n\n  //se arranca y configura la comunicaci\u00f3n con el sensor de temperatura\n  sensors.begin();\n}\n\nvoid loop(void) {\n  Serial.print(\"Obteniendo temperatura...\");\n  sensors.requestTemperatures(); // se hace la solicitud de temperatura al sensor\n\n  // se obtiene la temperatura en grados Celsius del sensor que hay (se le pasa 0 porque solo tenemos un sensor)\n  float tempC = sensors.getTempCByIndex(0);\n\n  // se verifica si el valor es correcto\n  if (tempC != DEVICE_DISCONNECTED_C) {\n    Serial.print(\"La temperatura es: \");\n    Serial.println(tempC);\n  }\n  else  {\n    Serial.println(\"Error: No se pudo obtener el valor de temperatura\");\n  }\n  delay(5000);\n}\n</code></pre>"},{"location":"Capitulo%202/08_sensores/#sensor-de-sonido","title":"Sensor de Sonido","text":"<p>Vamos a realizar un interruptor por aplausos, con dos aplausos se prende y con otros 2 se apaga el led.</p> <p>Diagrama Pict\u00f3rico</p> <p></p> <p></p> <p>C\u00f3digo</p> <pre><code>//C\u00d3DIGO NO PROBADO \n// C\u00d3DIGO PARA EL SENSOR CON SALIDA ANAL\u00d3GICA\n#define MICROPHONE 34\n#define LED 25\nint clap = 0;\nlong detection_range_start = 0;\nlong detection_range = 0;\nboolean status_lights = false;\n\nvoid setup() {\n  pinMode(MICROPHONE, INPUT);\n  pinMode(LED, OUTPUT);\n}\n\nvoid loop() {\n  int status_microphone = digitalRead(MICROPHONE);\n\n  if (status_microphone == 0) {\n    if (clap == 0) {\n      detection_range_start = detection_range = millis();\n      clap++;\n    }\n    else if (clap &gt; 0 &amp;&amp; millis() - detection_range &gt;= 50) {\n      detection_range = millis();\n      clap++;\n    }\n  }\n\n  if (millis() - detection_range_start &gt;= 400) {\n    if (clap == 2) {\n      if (!status_lights) {\n        status_lights = true;\n        digitalWrite(LED, HIGH);\n      }\n      else if (status_lights) {\n        status_lights = false;\n        digitalWrite(LED, LOW);\n      }\n    }\n    clap = 0;\n  }\n}\n</code></pre>"},{"location":"Capitulo%202/08_sensores/#sensor-de-humedad-de-tierra-higrometro","title":"Sensor de humedad de tierra (Higr\u00f3metro)","text":"<p>Este sensor mide la conductividad de la tierra, es decir, que entre mas seca, menos conduce. Esta medici\u00f3n me esta indicando que har\u00eda falta agua (esto depende de la planta, que tanta agua requiera).</p> <p>Diagrama pict\u00f3rico</p> <p></p> <p>C\u00f3digo</p> <pre><code>#define SENSOR 34\n#define LED 25\n\nvoid setup() {\n  Serial.begin(115200);\n  pinMode(SENSOR, INPUT);\n  pinMode(LED, OUTPUT);\n}\n\nvoid loop() {\n\n  if (humedad == digitalRead(SENSOR)) {\n    Serial.println(\"Tierra seca\");\n    Serial.println(\"Encender bomba\");\n    digitalWrite(LED, HIGH);\n  } else {\n    Serial.println(\"Encender apagada\");\n    digitalWrite(LED, LOW);\n  }\n  delay(1000);\n}\n</code></pre> <p>Diagrama pict\u00f3rico</p> <p></p> <p>C\u00f3digo</p> <pre><code>//Entrada anal\u00f3gica\n#define SENSOR_HUMEDAD 34\n#define LED 25\n\nvoid setup() {\n  Serial.begin(115200);\n  pinMode(LED, OUTPUT);\n}\n\nvoid loop() {\n  int humedad = analogRead(SENSOR_HUMEDAD);\n  Serial.print(humedad);\n\n  if (humedad &lt; 500) {\n    Serial.println(\"Tierra seca\");\n    Serial.println(\"Encender bomba\");\n    digitalWrite(LED, HIGH);\n  }else{\n    Serial.println(\"Encender apagada\");\n    digitalWrite(LED, LOW);\n  }\n\n\n  delay(1000);\n}\n</code></pre>"},{"location":"Capitulo%202/08_sensores/#sensor-de-gas-lp-mq-2","title":"Sensor de Gas LP (MQ-2)","text":"<p>Vamos a realizar una simple alarma que al detectar una fuga de gas, active una alarma sonora, para alarmar al usuario de dicha fuga.</p> <p>Note</p> <p></p> <p>Diagrama Pict\u00f3rico</p> <p></p> <p>C\u00f3digo</p> <pre><code>#define LED  25\n#define BUZZER  26\n#define SENSOR_GAS 34\n#define LIMIT 1200\n\nvoid setup() {\n  Serial.begin(115200);\n  pinMode(LED, OUTPUT);\n}\nvoid loop() {\n\n  int valor = analogRead(SENSOR_GAS);\n\n  Serial.print(\"Gas Sensor: \");\n  Serial.println(valor);\n\n  if (valor &gt; LIMIT) {\n    Serial.println(\"Fuga de Gas\");\n    digitalWrite (LED, HIGH);\n    digitalWrite (BUZZER, HIGH);\n    delay(250);\n    digitalWrite (LED, LOW);\n    digitalWrite (BUZZER, LOW);\n    delay(250);\n    digitalWrite (LED, HIGH);\n    digitalWrite (BUZZER, HIGH);\n    delay(250);\n    digitalWrite (LED, LOW);\n    digitalWrite (BUZZER, LOW);\n    delay(250);\n    digitalWrite (LED, HIGH);\n    digitalWrite (BUZZER, HIGH);\n    delay(250);\n    digitalWrite (LED, LOW);\n    digitalWrite (BUZZER, LOW);\n    delay(250);\n  }\n  else {\n    Serial.println(\"Sin fuga de Gas\");\n    digitalWrite (LED, HIGH) ;\n    digitalWrite (BUZZER, LOW);\n    delay(1000);\n  }\n}\n</code></pre>"},{"location":"Capitulo%202/08_sensores/#tarjeta-rfid","title":"Tarjeta RFID","text":"<p>Note</p> <p>Descarga la librer\u00eda, Dar click aqu\u00ed</p> <p>Note</p> <p></p> <p>Warning</p> <p></p> <p>Note</p> <p>Estas conexiones no pueden cambiar, siempre se debe conectar de esta manera</p> ESP32 &lt;---&gt; RFID 1 3.3V &lt;---&gt; VCC 2 D0 &lt;---&gt; RST 3 GND &lt;---&gt; GND 4 NC &lt;---&gt; IRQ 5 D19 &lt;---&gt; MISO 6 D23 &lt;---&gt; MOSI 7 D18 &lt;---&gt; SCK 8 D5 &lt;---&gt; SDA"},{"location":"Capitulo%202/08_sensores/#dumpeando-los-datos-de-tarjeta-rfid","title":"Dumpeando los datos de tarjeta RFID","text":"<p>Obteniendo todos los datos de la tarjeta o llavero. Mostrando toda la informaci\u00f3n en el monitor serial.</p> <p>Diagrama Pict\u00f3rico</p> <p></p> <p>C\u00f3digo</p> <pre><code>#include &lt;SPI.h&gt;\n#include &lt;MFRC522.h&gt;\n\n#define RST_PIN   0\n#define SS_PIN    5\n\nMFRC522 mfrc522(SS_PIN, RST_PIN);  // Crea el objeto para el m\u00f3dulo RFID\n\nvoid setup() {\n  Serial.begin(115200);     // Inicializa la comunicaci\u00f3n serial\n\n  SPI.begin();          // Inicia la comunicaci\u00f3n de SPI\n  mfrc522.PCD_Init();   // Inicializa la comunicaci\u00f3n con el modulo\n  delay(4);             // un delay para esperar que se configure correctamente el modulo\n  mfrc522.PCD_DumpVersionToSerial();    // Muestra los detalles del modulo MFRC522\n  Serial.println(F(\"Escaneado el PICC para ver el UID, SAK, tipo, bloque de datos...\"));\n}\n//\nvoid loop() {\n  // Resetea en cada vuelta del ciclo, para leer una una tarjeta.\n  if ( ! mfrc522.PICC_IsNewCardPresent()) {\n    return;\n  }\n\n  // Selecciona una tarjeta\n  if ( ! mfrc522.PICC_ReadCardSerial()) {\n    return;\n  }\n\n  // vuelca la informacion encontrada en la tarjeta\n  mfrc522.PICC_DumpToSerial(&amp;(mfrc522.uid));\n}\n</code></pre>"},{"location":"Capitulo%202/08_sensores/#leyendo-el-nuid-de-la-tarjeta-rfid","title":"Leyendo el NUID de la tarjeta RFID","text":"<p>Lo que se realiza es leer la tarjeta, si es diferente a la anterior, te muestra su c\u00f3digo en hexadecimal y decimal, en caso que se la misma tarjeta que se vuelve a pasar por el lector, manda el mensaje de <code>tarjeta le\u00edda</code></p> <pre><code>#include &lt;SPI.h&gt;\n#include &lt;MFRC522.h&gt;\n\n#define RST_PIN   0\n#define SS_PIN    5\n\nMFRC522 rfid(SS_PIN, RST_PIN); // crea el objeto para ocupar el lector\n\nMFRC522::MIFARE_Key key; \n\n// inicializa el array donde se almacenara el NUID\nbyte nuidPICC[4];\n\nvoid setup() { \n  Serial.begin(115200);\n  SPI.begin(); // Inicializa el bus para la comunicaci\u00f3n SPI\n  rfid.PCD_Init(); // Inicializa el modulo MFRC522 \n\n  for (byte i = 0; i &lt; 6; i++) {// crea una llave temporal de referencia\n    key.keyByte[i] = 0xFF;\n  }\n\n  Serial.println(F(\"Este es el codigo leido NUID.\"));\n  Serial.print(F(\"Usa la siguiente llave:\"));\n  printHex(key.keyByte, MFRC522::MF_KEY_SIZE);\n  Serial.println(\"\");//solo para dar un enter\n}\n\nvoid loop() {\n\n  // Resetea en cada vuelta del ciclo, para leer una una tarjeta.\n  if ( ! rfid.PICC_IsNewCardPresent())\n    return;\n\n  // Verifica si el NUID ha sido le\u00eddo\n  if ( ! rfid.PICC_ReadCardSerial())\n    return;\n\n  if (rfid.uid.uidByte[0] != nuidPICC[0] || \n    rfid.uid.uidByte[1] != nuidPICC[1] || \n    rfid.uid.uidByte[2] != nuidPICC[2] || \n    rfid.uid.uidByte[3] != nuidPICC[3] ) {\n    Serial.println(F(\"Tarjeta nueva detectada.\"));\n\n    // Almacena el NUID dentro del array\n    for (byte i = 0; i &lt; 4; i++) {\n      nuidPICC[i] = rfid.uid.uidByte[i];\n    }\n\n    Serial.println(F(\"El tag del NUID:\"));\n    Serial.print(F(\"En hex: \"));\n    printHex(rfid.uid.uidByte, rfid.uid.size);\n    Serial.println();\n    Serial.print(F(\"En dec: \"));\n    printDec(rfid.uid.uidByte, rfid.uid.size);\n    Serial.println();\n  }\n  else Serial.println(F(\"Tarjeta ya leida.\"));\n\n  // Con estas 2 funciones se evita que siga leyendo como loco el sensor,\n  // si lo quitas comenzara a leer sin parar\n  // tu decides si es necesario quitarlo\n  // Halt PICC\n  rfid.PICC_HaltA();\n  // Detiene la encriptacion en PCD\n  rfid.PCD_StopCrypto1();\n}\n\n\n/**\n * Ayuda a imprimir los bytes del array en forma hexadecimal. \n */\nvoid printHex(byte *buffer, byte bufferSize) {\n  for (byte i = 0; i &lt; bufferSize; i++) {\n    Serial.print(buffer[i] &lt; 0x10 ? \" 0\" : \" \");\n    Serial.print(buffer[i], HEX);\n  }\n}\n\n/**\n * Ayuda a volcar los bytes del array en forma decimal. \n */\nvoid printDec(byte *buffer, byte bufferSize) {\n  for (byte i = 0; i &lt; bufferSize; i++) {\n    Serial.print(buffer[i] &lt; 0x10 ? \" 0\" : \" \");\n    Serial.print(buffer[i], DEC);\n  }\n}\n</code></pre>"},{"location":"Capitulo%202/08_sensores/#acceso-autorizado","title":"Acceso autorizado","text":"<p>Este codigo lee la tarjeta e indica si el codigo leido es igual al almacenado. En caso que sea correcto, manda el mensaje <code>ACCESO CORRECTO</code>, de lo contrario <code>Acceso no autorizado</code>.</p> <pre><code>#include &lt;SPI.h&gt;\n#include &lt;MFRC522.h&gt;\n\n#define RST_PIN   0\n#define SS_PIN    5\n\nMFRC522 rfid(SS_PIN, RST_PIN); // crea el objeto para ocupar el lector\n\n// Es la NUID de una tarjeta, aqu\u00ed reempl\u00e1zalo por tu NUID\nbyte nuidPICC[4] = {138, 92, 3, 14};;\n\nvoid setup() {\n  Serial.begin(115200);\n  SPI.begin(); // Inicializa el bus para la comunicaci\u00f3n SPI\n  rfid.PCD_Init(); // Inicializa el modulo MFRC522\n\n}\n\nvoid loop() {\n\n  // Resetea en cada vuelta del ciclo, para leer una una tarjeta.\n  if ( ! rfid.PICC_IsNewCardPresent())\n    return;\n\n  // Verifica si el NUID ha sido le\u00eddo\n  if ( ! rfid.PICC_ReadCardSerial())\n    return;\n\n  //aqu\u00ed verifico que el c\u00f3digo almacenado en la memoria sera igual al de la tarjeta que se esta verificando\n  if (rfid.uid.uidByte[0] != nuidPICC[0] || rfid.uid.uidByte[1] != nuidPICC[1] || rfid.uid.uidByte[2] != nuidPICC[2] || rfid.uid.uidByte[3] != nuidPICC[3] ) {\n    Serial.println(F(\"ACCESO CORRECTO\"));\n\n  }\n  else Serial.println(F(\"Acceso no autorizado\"));\n\n  // Con estas 2 funciones se evita que siga leyendo como loco el sensor,\n  // si lo quitas comenzara a leer sin parar\n  // tu decides si es necesario quitarlo\n  // Halt PICC\n  rfid.PICC_HaltA();\n  // Detiene la encriptaci\u00f3n en PCD\n  rfid.PCD_StopCrypto1();\n}\n</code></pre>"},{"location":"Capitulo%202/09_screen/","title":"Pantallas","text":""},{"location":"Capitulo%202/09_screen/#pantalla-lcd-con-comunicacion-i2c","title":"Pantalla LCD con comunicaci\u00f3n I<sup>2</sup>C","text":"<p>La pantalla LCD es una pantalla de cristal liquido, su controlador mas com\u00fan es el HD44780, su comunicaci\u00f3n puede ser de 4 bits u 8 bits. Dado que si nos comunicamos con 8 bits, implica usar 8 pines del microcontrolador, o en su defecto si usamos la comunicaci\u00f3n de 4 bits, se usar\u00edan 4 pines, y en ocasiones dependiendo del microcontrolador, no nos podemos dar el lujo de usar tantos, surgi\u00f3 un modulo de comunicaci\u00f3n I<sup>2</sup>C, que implica solo usar 2 pines para el control total de toda la pantalla.</p> <p></p> <p>Los tama\u00f1os mas comunes de pantalla son </p> <ul> <li>16x2: 16 caracteres de forma horizontal y 2 renglones</li> <li>20x4: 20 caracteres de forma horizontal y 4 renglones</li> </ul> <p></p> <p>El control es exactamente igual, obviamente se debe especificar en que sitio se colocara el car\u00e1cter.</p> <p>Cada car\u00e1cter esta formado de 5x7 pixels, es decir, podemos dar la forma o figura que quisi\u00e9ramos por cada car\u00e1cter y hacer combinaciones infinitas (inclusive hacer juegos)</p> <p></p> <p>La comunicaci\u00f3n I<sup>2</sup>C nos reduce el uso de pines, pero esto incrementa el uso de mas hardware o librer\u00edas para implementar el protocolo.</p> <p></p> <p>El controlador es el PCF8574 el encargado de recibir la informacion y comunicarla al microcontrolador de la LCD, realizando las acciones que enviamos por el protocolo.</p> <p></p> <p>En la comunicaci\u00f3n I<sup>2</sup>C es un protocolo tipo Maestro-Esclavo, y cada esclavo tiene un ID \u00fanico (direcci\u00f3n), para saber a que dispositivo le estamos solicitando la informaci\u00f3n y de quien estamos recibiendo.</p> <p>Al igual en este modulo incorpora un trimpot para ajustar el contraste de la pantalla, el jumper para el brillo de la pantalla y el selector de direcci\u00f3n (es la modificaci\u00f3n de una resistencia)</p> <p></p>"},{"location":"Capitulo%202/09_screen/#referencias","title":"Referencias","text":"<p>https://naylampmechatronics.com/oled/638-display-oled-i2c-130-12864-sh1106.html</p>"},{"location":"Capitulo%202/09_screen/#pines-de-la-lcd-con-i2c","title":"Pines de la LCD con I<sup>2</sup>C","text":"<p>Warning</p> <p>Los pines a los que se conectan los pines de <code>SDA</code> y <code>SCL</code> de la pantalla Iran a:</p> LCD ESP32 SDA GPIO21 SCL GPIO22 VCC 5V GND GND <p>]</p> <p>Warning</p> <p>Descargar la librer\u00eda para poder comunicar el ESP32 con el m\u00f3dulo I<sup>2</sup>C. Agregarla a Arduino IDE. Dar click aqu\u00ed</p> <p>Note</p> <p>Si al arrancar la pantalla no se ve nada, recuerda mover el tripot para el contraste.</p>"},{"location":"Capitulo%202/09_screen/#algoritmos-de-encendido-de-pantalla","title":"Algoritmos de encendido de pantalla","text":"<p>Estos son los pasos que siempre Iran al inicio para arrancar la pantalla.</p> <ol> <li>Funci\u00f3n <code>begin()</code>: Solo se llama al inicio para arrancar la pantalla</li> <li>Funci\u00f3n <code>backlight()</code>: Enciende la luz de fondo (depende si quieres prenderla)</li> <li>Funci\u00f3n <code>clear()</code>: Limpia la pantalla de cualquier ruido o car\u00e1cter raro que salga en pantalla</li> <li>Funci\u00f3n <code>setCursor(column, row)</code> </li> </ol> <p>Ya posicionados, podemos comenzar a escribir el mensaje en pantalla.</p> <p>https://lastminuteengineers.com/esp32-i2c-lcd-tutorial/</p>"},{"location":"Capitulo%202/09_screen/#visualizacion-de-mensaje","title":"Visualizaci\u00f3n de mensaje","text":"<p>Se mandara un mensaje a la pantalla, l\u00ednea por l\u00ednea.</p> <p>Diagrama Pict\u00f3rico</p> <p></p> <p></p> <pre><code>#include &lt;Wire.h&gt;\n#include &lt;LiquidCrystal_I2C.h&gt;\n\n// Set the LCD address to 0x27 for a 16 chars and 2 line display\nLiquidCrystal_I2C lcd(0x27, 16, 2);\n\nvoid setup()\n{\n  // inicializamos la pantalla para comunicaci\u00f3n \n  lcd.begin();\n  // Enciende la luz de fondo pantalla\n  lcd.backlight();\n  //Por default comenzar\u00e1 a escribir en la posici\u00f3n x=0,y=0\n  //se manda el siguiente texto a la pantalla\n  lcd.print(\"Mecatronica 85\"); //no se ponen acentos \n  //Nos movemos al segundo rengl\u00f3n, en la primera posici\u00f3n\n  lcd.setCursor(0, 1);\n  //se manda el siguiente texto a la pantalla\n  lcd.print(\"Rules\");\n}\n\nvoid loop()\n{\n  // Aqu\u00ed no colocamos nada\n}\n</code></pre>"},{"location":"Capitulo%202/09_screen/#voltimetro","title":"Volt\u00edmetro","text":"<p>Realizaremos un volt\u00edmetro sencillo y b\u00e1sico, donde vamos a leer el voltaje de un divisor de tension.</p> <p>Para ello debemos aplicar una formula donde vamos a convertir el valor que se recibe del ADC a un valor equivalente de voltaje, como tenemos un potenci\u00f3metro lineal, la relaci\u00f3n es directa, quedando la formula</p> \\[voltaje = ADC_{bit} \\frac{3.3V}{4095_{bit}}\\] <p>Con esta formula estamos convirtiendo lo que recibimos en la entrada del ADC a lo correspondiente de voltaje.</p> <p>Como el valor m\u00e1ximo de voltaje es 3.3V, esto se divide entre la resoluci\u00f3n del ADC y lo multiplicamos por el valor le\u00eddo.</p> <p>Diagrama pict\u00f3rico</p> <p></p> <p> <p></p> <p></p> <p>C\u00f3digo b\u00e1sico</p> <pre><code>#include &lt;Wire.h&gt;\n#include &lt;LiquidCrystal_I2C.h&gt;\n\n// Set the LCD address to 0x27 for a 16 chars and 2 line display\nLiquidCrystal_I2C lcd(0x27, 16, 2);\n#define PIN_ADC 34\n\n\nvoid setup(){\n  // inicializamos la pantalla para comunicaci\u00f3n \n  lcd.begin();\n  // Enciende la luz de fondo pantalla\n  lcd.backlight();\n  //Por default comenzar\u00e1 a escribir en la posici\u00f3n x=0,y=0\n  //se manda el siguiente texto a la pantalla\n  lcd.print(\"Mecatronica 85\");\n  //Nos movemos al segundo rengl\u00f3n, en la primera posici\u00f3n\n  lcd.setCursor(0, 1);\n  //se manda el siguiente texto a la pantalla\n  lcd.print(\"Voltimetro\");\n  delay(1000); //esperamos un segundo para el mensaje de bienvenida\n  lcd.clear(); //limpiamos la pantalla\n  lcd.setCursor(0,0); //regresamos a la posici\u00f3n inicial\n  lcd.print(\"Voltimetro 85\");\n  lcd.setCursor(15,1);  //nos movemos a la columna 15 y la ultima posici\u00f3n\n  lcd.print(\"V\"); //colocamos la unidad del voltaje (V)\n}\n\nvoid loop(){\n  int valorADC = analogRead(PIN_ADC);\n  delay(10); //esperamos un momento de estabilizaci\u00f3n del dato\n  float voltaje = (valorADC * 3.3) / 4095.0; //convertimos el valor a voltaje\n  lcd.setCursor(11,1); //nos colocamos en la parte para que el numero salga al final al lado de la \"V\"\n  lcd.print(voltaje);\n  delay(50);\n}\n</code></pre> <p>C\u00f3digo m\u00e1s estable</p> <p>Este c\u00f3digo es m\u00e1s eficiente para tener una valor m\u00e1s estable. Aplicamos un promedio de la muestra. Con esto hacemos que el valor que se muestra se m\u00e1s conciso.</p> <pre><code>#include &lt;Wire.h&gt;\n#include &lt;LiquidCrystal_I2C.h&gt;\n\n// Set the LCD address to 0x27 for a 16 chars and 2 line display\nLiquidCrystal_I2C lcd(0x27, 16, 2);\n#define PIN_ADC 34\n\n\nvoid setup() {\n  // inicializamos la pantalla para comunicaci\u00f3n\n  lcd.begin();\n  // Enciende la luz de fondo pantalla\n  lcd.backlight();\n  //Por default comenzar\u00e1 a escribir en la posici\u00f3n x=0,y=0\n  //se manda el siguiente texto a la pantalla\n  lcd.print(\"Mecatronica 85\");\n  //Nos movemos al segundo rengl\u00f3n, en la primera posici\u00f3n\n  lcd.setCursor(0, 1);\n  //se manda el siguiente texto a la pantalla\n  lcd.print(\"Voltimetro\");\n  delay(1000); //esperamos un segundo para el mensaje de bienvenida\n  lcd.clear(); //limpiamos la pantalla\n  lcd.setCursor(0, 0); //regresamos a la posici\u00f3n inicial\n  lcd.print(\"Voltimetro 85\");\n  lcd.setCursor(15, 1); //nos movemos a la columna 15 y la ultima posici\u00f3n\n  lcd.print(\"V\"); //colocamos la unidad del voltaje (V)\n}\n\n#define MUESTRAS 60.0 // defino una cantidad de muestras que se tomaran para el promedio\n\nvoid loop() {\n  int valorADC = 0;     //aqu\u00ed guardaremos el valor del ADC\n  int suma = 0;         //acumulara el valor de las muestras del ADC\n  for (byte x = 0; x &lt; MUESTRAS; x++) {\n    valorADC = analogRead(PIN_ADC);\n    suma += valorADC;\n    delay(5); //esperamos un momento de estabilizaci\u00f3n del dato\n  }\n  float promedio = suma / MUESTRAS;\n  float voltaje = (valorADC * 3.3) / 4095.0; //convertimos el valor a voltaje\n  lcd.setCursor(11, 1); //nos colocamos en la parte para que el numero salga al final al lado de la \"V\"\n  lcd.print(voltaje);\n\n}\n</code></pre>"},{"location":"Capitulo%202/09_screen/#oled","title":"OLED","text":"<p>Las pantalla OLED se han popularizado mucho \u00faltimamente, y gracias a Adafruit se ha economizado mucho.</p> <p>Nos da una amplia gama de aplicaci\u00f3n en diversas situaciones, como realizar estaciones meteorol\u00f3gicas, un contador para nuestros suscriptores de YT, juegos, etc.</p> <p></p> <p></p> <p>Contamos con 2 drivers, los mas comunes son:</p> <ul> <li>SSD1306</li> <li>SH110X</li> </ul> <p>Con dos protocolos, estos son</p> <ul> <li>I<sup>2</sup>C</li> <li>SPI</li> </ul> <p>Note</p> <p>Aqu\u00ed debes probar en caso de no conocer cual es el driver de tuu pantalla OLED, en mi caso tengo con driver: SH110X con I<sup>2</sup>C</p> <p>Warning</p> <p>Los pines a los que se conectan los pines de <code>SDA</code> y <code>SCL</code> de la pantalla Iran a:</p> OLED ESP32 SDA GPIO21 SCL GPIO22 VDD 3V3 GND GND <p></p> <p>Warning</p> <p>Las librer\u00edas que se necesitan son varias, si estas con el gestor e instalar en la carpeta de <code>librer\u00edas</code> del IDE de Arduino. Descargar aqu\u00ed y las agregamos de manera manual.</p>  Instalando desde el Gestor de librer\u00edas <p>Buscamos por \"oled\" e instalamos las siguientes e instalamos las librer\u00edas adiciones</p> <p></p> <p></p> <p></p>"},{"location":"Capitulo%202/09_screen/#convertidores-de-imagenes-para-la-pantalla","title":"Convertidores de im\u00e1genes para la pantalla","text":"<ul> <li>image2cpp [web]</li> </ul> <ul> <li>LCD Image Converter [Desktop]</li> </ul> <p>Descargar</p> <p>Para conocer mas, ingresa a la documentaci\u00f3n oficial de Adafruit</p>"},{"location":"Capitulo%202/09_screen/#assets","title":"Assets","text":"<p>La imagen demo que sale al inicio</p> <p></p> <p></p> <p></p> <p></p>"},{"location":"Capitulo%202/09_screen/#codigo-demo-de-la-oled","title":"C\u00f3digo DEMO de la OLED","text":"<p>Se realizara demo simple de uso de la pantalla OLED</p> <p>Diagrama Pict\u00f3rico</p> <p></p> <p></p> <pre><code>// Para la pantalla SH110X\n#include &lt;SPI.h&gt;\n#include &lt;Wire.h&gt;\n#include &lt;Adafruit_GFX.h&gt;\n#include &lt;Adafruit_SH110X.h&gt;\n\n#define i2c_Address 0x3c //initialize with the I2C addr 0x3C Typically eBay OLED's\n//#define i2c_Address 0x3d //initialize with the I2C addr 0x3D Typically Adafruit OLED's\n\n#define SCREEN_WIDTH 128 // OLED display width, in pixels\n#define SCREEN_HEIGHT 64 // OLED display height, in pixels\n#define OLED_RESET -1   //   QT-PY / XIAO\nAdafruit_SH1106G display = Adafruit_SH1106G(SCREEN_WIDTH, SCREEN_HEIGHT, &amp;Wire, OLED_RESET);\n\n\n#define NUMFLAKES 10\n#define XPOS 0\n#define YPOS 1\n#define DELTAY 2\n\n\n#define LOGO16_GLCD_HEIGHT 16\n#define LOGO16_GLCD_WIDTH  16\nstatic const unsigned char PROGMEM logo16_glcd_bmp[] = {\n  0x06, 0x60,\n  0x06, 0x60,\n  0x3f, 0xfc,\n  0x20, 0x04,\n  0x20, 0x04,\n  0xee, 0x77,\n  0xea, 0x47,\n  0x2a, 0x44,\n  0x2e, 0x74,\n  0xea, 0x17,\n  0xea, 0x17,\n  0x2e, 0x74,\n  0x20, 0x04,\n  0x3f, 0xfc,\n  0x06, 0x60,\n  0x06, 0x60\n};\n\n\nvoid setup()   {\n\n  Serial.begin(115200);\n\n  delay(250); // wait for the OLED to power up\n  display.begin(i2c_Address, true); // Address 0x3C default\n  //display.setContrast (0); // dim display\n\n  display.display();\n  delay(2000);\n\n  // limpia la pantalla\n  display.clearDisplay();\n\n  // dibuja un pixel\n  display.drawPixel(10, 10, SH110X_WHITE);\n  // Show the display buffer on the hardware.\n  // NOTE: You _must_ call display after making any drawing commands\n  // to make them visible on the display hardware!\n  display.display();\n  delay(2000);\n  display.clearDisplay();\n\n  // dibuja muchas lineas\n  testdrawline();\n  display.display();\n  delay(2000);\n  display.clearDisplay();\n\n  // dibuja rectangulos\n  testdrawrect();\n  display.display();\n  delay(2000);\n  display.clearDisplay();\n\n  // dibuja multiples rectangulos\n  testfillrect();\n  display.display();\n  delay(2000);\n  display.clearDisplay();\n\n  // dibuja multiples circulos\n  testdrawcircle();\n  display.display();\n  delay(2000);\n  display.clearDisplay();\n\n  // dibuja un circulo de 10px de radio SH110X_WHITE\n  display.fillCircle(display.width() / 2, display.height() / 2, 10, SH110X_WHITE);\n  display.display();\n  delay(2000);\n  display.clearDisplay();\n\n  testdrawroundrect();\n  delay(2000);\n  display.clearDisplay();\n\n  testfillroundrect();\n  delay(2000);\n  display.clearDisplay();\n\n  testdrawtriangle();\n  delay(2000);\n  display.clearDisplay();\n\n  testfilltriangle();\n  delay(2000);\n  display.clearDisplay();\n\n  // dibuja las primeras 12 letras en una fuente\n  testdrawchar();\n  display.display();\n  delay(2000);\n  display.clearDisplay();\n\n  // Muestra texto\n  display.setTextSize(1);\n  display.setTextColor(SH110X_WHITE);\n  display.setCursor(0, 0);\n  display.println(\"Failure is always an option\");\n  display.setTextColor(SH110X_BLACK, SH110X_WHITE); // 'inverted' text\n  display.println(3.141592);\n  display.setTextSize(2);\n  display.setTextColor(SH110X_WHITE);\n  display.print(\"0x\"); display.println(0xDEADBEEF, HEX);\n  display.display();\n  delay(2000);\n  display.clearDisplay();\n\n  // muestra la imagen (logo)\n  display.drawBitmap(30, 16,  logo16_glcd_bmp, 16, 16, 1);\n  display.display();\n  delay(1);\n\n  // invierte el color del display\n  display.invertDisplay(true);\n  delay(1000);\n  display.invertDisplay(false);\n  delay(1000);\n  display.clearDisplay();\n\n  // dibuja el icono bitmap en un movimiento animado\n  testdrawbitmap(logo16_glcd_bmp, LOGO16_GLCD_HEIGHT, LOGO16_GLCD_WIDTH);\n}\n\n\nvoid loop() {\n\n}\n\n\nvoid testdrawbitmap(const uint8_t *bitmap, uint8_t w, uint8_t h) {\n  uint8_t icons[NUMFLAKES][3];\n\n  // initialize\n  for (uint8_t f = 0; f &lt; NUMFLAKES; f++) {\n    icons[f][XPOS] = random(display.width());\n    icons[f][YPOS] = 0;\n    icons[f][DELTAY] = random(5) + 1;\n\n    Serial.print(\"x: \");\n    Serial.print(icons[f][XPOS], DEC);\n    Serial.print(\" y: \");\n    Serial.print(icons[f][YPOS], DEC);\n    Serial.print(\" dy: \");\n    Serial.println(icons[f][DELTAY], DEC);\n  }\n\n  while (1) {\n    // draw each icon\n    for (uint8_t f = 0; f &lt; NUMFLAKES; f++) {\n      display.drawBitmap(icons[f][XPOS], icons[f][YPOS], bitmap, w, h, SH110X_WHITE);\n    }\n    display.display();\n    delay(200);\n\n    // then erase it + move it\n    for (uint8_t f = 0; f &lt; NUMFLAKES; f++) {\n      display.drawBitmap(icons[f][XPOS], icons[f][YPOS], bitmap, w, h, SH110X_BLACK);\n      // move it\n      icons[f][YPOS] += icons[f][DELTAY];\n      // if its gone, reinit\n      if (icons[f][YPOS] &gt; display.height()) {\n        icons[f][XPOS] = random(display.width());\n        icons[f][YPOS] = 0;\n        icons[f][DELTAY] = random(5) + 1;\n      }\n    }\n  }\n}\n\n\nvoid testdrawchar(void) {\n  display.setTextSize(1);\n  display.setTextColor(SH110X_WHITE);\n  display.setCursor(0, 0);\n\n  for (uint8_t i = 0; i &lt; 168; i++) {\n    if (i == '\\n') continue;\n    display.write(i);\n    if ((i &gt; 0) &amp;&amp; (i % 21 == 0))\n      display.println();\n  }\n  display.display();\n  delay(1);\n}\n\nvoid testdrawcircle(void) {\n  for (int16_t i = 0; i &lt; display.height(); i += 2) {\n    display.drawCircle(display.width() / 2, display.height() / 2, i, SH110X_WHITE);\n    display.display();\n    delay(1);\n  }\n}\n\nvoid testfillrect(void) {\n  uint8_t color = 1;\n  for (int16_t i = 0; i &lt; display.height() / 2; i += 3) {\n    // alternate colors\n    display.fillRect(i, i, display.width() - i * 2, display.height() - i * 2, color % 2);\n    display.display();\n    delay(1);\n    color++;\n  }\n}\n\nvoid testdrawtriangle(void) {\n  for (int16_t i = 0; i &lt; min(display.width(), display.height()) / 2; i += 5) {\n    display.drawTriangle(display.width() / 2, display.height() / 2 - i,\n                         display.width() / 2 - i, display.height() / 2 + i,\n                         display.width() / 2 + i, display.height() / 2 + i, SH110X_WHITE);\n    display.display();\n    delay(1);\n  }\n}\n\nvoid testfilltriangle(void) {\n  uint8_t color = SH110X_WHITE;\n  for (int16_t i = min(display.width(), display.height()) / 2; i &gt; 0; i -= 5) {\n    display.fillTriangle(display.width() / 2, display.height() / 2 - i,\n                         display.width() / 2 - i, display.height() / 2 + i,\n                         display.width() / 2 + i, display.height() / 2 + i, SH110X_WHITE);\n    if (color == SH110X_WHITE) color = SH110X_BLACK;\n    else color = SH110X_WHITE;\n    display.display();\n    delay(1);\n  }\n}\n\nvoid testdrawroundrect(void) {\n  for (int16_t i = 0; i &lt; display.height() / 2 - 2; i += 2) {\n    display.drawRoundRect(i, i, display.width() - 2 * i, display.height() - 2 * i, display.height() / 4, SH110X_WHITE);\n    display.display();\n    delay(1);\n  }\n}\n\nvoid testfillroundrect(void) {\n  uint8_t color = SH110X_WHITE;\n  for (int16_t i = 0; i &lt; display.height() / 2 - 2; i += 2) {\n    display.fillRoundRect(i, i, display.width() - 2 * i, display.height() - 2 * i, display.height() / 4, color);\n    if (color == SH110X_WHITE) color = SH110X_BLACK;\n    else color = SH110X_WHITE;\n    display.display();\n    delay(1);\n  }\n}\n\nvoid testdrawrect(void) {\n  for (int16_t i = 0; i &lt; display.height() / 2; i += 2) {\n    display.drawRect(i, i, display.width() - 2 * i, display.height() - 2 * i, SH110X_WHITE);\n    display.display();\n    delay(1);\n  }\n}\n\nvoid testdrawline() {\n  for (int16_t i = 0; i &lt; display.width(); i += 4) {\n    display.drawLine(0, 0, i, display.height() - 1, SH110X_WHITE);\n    display.display();\n    delay(1);\n  }\n  for (int16_t i = 0; i &lt; display.height(); i += 4) {\n    display.drawLine(0, 0, display.width() - 1, i, SH110X_WHITE);\n    display.display();\n    delay(1);\n  }\n  delay(250);\n\n  display.clearDisplay();\n  for (int16_t i = 0; i &lt; display.width(); i += 4) {\n    display.drawLine(0, display.height() - 1, i, 0, SH110X_WHITE);\n    display.display();\n    delay(1);\n  }\n  for (int16_t i = display.height() - 1; i &gt;= 0; i -= 4) {\n    display.drawLine(0, display.height() - 1, display.width() - 1, i, SH110X_WHITE);\n    display.display();\n    delay(1);\n  }\n  delay(250);\n\n  display.clearDisplay();\n  for (int16_t i = display.width() - 1; i &gt;= 0; i -= 4) {\n    display.drawLine(display.width() - 1, display.height() - 1, i, 0, SH110X_WHITE);\n    display.display();\n    delay(1);\n  }\n  for (int16_t i = display.height() - 1; i &gt;= 0; i -= 4) {\n    display.drawLine(display.width() - 1, display.height() - 1, 0, i, SH110X_WHITE);\n    display.display();\n    delay(1);\n  }\n  delay(250);\n\n  display.clearDisplay();\n  for (int16_t i = 0; i &lt; display.height(); i += 4) {\n    display.drawLine(display.width() - 1, 0, 0, i, SH110X_WHITE);\n    display.display();\n    delay(1);\n  }\n  for (int16_t i = 0; i &lt; display.width(); i += 4) {\n    display.drawLine(display.width() - 1, 0, i, display.height() - 1, SH110X_WHITE);\n    display.display();\n    delay(1);\n  }\n  delay(250);\n}\n</code></pre>"},{"location":"Capitulo%202/09_screen/#voltimetro_1","title":"Volt\u00edmetro","text":"<p>Realizaremos un volt\u00edmetro sencillo y b\u00e1sico, donde vamos a leer el voltaje de un divisor de tension.</p> <p>Para ello debemos aplicar una formula donde vamos a convertir el valor que se recibe del ADC a un valor equivalente de voltaje, como tenemos un potenci\u00f3metro lineal, la relaci\u00f3n es directa, quedando la formula</p> \\[voltaje = ADC_{bit} \\frac{3.3V}{4095_{bit}}\\] <p>Con esta formula estamos convirtiendo lo que recibimos en la entrada del ADC a lo correspondiente de voltaje.</p> <p>Como el valor m\u00e1ximo de voltaje es 3.3V, esto se divide entre la resoluci\u00f3n del ADC y lo multiplicamos por el valor le\u00eddo.</p> <p>Haciendo uso de una pantalla OLED para mostrar le valor en la pantalla.</p> <p>Diagrama pict\u00f3rico</p> <p></p> <p></p> <p>C\u00f3digo</p> <pre><code>#include &lt;SPI.h&gt;\n#include &lt;Wire.h&gt;\n#include &lt;Adafruit_GFX.h&gt;\n#include &lt;Adafruit_SH110X.h&gt;\n\n#define i2c_Address 0x3c //inicializa la comunicaci\u00f3n con el I2C con la direcci\u00f3n 0x3C.\n//#define i2c_Address 0x3d // inicializa la comunicaci\u00f3n con el I2C con la direcci\u00f3n 0x3D.\n\n#define SCREEN_WIDTH 128 // OLED ancho del display, en pixels\n#define SCREEN_HEIGHT 64 // OLED alto del display, en pixels\n#define OLED_RESET -1   //   QT-PY / XIAO\nAdafruit_SH1106G display = Adafruit_SH1106G(SCREEN_WIDTH, SCREEN_HEIGHT, &amp;Wire, OLED_RESET);\n\n#define PIN_ADC 34\n\nvoid setup()   {\n  ////NO MODIFICAR\n  Serial.begin(115200);\n  delay(250); // wait for the OLED to power up\n  display.begin(i2c_Address, true); // Address 0x3C default\n  //display.setContrast (0); // dim display\n  display.display();\n  delay(2000);\n  display.clearDisplay();\n  ////NO MODIFICAR\n\n  // text display tests\n  display.setTextSize(2);\n  display.setTextColor(SH110X_WHITE);\n  display.setCursor(0, 0);\n  display.println(\"Voltimetro\");\n  display.display();\n  delay(2000);\n  display.clearDisplay();\n\n}\n\n#define MUESTRAS 60.0 // defino una cantidad de muestras que se tomaran para el promedio\n\nvoid loop() {\n\n  int valorADC = 0;     //aqu\u00ed guardaremos el valor del ADC\n  int suma = 0;         //acumulara el valor de las muestras del ADC\n  for (byte x = 0; x &lt; MUESTRAS; x++) {\n    valorADC = analogRead(PIN_ADC);\n    suma += valorADC;\n    delay(5); //esperamos un momento de estabilizaci\u00f3n del dato\n  }\n  float promedio = suma / MUESTRAS;\n  float voltaje = (valorADC * 3.3) / 4095.0; //convertimos el valor a voltaje\n\n  display.setTextSize(2);\n  display.setTextColor(SH110X_WHITE);\n  display.clearDisplay();\n  display.setCursor(0, 0);\n  display.print(\"Voltimetro\");\n  display.setCursor(SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2);\n  display.print(voltaje);\n  display.println(\"V\");\n  display.display();\n}\n</code></pre>"}]}