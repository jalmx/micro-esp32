{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Programa Tarjetas Electr\u00f3nicas de control para sistemas Mecatr\u00f3nicos 2023","text":"<p>Documentaci\u00f3n para el aprendizaje del Lenguaje C con un enfoque b\u00e1sico para quien no ha programado pero tiene nociones de algoritmos, y ahora tendr\u00e1 que aplicar ese conocimiento a un lenguaje en una tarjeta de control, en este caso para ESP32 con Arduino.</p>"},{"location":"#arduino-con-esp32","title":"Arduino con ESP32","text":""},{"location":"#introduccion","title":"Introducci\u00f3n","text":""},{"location":"#estructura-de-codigo-base-arduino","title":"Estructura de c\u00f3digo base Arduino","text":""},{"location":"#interfaz-de-arduino-ide","title":"Interfaz de Arduino IDE","text":""},{"location":"#entradas-y-salidas-digitales-io","title":"Entradas y Salidas Digitales (I/O)","text":""},{"location":"#ejercicios-con-io-digitales","title":"Ejercicios con IO Digitales","text":""},{"location":"#entradas-y-salidas-analogicas-adc-y-pwm","title":"Entradas y Salidas anal\u00f3gicas (ADC y PWM)","text":""},{"location":"#ejercicios-con-io-analogicas","title":"Ejercicios con IO Anal\u00f3gicas","text":""},{"location":"#sensores-introduccion","title":"Sensores - Introducci\u00f3n","text":""},{"location":"#sensores-aplicacion","title":"Sensores - Aplicaci\u00f3n","text":""},{"location":"#pantallas","title":"Pantallas","text":""},{"location":"#simaladores","title":"Simaladores","text":""},{"location":"#referencias","title":"Referencias","text":""},{"location":"00_introduccion/","title":"Introducci\u00f3n a Arduino con ESP32","text":"<p>El ecosistema Arduino esta compuesto por una tarjeta con un microcontrolador y los perif\u00e9ricos necesarios m\u00ednimos para operar, el cual contiene un firmware para comunicarse y carga los programas realizados en C. Esta placa trabaja en conjunto con un IDE (Entorno de Desarrollo Integrado) el cual facilita la carga y depuraci\u00f3n de los programas realizados. </p> <p>El lenguaje que utiliza el entorno Arduino es C/C++, el cual nos ayuda a desarrollar nuestro programa y con ello desarrollar un prototipo r\u00e1pido.</p> <p>Todo este entorno es Open Source y Open Hardware, gracias a ello existe mucha comunidad desarrollando <code>mods</code>, <code>shields</code>, variantes de tarjetas, con el firmware que se acopla al entorno de Arduino.</p> <p>En este caso usaremos la tarjeta <code>ESP32 Dev Kit</code>, la cual tiene un microcontrolador <code>ESP32</code> de la empresa <code>espressif</code>.</p>"},{"location":"00_introduccion/#descripcion-general","title":"Descripci\u00f3n general","text":"<p>En la siguiente imagen y la tabla se describe los componentes clases, interfaces y controles de la tarjeta ESP32-DevKitC V4.</p> <p></p> Componente clave Descripci\u00f3n ESP32-WROOM-32 Un modulo con un ESP32 en el n\u00facleo. Para mas informaci\u00f3n ver el datasheet EN Bot\u00f3n de Reset Boot Download button. Holding down Boot and then pressing EN initiates Firmware Download mode for downloading firmware through the serial port. Puente USB a UART Single USB-UART bridge chip provides transfer rates of up to 3 Mbps. Puerto micro USB USB interface. Power supply for the board as well as the communication interface between a computer and the ESP32-WROOM-32 module. LED de alimentaci\u00f3n de 5V Turns on when the USB or an external 5V power supply is connected to the board. For details see the schematics in Related Documents. I/O Most of the pins on the ESP module are broken out to the pin headers on the board. You can program ESP32 to enable multiple functions such as PWM, ADC, DAC, I2C, I2S, SPI, etc."},{"location":"00_introduccion/#opciones-de-fuente-de-alimentacion","title":"Opciones de fuente de alimentaci\u00f3n","text":"<p>Hay 3 formas mutuamente exclusivas para darle alimentaci\u00f3n a la tarjeta:</p> <ul> <li>Puerto micro USB, por default es por este medio</li> <li>5V / GND header pins</li> <li>3V3 / GND header pins</li> </ul>"},{"location":"00_introduccion/#conector-j2-izquierdo","title":"Conector J2 (Izquierdo)","text":"No Nombre Tipo<sup>1</sup> Descripci\u00f3n 1 3V3 P Fuente de alimentaci\u00f3n de 3.3V 2 EN I CHIP_PU, Reset 3 VP I GPIO36, ADC1_CH0, S_VP 4 VN I GPIO39, ADC1_CH3, S_VN 5 IO34 I GPIO34, ADC1_CH6, VDET_1 6 IO35 I GPIO35, ADC1_CH7, VDET_2 7 IO32 I/O GPIO32, ADC1_CH4, TOUCH_CH9, XTAL_32K_P 8 IO33 I/O GPIO33, ADC1_CH5, TOUCH_CH8, XTAL_32K_N 9 IO25 I/O GPIO25, ADC1_CH8, DAC_1 10 IO26 I/O GPIO26, ADC2_CH9, DAC_2 11 IO27 I/O GPIO27, ADC2_CH7, TOUCH_CH7 12 IO14 I/O GPIO14, ADC2_CH6, TOUCH_CH6, MTMS 13 IO12 I/O GPIO12, ADC2_CH5, TOUCH_CH5, MTDI 14 GND G Ground (Tierra) 15 IO13 I/O GPIO13, ADC2_CH4, TOUCH_CH4, MTCK 16 D2 I/O GPIO9, D2<sup>2</sup> 17 D3 I/O GPIO10, D3<sup>2</sup> 18 CMD I/O GPIO11, CMD<sup>2</sup> 19 5V P Fuente de alimentaci\u00f3n de 5V"},{"location":"00_introduccion/#conector-j3-derecho","title":"Conector J3 (Derecho)","text":"No Nombre Tipo<sup>1</sup> Descripci\u00f3n 1 GND G Ground (Tierra) 2 IO23 I/O GPIO23 3 IO22 I/O GPIO22 4 TX I/O GPIO1, U0TXD 5 RX I/O GPIO3, U0RXD 6 IO21 I/O GPIO21 7 GND G Ground (Tierra) 8 IO19 I/O GPIO19 9 IO18 I/O GPIO18 10 IO5 I/O GPIO5 11 IO17 I/O GPIO17<sup>3</sup> 12 IO16 I/O GPIO16<sup>3</sup> 13 IO4 I/O GPIO4, ADC2_CH0, TOUCH_CH0 14 IO0 G GPIO0, ADC2_CH1, TOUCH_CH1, Boot 15 IO3 I/O GPIO3 16 IO15 I/O GPIO15, ADC2_CH3, TOUCH_CH3, MTDO 17 D1 I/O GPIO8, D1<sup>2</sup> 18 D0 I/O GPIO7, D0<sup>2</sup> 19 CLK P GPIO6, CLK<sup>2</sup> <p>[1] (1,2): P: Fuente de alimentaci\u00f3n; I: Input, O: Output</p> <p>[2] (1,2,3,4,5,6): The pins D0, D1, D2, D3, CMD and CLK are used internally for communication between ESP32 and SPI flash memory. They are grouped on both sides near the USB connector. Avoid using these pins, as it may disrupt access to the SPI flash memory / SPI RAM.</p> <p>[3] (1,2): The pins GPIO16 and GPIO17 are available for use only on the boards with the modules ESP32-WROOM and ESP32-SOLO-1. The boards with ESP32-WROVER modules have the pins reserved for internal use.</p>"},{"location":"00_introduccion/#pinout","title":"Pinout","text":""},{"location":"00_introduccion/#esp32-dev","title":"ESP32 Dev","text":""},{"location":"00_introduccion/#esp32-wemos-d1-r32","title":"ESP32 Wemos D1 R32","text":""},{"location":"00_introduccion/#consideraciones-con-algunos-pines","title":"Consideraciones con algunos pines","text":"<p>Los pines 34 y 35 solo pueden ser entradas, esto lo debes considerar si quieres ocupar la maxima cantidad de pines.</p> <p></p>"},{"location":"00_introduccion/#diagrama-esquematico","title":"Diagrama esquem\u00e1tico","text":"<p>Ver pdf original</p> <p>Esta informaci\u00f3n fue extra\u00edda de la documentaci\u00f3n oficial</p>"},{"location":"01_estructura/","title":"Estructura de c\u00f3digo base Arduino","text":"<p>El c\u00f3digo Arduino es de base es lenguaje <code>C/C++</code>, toda la sintaxis, estructura, etc. Pero, para facilitar la incursion en el ecosistema Arduino dise\u00f1o un estructura base que se divide en dos funciones principales, llamada <code>setup()</code> y <code>loop()</code>. Aqu\u00ed no vemos la funci\u00f3n <code>main()</code> porque esta ha sido abstra\u00edda para evitar mayores detalles, sin embargo, si existe en el programa principal pero no lo vemos.</p> <p>Regresando a la estructura de Arduino y sus funciones principales <code>setup()</code> y <code>loop()</code></p>"},{"location":"01_estructura/#la-funcion-setup","title":"La funci\u00f3n setup","text":"<p>La finalidad de esta funci\u00f3n es configurar pines, inicializar sensores, m\u00f3dulos, comunicaci\u00f3n serial, pantallas, etc.</p> <p>Esta funci\u00f3n es la primera en ejecutarse y solo una vez</p>"},{"location":"01_estructura/#la-funcion-loop","title":"La funci\u00f3n loop","text":"<p>La finalidad de esta funci\u00f3n es realizar todas las tareas colocadas aqu\u00ed de manera infinita (por eso se llama loop). Lo que vayamos a colocar aqu\u00ed se repetir\u00e1, realizando todas las tareas indicadas en el c\u00f3digo, aqu\u00ed mandamos los diferentes mensajes a pantallas, leemos constantemente los sensores, etc.</p> <p>Esta funci\u00f3n es la ultima en ejecutarse y se repetir\u00e1 de manera infinita todo el c\u00f3digo que este aqu\u00ed</p> <pre><code>// the setup function runs once when you press reset or power the board\nvoid setup() {\n  // secci\u00f3n de configuraci\u00f3n e inicializaci\u00f3n de todo tipo\n}\n\n// the loop function runs over and over again forever\nvoid loop() {\n    /*aqu\u00ed todo el c\u00f3digo que queremos que se repita por siempre;\n    es decir, las tareas que desarrollara el microcontrolador y realizar por siempre\n    */\n}\n</code></pre> <p>Ejemplo de c\u00f3digo blink (encendido y apagado de un LED)</p> <pre><code>#define LED_BUILTIN 34 //for ESP32 board, if you have Arduino UNO board, you don't have to do this\n\n// the setup function runs once when you press reset or power the board\nvoid setup() {\n  // initialize digital pin LED_BUILTIN as an output.\n  pinMode(LED_BUILTIN, OUTPUT);\n}\n\n// the loop function runs over and over again forever\nvoid loop() {\n  digitalWrite(LED_BUILTIN, HIGH);   // turn the LED on (HIGH is the voltage level)\n  delay(1000);                       // wait for a second\n  digitalWrite(LED_BUILTIN, LOW);    // turn the LED off by making the voltage LOW\n  delay(1000);                       // wait for a second\n}\n</code></pre>"},{"location":"01_estructura/#configuracion-del-entorno-para-el-esp32","title":"Configuraci\u00f3n del entorno para el ESP32","text":"<p>Hoy en d\u00eda la version de Arduino IDE 1.8x, ya se considera legacy, pero aun asi sigue funcionando de la misma manera para compilar, y hacer todo lo necesario para las placas que soporten el firmware de Arduino. Aunque ya se recomienda hacer uso de la version 2, dado que mejora de cierta manera algunas cosas (pero a mi consideraci\u00f3n aun esta verde y consume demasiado). </p> <p>Otra alternativa es usar VS Code con un plugin de PlatformIO, esto es aun m\u00e1s pesado, pero muy bueno (a m\u00ed consideraci\u00f3n es el mejor entorno, elimina varias limitaciones de la version 2, que me imagino en un futuro va a superar). Si deseas usarla en su sitio oficial est\u00e1n las instrucciones click aqu\u00ed.</p>"},{"location":"01_estructura/#arduino-ide-18x","title":"Arduino IDE 1.8.x","text":""},{"location":"01_estructura/#arduino-ide-2x","title":"Arduino IDE 2.x","text":""},{"location":"02_interfaz_ide/","title":"Interfaz de Arduino IDE","text":""},{"location":"02_interfaz_ide/#arduino-ide-18x","title":"Arduino IDE 1.8x","text":"<p>Vista general del editor</p> <p></p> <p></p>"},{"location":"02_interfaz_ide/#arduino-ide-2x","title":"Arduino IDE 2.x","text":""},{"location":"03_io/","title":"Entradas y Salidas Digitales (I/O)","text":""},{"location":"03_io/#niveles-logicos","title":"Niveles l\u00f3gicos","text":"<p>Tenemos que dar las indicaciones para mandar a nivel alto las salidas del microcontrolador; es decir, mandar a un <code>nivel l\u00f3gico 1</code> o <code>alto</code> o <code>True</code>, esto lo que har\u00e1 ser\u00e1 que a la salida del pin tenga un nivel de voltaje de <code>3.3V</code>, en caso de mandarlo a <code>0</code> o <code>bajo</code> o <code>False</code>, es equivalente a <code>0V</code>.</p> Programaci\u00f3n Nivel l\u00f3gico Digital Voltaje False 0 LOW 0V True 1 HIGH 3.3V"},{"location":"03_io/#salidas-y-entradas-digitales","title":"Salidas y Entradas digitales","text":""},{"location":"03_io/#salidas-digitales","title":"Salidas digitales","text":"<p>Para comenzar vamos a controlar las salidas digitales. Para esto se usa la funci\u00f3n <code>piMode</code> y <code>digitalWrite</code>.</p> <p><pre><code>// uso de la funci\u00f3n piMode y digitalWrite\npinMode(NO_PIN, MODO); // \ndigitalWrite(NO_PIN, I_O);\n</code></pre> Configuraci\u00f3n del <code>MODO</code>:</p> <ul> <li><code>OUTPUT</code>: Indica que el pin ser\u00e1 <code>salida</code></li> <li><code>INPUT</code>: Indica que el pin ser\u00e1 <code>entrada</code></li> </ul> <p>Configuraci\u00f3n <code>I_O</code></p> <ul> <li><code>LOW</code>: Apagado o nivel bajo o 0V</li> <li><code>HIGH</code>: Alto o nivel alto o 3.3V</li> </ul> <pre><code>// Aqu\u00ed indicamos que el pin 34 ser\u00e1 salida\npinMode(34, OUTPUT)\ndigitalWrite(34, HIGH);\n</code></pre> <p>Para conocer los pines que se pueden usar o el numero que podemos pasar para el pin ver la tabla de los pines</p>"},{"location":"03_io/#entradas-digitales","title":"Entradas digitales","text":"<p>Para comenzar vamos a controlar las entradas digitales. Para esto se usa la funci\u00f3n <code>pinMode</code>.</p> <p><pre><code>// uso de la funci\u00f3n pinMode\npinMode(NO_PIN, MODO); // \ndigitalWrite(NO_PIN, I_O);\n</code></pre> Configuraci\u00f3n del <code>MODO</code>:</p> <ul> <li><code>OUTPUT</code>: Indica que el pin ser\u00e1 <code>salida</code></li> <li><code>INPUT</code>: Indica que el pin ser\u00e1 <code>entrada</code></li> </ul> <p>Configuraci\u00f3n <code>I_O</code></p> <ul> <li><code>LOW</code>: Apagado o nivel bajo o 0V</li> <li><code>HIGH</code>: Alto o nivel alto o 3.3V</li> </ul> <p><pre><code>// Aqu\u00ed indicamos que el pin 32 ser\u00e1 entrada\npinMode(32, OUTPUT)\ndigitalWrite(32, INPUT);\n</code></pre> Para conocer los pines que se pueden usar o el numero que podemos pasar para el pin ver la tabla de los pines</p>"},{"location":"03_io/#utilizando-las-salidas-digitales","title":"Utilizando las salidas digitales","text":""},{"location":"03_io/#encender-un-led","title":"Encender un LED","text":"<p>Vamos a realizar un ejemplo b\u00e1sico para encender un LED.</p> <p>Material</p> Cantidad Descripci\u00f3n 1 Placa ESP32 1 LED 1 R330 <p>Diagrama pict\u00f3rico</p> <p></p> <p>C\u00f3digo</p> <pre><code>#define LED 32 // declaro una variable con el n\u00famero del pin en donde tengo el led\n// the setup function runs once when you press reset or power the board\nvoid setup() {\n  pinMode(LED, OUTPUT);   // configuro el pin 32 como salida\n  digitalWrite(LED, LOW); // indico que el pin 32 se ponga en estado BAJO, es decir, manda un 0 a la salida\n}\n\n// the loop function runs over and over again forever\nvoid loop() {\n  digitalWrite(LED, HIGH);   // indico que el pin 32 se ponga en estado ALTO, es decir, manda un 1 a la salida, prendiendo el LED\n}\n</code></pre>"},{"location":"03_io/#encender-varios-led","title":"Encender varios LED","text":"<p>Vamos a realizar un ejemplo b\u00e1sico para encender un LED.</p> <p>Material</p> Cantidad Descripci\u00f3n 1 Placa ESP32 3 LED 3 R330 <p>Diagrama pict\u00f3rico</p> <p></p> <p>C\u00f3digo</p> <pre><code>#define LED1 32 // declaro una variable con el n\u00famero del pin en donde tengo el led\n#define LED2 33 // declaro una variable con el n\u00famero del pin en donde tengo el led\n#define LED3 25 // declaro una variable con el n\u00famero del pin en donde tengo el led\n// the setup function runs once when you press reset or power the board\nvoid setup() {\n  pinMode(LED1, OUTPUT);   // configuro el pin 32 como salida\n  pinMode(LED2, OUTPUT);   // configuro el pin 33 como salida\n  pinMode(LED3, OUTPUT);   // configuro el pin 25 como salida\n  digitalWrite(LED1, LOW); // indico que el pin 32 se ponga en estado BAJO, es decir, manda un 0 a la salida\n  digitalWrite(LED2, LOW); // indico que el pin 33 se ponga en estado BAJO, es decir, manda un 0 a la salida\n  digitalWrite(LED3, LOW); // indico que el pin 25 se ponga en estado BAJO, es decir, manda un 0 a la salida\n}\n\n// the loop function runs over and over again forever\nvoid loop() {\n  digitalWrite(LED1, HIGH);   // indico que el pin 32 se ponga en estado ALTO, es decir, manda un 1 a la salida, prendiendo el LED\n  digitalWrite(LED2, HIGH);   // indico que el pin 33 se ponga en estado ALTO, es decir, manda un 1 a la salida, prendiendo el LED\n  digitalWrite(LED3, HIGH);   // indico que el pin 25 se ponga en estado ALTO, es decir, manda un 1 a la salida, prendiendo el LED\n}\n</code></pre>"},{"location":"03_io/#blink-led","title":"Blink LED","text":"<p>Vamos a realizar un ejemplo de parpadeo de un LED, conocido como blink-blink. Con un intervalo de tiempo de 1s.</p> <p>Material</p> Cantidad Descripci\u00f3n 1 Placa ESP32 1 LED 1 R330 <p>Diagrama pict\u00f3rico</p> <p></p> <p>C\u00f3digo</p> <pre><code>#define LED 32 // declaro una variable con el n\u00famero del pin en donde tengo el led\n\n// the setup function runs once when you press reset or power the board\n\nvoid setup() {\n  pinMode(LED, OUTPUT);   // configuro el pin 32 como salida\n  digitalWrite(LED, LOW); // indico que el pin 32 se ponga en estado BAJO, es decir, manda un 0 a la salida\n}\n\n// the loop function runs over and over again forever\nvoid loop() {\n  digitalWrite(LED, HIGH);   // enciendo el LED \n  delay(1000);               // espero un segundo\n  digitalWrite(LED, LOW);    // apago el LED\n  delay(1000);              // espero un segundo\n}\n</code></pre>"},{"location":"03_io/#semaforo-sencillo","title":"Sem\u00e1foro sencillo","text":"<p>Vamos a realizar un ejemplo de un sem\u00e1foro de cruce sencillo,</p> <p>Material</p> Cantidad Descripci\u00f3n 1 Placa ESP32 1 LED 1 R330 <p>Diagrama pict\u00f3rico</p> <p></p> <p>Simulaci\u00f3n</p> <p></p> <p>C\u00f3digo</p> <pre><code>#define LED1 32 //ROJO\n#define LED2 33 //AMARILLO\n#define LED3 25 //VERDE\n\n// the setup function runs once when you press reset or power the board\n\nvoid setup() {\n  pinMode(LED1, OUTPUT);\n  pinMode(LED2, OUTPUT);\n  pinMode(LED3, OUTPUT);\n  digitalWrite(LED1, LOW);\n  digitalWrite(LED2, LOW);\n  digitalWrite(LED3, LOW);\n  Serial.begin(115200); //inicio comunicaci\u00f3n serial\n}\n\n// the loop function runs over and over again forever\nvoid loop() {\n  digitalWrite(LED1, HIGH);\n  Serial.println(\"Enciende rojo\");\n  delay(2000);\n  digitalWrite(LED1, LOW);\n  digitalWrite(LED3, HIGH);\n  Serial.println(\"Apaga rojo\");\n  Serial.println(\"Enciende Verde\");\n  delay(900);\n  digitalWrite(LED3, LOW);\n  delay(300);\n  digitalWrite(LED3, HIGH);\n  delay(300);\n  digitalWrite(LED3, LOW);\n  delay(500);\n  digitalWrite(LED3, HIGH);\n  delay(300);\n  digitalWrite(LED3, LOW);\n  delay(500);\n  digitalWrite(LED3, HIGH);\n  delay(300);\n  digitalWrite(LED3, LOW);\n  digitalWrite(LED2, HIGH);\n  Serial.println(\"Apaga verde\");\n  Serial.println(\"Enciende amarillo\");\n  delay(900);\n  digitalWrite(LED2, LOW);\n  Serial.println(\"Apaga amarillo\");\n}\n</code></pre>"},{"location":"03_io/#entradas-digitales_1","title":"Entradas digitales","text":"<p>Nota</p> <p>Se estar\u00e1 usando por default los pines <code>34</code> y <code>35</code> para los botones dado que estos pines solo pueden ser usados como <code>INPUT</code>, y vamos a aprovechar esto para sean nuestras entradas, si tu deseas usar cualquier otro pin solo ajusta tu c\u00f3digo.</p>"},{"location":"03_io/#control-de-entrada-encender-led","title":"Control de entrada, encender LED","text":"<p>Vamos a usar un bot\u00f3n para que mientras se este presionando el bot\u00f3n, se encienda el LED; es decir, mientras mantenga presionado el bot\u00f3n el LED estar\u00e1 encendido</p> <p>Material</p> Cantidad Descripci\u00f3n 1 Placa ESP32 1 LED 1 R330 1 push button 1 R1K <p>Diagrama pict\u00f3rico</p> <p></p> <p>C\u00f3digo</p> <pre><code>#define LED 32 // declaro una variable con el n\u00famero del pin en donde tengo el led\n#define BTN 34 // declaro una variable para identificar el pin en donde estar\u00e1 el bot\u00f3n\n\n// the setup function runs once when you press reset or power the board\nvoid setup() {\n  pinMode(LED, OUTPUT);   // configuro el pin 32 como salida\n  pinMode(BTN, INPUT); // configuro el pin 34 como entrada\n  digitalWrite(LED, LOW); // indico que el pin 32 se ponga en estado BAJO, es decir, manda un 0 a la salida\n}\n\n// the loop function runs over and over again forever\nvoid loop() {\n\n  int status = digitalRead(BTN); //leo el estado del bot\u00f3n y lo guardo en la variable status\n  if( status == 1){ //si el bot\u00f3n esta siendo presionado mando entro \n    digitalWrite(LED, HIGH);   // enciendo el LED \n    delay(250); // espero este tiempo para evitar el transitorio del bot\u00f3n\n  }else{\n    digitalWrite(LED, LOW);   // apago el LED \n  }\n}\n</code></pre>"},{"location":"03_io/#led-onoff","title":"LED ON/OFF","text":"<p>En este caso, si presiono el LED, este se enciende y se manteniente de esa manera, en caso que se vuelva a presionar, se apagar\u00e1 hasta que sea presionado de nuevo el LED.</p> <p>Material</p> Cantidad Descripci\u00f3n 1 Placa ESP32 1 LED 1 R330 1 push button 1 R1K <p>Diagrama pict\u00f3rico</p> <p></p> <p>C\u00f3digo</p> <pre><code>#define LED 32 // declaro una variable con el n\u00famero del pin en donde tengo el led\n#define BTN 34 // declaro una variable para identificar el pin en donde estar\u00e1 el bot\u00f3n\n\n// the setup function runs once when you press reset or power the board\nvoid setup() {\n  pinMode(LED, OUTPUT);   // configuro el pin 32 como salida\n  pinMode(BTN, INPUT); // configuro el pin 34 como entrada\n  digitalWrite(LED, LOW); // indico que el pin 32 se ponga en estado BAJO, es decir, manda un 0 a la salida\n}\n\n// the loop function runs over and over again forever\nvoid loop() {\n\n  int status = digitalRead(BTN); //leo el estado del bot\u00f3n y lo guardo en la variable status\n  if( status == 1){ //si el bot\u00f3n esta siendo presionado mando entro \n    digitalWrite(LED, HIGH);   // enciendo el LED \n    delay(250); // espero este tiempo para evitar el transitorio del bot\u00f3n\n  }else{\n    digitalWrite(LED, LOW);   // apago el LED \n  }\n}\n</code></pre>"},{"location":"03_io/#led-onoff-toggle","title":"LED ON/OFF (Toggle)","text":"<p>En este caso, si presiono el LED, este se enciende y se manteniente de esa manera, en caso que se vuelva a presionar, se apagar\u00e1 hasta que sea presionado de nuevo el LED.</p> <p>Material</p> Cantidad Descripci\u00f3n 1 Placa ESP32 1 LED 1 R330 1 push button 1 R1K <p>Diagrama pict\u00f3rico</p> <p></p> <p>C\u00f3digo</p> <pre><code>#define LED 32 // declaro una variable con el n\u00famero del pin en donde tengo el led\n#define BTN 34; // declaro una variable para identificar el pin en donde estar\u00e1 el bot\u00f3n\n\n// the setup function runs once when you press reset or power the board\nvoid setup() {\n  pinMode(LED, OUTPUT);   // configuro el pin 32 como salida\n  pinMode(BTN, INPUT); // configuro el pin 34 como entrada\n  digitalWrite(LED, LOW); // indico que el pin 32 se ponga en estado BAJO, es decir, manda un 0 a la salida\n}\n\n// the loop function runs over and over again forever\nvoid loop() {\n\n  int status = digitalRead(BTN); //leo el estado del bot\u00f3n y lo guardo en la variable status\n  if( status == 1){ //si el bot\u00f3n esta siendo presionado mando entro \n    digitalWrite(LED, !digitalRead(LED));   // enciendo el LED o lo apaga dependiendo su estado \n    delay(250); // espero este tiempo para evitar el transitorio del bot\u00f3n\n  }\n}\n</code></pre>"},{"location":"03_io/#control-de-buzzer","title":"Control de buzzer","text":"<p>Vamos a realizar un control de un buzzer activo (es decir, que con alimentaci\u00f3n emita un sonido), cuando no se presione el bot\u00f3n, simplemente parpadea un led a 250mS, cuando sea presionado el bot\u00f3n el buzzer sonara y al mismo tiempo el LED va a encender a la misma velocidad</p> <p>Material</p> Cantidad Descripci\u00f3n 1 Placa ESP32 1 LED 1 R330 1 push button 1 R1K 1 Buzzer activo <p>Diagrama pict\u00f3rico</p> <p></p> <p>C\u00f3digo</p> <pre><code>#define LED 33 // declaro una variable con el n\u00famero del pin en donde tengo el led\n#define BUZZER 25 // declaro la variable con el numero del pin en donde tendr\u00e9 el buzzer\n#define BTN 34 // declaro una variable para identificar el pin en donde estar\u00e1 el bot\u00f3n\n\n// the setup function runs once when you press reset or power the board\nvoid setup() {\n  pinMode(LED, OUTPUT);   // configuro el pin 33 como salida\n  pinMode(BUZZER, OUTPUT);   // configuro el pin 25 como salida\n  pinMode(BTN, INPUT); // configuro el pin 34 como entrada\n  digitalWrite(LED, LOW); // indico que el pin 33 se ponga en estado BAJO, es decir, manda un 0 a la salida\n}\n\n// the loop function runs over and over again forever\nvoid loop() {\n\n  int status = digitalRead(BTN); //leo el estado del bot\u00f3n y lo guardo en la variable status\n\n  if ( status == 1) { //si el bot\u00f3n esta siendo presionado mando entro\n    digitalWrite(LED, HIGH);   // enciendo el LED\n    digitalWrite(BUZZER, HIGH);   // enciendo el BUZZER\n    delay(100); // espero este tiempo escuchar el sonido correcto\n    digitalWrite(LED, LOW);   // enciendo el LED\n    digitalWrite(BUZZER, LOW);   // enciendo el BUZZER\n    delay(100); // espero este tiempo escuchar el sonido correcto\n  } else {\n    digitalWrite(LED, HIGH);   // enciendo el LED\n    delay(250); //parpadea el LED\n    digitalWrite(LED, LOW);   // enciendo el LED\n    delay(250); //parpadea el LED\n  }\n}\n</code></pre>"},{"location":"03_io/#display-de-7-segmentos","title":"Display de 7 segmentos","text":"<p>Note</p> <p>Se estar\u00e1 usando un display de 7 segmentos de C\u00e1todo com\u00fan en todos los ejemplos, en caso de contar con uno de \u00e1nodo com\u00fan, hacer los ajuste necesarios en el c\u00f3digo</p>"},{"location":"03_io/#contador-basico-con-display-de-7-segmentos","title":"Contador b\u00e1sico con display de 7 segmentos","text":"Im\u00e1genes ejemplo <p>Material</p> Cantidad Descripci\u00f3n 1 Placa ESP32 1 LED 7 R330 1 Display de 7 segmentos de c\u00e1todo com\u00fan <p>Diagrama pict\u00f3rico</p> <p></p> <p>C\u00f3digo</p> <pre><code>#define A 25\n#define B 26\n#define C 27\n#define D 14\n#define E 12\n#define F 19\n#define G 18\n\nvoid display(int a, int b, int c, int d, int e, int f, int g);\n\nvoid display(int a, int b, int c, int d, int e, int f, int g)\n{\n  digitalWrite(A, a);\n  digitalWrite(B, b);\n  digitalWrite(C, c);\n  digitalWrite(D, d);\n  digitalWrite(E, e);\n  digitalWrite(F, f);\n  digitalWrite(G, g);\n}\n\nvoid setup()\n{\n  Serial.begin(115200);\n  pinMode(A, OUTPUT);\n  pinMode(B, OUTPUT);\n  pinMode(C, OUTPUT);\n  pinMode(D, OUTPUT);\n  pinMode(E, OUTPUT);\n  pinMode(F, OUTPUT);\n  pinMode(G, OUTPUT);\n}\n\n// the loop function runs over and over again forever\n\nvoid loop()\n{\n\n  display(1, 1, 1, 1, 1, 1, 0); // 0\n  delay(500);\n  display(0, 1, 1, 0, 0, 0, 0); // 1\n  delay(500);\n  display(1, 1, 0, 1, 1, 0, 1); // 2\n  delay(500);\n  display(1, 1, 1, 1, 0, 0, 1); // 3\n  delay(500);\n  display(0, 1, 1, 0, 0, 1, 1); // 4\n  delay(500);\n  display(1, 0, 1, 1, 0, 1, 1); // 5\n  delay(500);\n  display(1, 0, 1, 1, 1, 1, 1); // 6\n  delay(500);\n  display(1, 1, 1, 0, 0, 0, 0); // 7\n  delay(500);\n  display(1, 1, 1, 1, 1, 1, 1); // 8\n  delay(500);\n  display(1, 1, 1, 0, 0, 1, 1); // 9\n  delay(500);\n  display(1, 1, 1, 0, 1, 1, 1); // A\n  delay(500);\n  display(0, 0, 1, 1, 1, 1, 1); // B\n  delay(500);\n  display(1, 0, 0, 1, 1, 1, 0); // C\n  delay(500);\n  display(0, 1, 1, 1, 1, 0, 1); // D\n  delay(500);\n  display(1, 0, 0, 1, 1, 1, 1); // E\n  delay(500);\n  display(1, 0, 0, 0, 1, 1, 1); // F\n  delay(500);\n}\n</code></pre>"},{"location":"03_io/#contador-basico-con-boton-display-de-7-segmentos","title":"Contador b\u00e1sico con bot\u00f3n, display de 7 segmentos","text":"<p>Ahora vamos a controlar el display haciendo el incremento de manera manual, cada que se presione el bot\u00f3n se har\u00e1 el cambio de d\u00edgito, una vez llegue al final se reiniciara el contador.</p> <p>Material</p> Cantidad Descripci\u00f3n 1 Placa ESP32 1 LED 7 R330 1 Display de 7 segmentos de c\u00e1todo com\u00fan 1 Push button 1 R1k <p>Diagrama pict\u00f3rico</p> <p></p> <p>C\u00f3digo</p> <pre><code>#define A  25\n#define B  26\n#define C  27\n#define D  14\n#define E  12\n#define F  19\n#define G  18\n#define BTN  34\n\nvoid display(int a, int b, int c, int d, int e, int f, int g);\n\nvoid display(int a, int b, int c, int d, int e, int f, int g)\n{\n  digitalWrite(A, a);\n  digitalWrite(B, b);\n  digitalWrite(C, c);\n  digitalWrite(D, d);\n  digitalWrite(E, e);\n  digitalWrite(F, f);\n  digitalWrite(G, g);\n}\n\nvoid setup()\n{\n  Serial.begin(115200);\n  pinMode(A, OUTPUT);\n  pinMode(B, OUTPUT);\n  pinMode(C, OUTPUT);\n  pinMode(D, OUTPUT);\n  pinMode(E, OUTPUT);\n  pinMode(F, OUTPUT);\n  pinMode(G, OUTPUT);\n}\n\n// the loop function runs over and over again forever\nint count = 0; //variable que me ayuda a conocer en que d\u00edgito hay que desplegar\nvoid loop() {\n\n  if (digitalRead(BTN) == 1) {\n    delay(250);\n    if (count &lt; 15) {\n      count++;\n    }\n    else {\n      count = 0;\n    }\n  }\n\n  if (count == 0)\n    display(1, 1, 1, 1, 1, 1, 0); // 0\n  if (count == 1)\n    display(0, 1, 1, 0, 0, 0, 0); // 1\n  if (count == 2)\n    display(1, 1, 0, 1, 1, 0, 1); // 2\n  if (count == 3)\n    display(1, 1, 1, 1, 0, 0, 1); // 3\n  if (count == 4)\n    display(0, 1, 1, 0, 0, 1, 1); // 4\n  if (count == 5)\n    display(1, 0, 1, 1, 0, 1, 1); // 5\n  if (count == 6)\n    display(1, 0, 1, 1, 1, 1, 1); // 6\n  if (count == 7)\n    display(1, 1, 1, 0, 0, 0, 0); // 7\n  if (count == 8)\n    display(1, 1, 1, 1, 1, 1, 1); // 8\n  if (count == 9)\n    display(1, 1, 1, 0, 0, 1, 1); // 9\n  if (count == 10)\n    display(1, 1, 1, 0, 1, 1, 1); // A\n  if (count == 11)\n    display(0, 0, 1, 1, 1, 1, 1); // B\n  if (count == 12)\n    display(1, 0, 0, 1, 1, 1, 0); // C\n  if (count == 13)\n    display(0, 1, 1, 1, 1, 0, 1); // D\n  if (count == 14)\n    display(1, 0, 0, 1, 1, 1, 1); // E\n  if (count == 15)\n    display(1, 0, 0, 0, 1, 1, 1); // F\n\n  delay(10);\n}\n</code></pre>"},{"location":"03_io/#giro-en-dos-sentidos-motor-dc","title":"Giro en dos sentidos Motor DC","text":"<p>Realizaremos un control b\u00e1sico de un control DC, haci\u00e9ndolo girar en un sentido con un bot\u00f3n y se invertir\u00e1 el sentido presionando el 2o bot\u00f3n. Tendr\u00e1 un LED indicativo del giro.</p> <p>Material</p> Cantidad Descripci\u00f3n 1 Placa ESP32 2 LED 2 R330 2 Push button 2 R1k 1 Driver para motor DC (MX1580, L298 o L293) 1 Motor DC (6V) 1 Fuente externa para el motor, de 1A (m\u00ednimo) <p>Diagrama pict\u00f3rico</p> <p></p> <p></p> <p>C\u00f3digo</p> <pre><code>//Configuro los pines f\u00edsicos para las entradas y salidas\n#define LED_I 25\n#define LED_D 26\n#define MOTOR_1 18\n#define MOTOR_2 19\n#define BTN_D 34\n#define BTN_I 35\n\nvoid setup() {\n  // configurando los pines como entradas y salidas\n  pinMode(LED_I, OUTPUT);\n  pinMode(LED_D, OUTPUT);\n  pinMode(MOTOR_1, OUTPUT);\n  pinMode(MOTOR_2, OUTPUT);\n  pinMode(BTN_I, INPUT);\n  pinMode(BTN_D, INPUT);\n}\n\nvoid loop() {\n\n  if (digitalRead(BTN_I) == 1) {\n    delay(100);\n    // Motor\n    digitalWrite(MOTOR_1, HIGH);\n    digitalWrite(MOTOR_2, LOW);\n    //Leds\n    digitalWrite(LED_I,HIGH);\n    digitalWrite(LED_D,LOW);\n  } else if (digitalRead(BTN_D) == 1) {\n    delay(100);\n    // Motor\n    digitalWrite(MOTOR_1, LOW);\n    digitalWrite(MOTOR_2, HIGH);\n    //Leds\n    digitalWrite(LED_I,LOW);\n    digitalWrite(LED_D,HIGH);\n  } else {\n     // Motor apagado\n    digitalWrite(MOTOR_1, LOW);\n    digitalWrite(MOTOR_2, LOW);\n    //Hago un blink con los leds\n    //Leds\n    digitalWrite(LED_I,LOW);\n    digitalWrite(LED_D,LOW);\n    delay(250);    \n    digitalWrite(LED_I,HIGH);\n    digitalWrite(LED_D,HIGH);\n    delay(250);\n  }\n}\n</code></pre>"},{"location":"03_io/#control-de-motor-pap","title":"Control de Motor PAP","text":"<p>Vamos a realizar el control de un motor Paso a Paso, en sus diferentes combinaciones de secuencias, es decir, medio paso, paso completo</p> <p>Material</p> Cantidad Descripci\u00f3n 1 Placa ESP32 2 LED 2 R330 2 Push button 2 R1k 1 M\u00f3dulo de driver para Motor PAP (ULN2003) 1 Motor PAP 28BYJ-48 1 Fuente externa para el motor, de 1A (m\u00ednimo) <p>Descripci\u00f3n del Motor PAP 28BYJ-48 y Driver ULN</p> <p></p> <ul> <li>Total de pasas por revoluci\u00f3n = 2048 steps</li> <li>\u00c1ngulo del paso = 0.18\u00ba/step</li> </ul> <p></p> <p>Diagrama pict\u00f3rico</p> <p></p> <p></p> <p>C\u00f3digo</p> <pre><code>#include &lt;Stepper.h&gt;\n\n#define stepsPerRevolution 512  //\n\n//se crea el objeto de la librer\u00eda para ser configurada\nStepper myStepper(stepsPerRevolution, 25, 26, 27, 14);\n\nconst int BTN_I = 34;\nconst int BTN_D = 35;\n\nvoid setup() {\n  // set the speed at 60 rpm:\n  myStepper.setSpeed(60);\n  // initialize the serial port:\n  Serial.begin(115200);\n  pinMode(BTN_I, INPUT);\n  pinMode(BTN_D, INPUT);\n}\n\nvoid loop() {\n\n  if (digitalRead(BTN_I) == 1) {\n    // step one revolution  in one direction:\n    Serial.println(\"clockwise\");\n    myStepper.step(stepsPerRevolution);\n    delay(10);\n\n  }else if (digitalRead(BTN_D) == 1) {\n    // step one revolution in the other direction:\n    Serial.println(\"counterclockwise\");\n    myStepper.step(-stepsPerRevolution);\n    delay(10);\n  }\n\n}\n</code></pre>"},{"location":"03_io/#control-de-carga-ac-modulo-de-relay","title":"Control de carga AC - Modulo de Relay","text":"<p>Realizaremos un control b\u00e1sico de un control DC, haci\u00e9ndolo girar en un sentido con un bot\u00f3n y se invertir\u00e1 el sentido presionando el 2o bot\u00f3n. Tendr\u00e1 un LED indicativo del giro.</p> <p>Material</p> Cantidad Descripci\u00f3n 1 Placa ESP32 2 LED 2 R330 2 Push button 2 R1k 1 Fuente externa para el motor, de 1A (m\u00ednimo) 1 M\u00f3dulo de Relay 1 Foco (puede ser cualquier otra Carga AC ligera) con su clavija <p>Diagrama pict\u00f3rico</p> <p>Para el modulo de un Relay</p> <p></p> <p>Para el modulo doble Relay</p> <p></p> <p>C\u00f3digo</p> <pre><code>//creo las constantes de los pines en donde se colocaran los elementos de entrada y salida\n\n#define MODULE_SINGLE 2  // SI ESTAS USANDO EL MODULO DE DOBLE RELAY, CAMBIA EL VALOR A 2\n\n\n#define BTN 34\n#define RELAY 25\n\nvoid setup() {\n  //configuro los pines como entrada y salida\n  pinMode(BTN, INPUT);\n  pinMode(RELAY, OUTPUT);\n\n  if(MODULE_SINGLE == 2){\n    digitalWrite(RELAY, HIGH);\n  }else{\n    digitalWrite(RELAY, LOW);\n  }\n}\n\nvoid loop() {\n\n  if (digitalRead(BTN) == 1) {\n    //invierto el estado de la salida, es decir, si esta apagado se enciende\n    digitalWrite(RELAY, !digitalRead(RELAY));\n    delay(250);\n  }\n}\n</code></pre>"},{"location":"03_io/#control-rf-315-mhz","title":"Control RF 315 MHz","text":"<p>El control RF ya incluye un decodificador, es decir, este IC es el encargado de decirnos qu\u00e9 bot\u00f3n fue presionado en el control y con ello sabremos la acci\u00f3n a realizar.</p> <p></p> <p>Descripci\u00f3n del receptor </p> <p></p> <p>Cuando se pulsa un bot\u00f3n el control remoto, si la comunicaci\u00f3n es correcta levanta el pin VT para indicar que ha detectado una transmisi\u00f3n valida (Valid Trans).</p> <p></p> <p>Probando el funcionamiento del Control con receptor</p> <p>C\u00f3digo</p> <pre><code>///defino los pines de entrada y salida\n#define D0 34\n#define D1 35\n#define D2 32\n#define D3 33\n\n#define LED1 26\n#define LED2 27\n#define LED3 14\n#define LED4 12\n\nvoid setup() {\n  pinMode(D0, INPUT);\n  pinMode(D1, INPUT);\n  pinMode(D2, INPUT);\n  pinMode(D3, INPUT);\n  pinMode(LED1, OUTPUT);\n  pinMode(LED2, OUTPUT);\n  pinMode(LED3, OUTPUT);\n  pinMode(LED4, OUTPUT);\n  // inicializamos la pantalla para comunicaci\u00f3n\n  Serial.begin(115200);\n\n}\n\nvoid loop() {\n\n  if (digitalRead(D0) == 1) {\n    Serial.println(\"D0\");\n    digitalWrite(LED1, !digitalRead(LED1));\n  }\n  if (digitalRead(D1) == 1) {\n    Serial.println(\"D1\");\n    digitalWrite(LED2, !digitalRead(LED2));\n  }\n  if (digitalRead(D2) == 1) {\n    Serial.println(\"D2\");\n    digitalWrite(LED3, !digitalRead(LED3));\n  }\n  if (digitalRead(D3) == 1) {\n    Serial.println(\"D3\");\n    digitalWrite(LED4, !digitalRead(LED4));\n  }\n  delay(250);\n}\n</code></pre>"},{"location":"03_io/#mini-proyecto","title":"Mini proyecto","text":""},{"location":"03_io/#seguidor-de-luz","title":"Seguidor de Luz","text":"<p>Es un carrito seguidor de Luz, cuando se recibe la luz en el sensor izquierdo, se activa el motor derecho, cuando recibe luz el sensor derecho se activa el motor izquierdo, si se recibe la luz en ambos se activan los 2 motores al mismo tiempo.</p> <p></p> <p>Abrir la imagen</p> <p><code>Nota: Solo se cambia la secci\u00f3n de control por la placa ESP32</code></p> <p></p> <p>C\u00f3digo</p> <pre><code>//Se uso el ESP32 version Wemos\n#define sensorD  19 //\n#define sensorI  23\n#define motorD_1  26 // 26\n#define motorD_2  25 // 25\n#define motorI_1  17 // 17\n#define motorI_2  16 //1 6\n\nvoid setup() {\n  // put your setup code here, to run once:\n  Serial.begin(115200);\n  Serial.println(\"inicio\");\n  pinMode(sensorD, INPUT);\n  pinMode(sensorI, INPUT);\n  pinMode(motorD_1, OUTPUT);\n  pinMode(motorD_2, OUTPUT);\n  pinMode(motorI_1, OUTPUT);\n  pinMode(motorI_2, OUTPUT);\n  digitalWrite(motorD_2, LOW);\n  digitalWrite(motorI_2, LOW);\n\n}\n\nvoid loop() {\n\n  if (digitalRead(sensorD) == 1 &amp;&amp; digitalRead(sensorI) == 1) {\n    Serial.println(\"derecho e izquierdo\");\n    digitalWrite(motorD_1, HIGH);\n    digitalWrite(motorI_1, HIGH);\n    delay(10);\n  } else if (digitalRead(sensorI) == 1) {\n    Serial.println(\"izquierdo\");\n    digitalWrite(motorD_1, HIGH);\n    digitalWrite(motorI_1, LOW);\n    delay(10);\n  } else if (digitalRead(sensorD) == 1) {\n    Serial.println(\"derecho\");\n    digitalWrite(motorD_1, LOW);\n    digitalWrite(motorI_1, HIGH);\n    delay(10);\n  } else {\n    Serial.println(\"nada\");\n    digitalWrite(motorD_1, LOW);\n    digitalWrite(motorI_1, LOW);\n    delay(10);\n  }\n\n}\n</code></pre>"},{"location":"04_io_ex/","title":"Ejercicios con I/O Digitales","text":""},{"location":"04_io_ex/#display-de-7-segmentos","title":"Display de 7 Segmentos","text":"<p>Realizar el siguiente ejercicio, como se ve en la animaci\u00f3n</p> <p></p> <p>Funcionamiento</p> <ol> <li>Contador hexadecimal, es decir, va desde el 0 hasta la F</li> <li>0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F</li> <li>Cada que se presione un bot\u00f3n, debe incrementar el d\u00edgito</li> <li>Cada que se presione otro bot\u00f3n, se decrementa en uno el d\u00edgito</li> <li>Hay un tercer bot\u00f3n, para el reset del conteo</li> <li>Cuando llegue al topo superior (F) o inferior (cero), no debe pasar nada</li> </ol>"},{"location":"04_io_ex/#control-de-motor-dc-con-lcd","title":"Control de Motor DC con LCD","text":"<p>Realizar el siguiente ejercicio, como se ve en la animaci\u00f3n</p> <p></p> <p>Funcionamiento</p> <ol> <li>Cuando el no se este presionando ning\u00fan bot\u00f3n, debe estar parpadeando los 2 leds y en la pantalla indicar \"MOTOR DETENIDO\"</li> <li>Cuando sea presionado un bot\u00f3n debe encender solamente el LED indicativo a dicha direcci\u00f3n, e indicar en la pantalla \"MOTOR A LA DERECHA\"</li> <li>Cuando sea presionado el otro bot\u00f3n debe encender solamente el LED indicativo a dicha direcci\u00f3n, e indicar en la pantalla \"MOTOR A LA IZQUIERDA\"</li> </ol>"},{"location":"05_adc_pwm/","title":"Entradas y Salidas anal\u00f3gicas (ADC y PWM)","text":""},{"location":"05_adc_pwm/#entradas-analogicas","title":"Entradas anal\u00f3gicas","text":"<p>El ADC es un modulo interno que tiene el microcontrolador ESP32, el cual su funci\u00f3n es convertir unas se\u00f1al de voltaje a un valor equivalente en binario, este valor determinado por la resoluci\u00f3n del convertidor.</p> <p>Caracter\u00edsticas del ADC</p> <ul> <li>Voltaje de entrada <code>0V</code> a <code>3.3V</code></li> <li>Resoluci\u00f3n de 12 bits</li> <li>Valor en decimal de <code>0</code> a <code>4095</code></li> <li>El valor mas peque\u00f1o que podemos medir es de 0.8mV o 800uV (en teor\u00eda)</li> <li>Tenemos 11 canales disponibles para utilizar (los dem\u00e1s no los podemos usar si usamos el framework de Arduino)</li> </ul> <p>Los pines a los que se puede conectar son los que indican <code>ADCx CHx</code>, lo cual significa Canal <code>X</code> ADC. Nota: Recuerda que hay pines que no podemos utilizar.</p> <p></p> <p>Note</p> <p>No se necesita inicializar el pin como entrada, solo se usa la funci\u00f3n <code>analogRead(pin)</code>.  <pre><code>// de esta manera utilizar\u00edamos la funci\u00f3n y guarda el dato en una variable\nint valueADC = analogRead(noPin);\n</code></pre></p> <p>Note</p> <p>Se recomienda colocar un capacitor de 0.1uF en la entrada del ADC para reducir el ruido, junto con multimuestra para reducirlo lo m\u00e1ximo posible. Ir a documentaci\u00f3n oficial</p> <p>Danger</p> <p>NUNCA se debe exceder de 3.3V a la entrada del ADC, ni voltajes negativos, esto da\u00f1ar\u00eda de manera parcial o total el microcontrolador.</p> <p>Hay varias caracter\u00edsticas avanzadas relacionadas al ADC que no se van a tratar.</p>"},{"location":"05_adc_pwm/#leyendo-una-entrada-analogica","title":"Leyendo una entrada anal\u00f3gica","text":"<p>Vamos a realizar una lectura b\u00e1sica de un ADC y mandar ese valor a la monitor serial.</p> <p>Material</p> Cantidad Descripci\u00f3n 1 Placa ESP32 1 LED 1 Pot 10k <p>Diagrama pict\u00f3rico</p> <p></p> <p>C\u00f3digo</p> <pre><code>#define pinADC 34 //pin que sera le\u00eddo del ADC\n\n// the setup routine runs once when you press reset:\nvoid setup() {\n  // inicializamos el monitor serial a 115200 baudios\n  Serial.begin(115200);\n}\n\n// the loop routine runs over and over again forever:\nvoid loop() {\n  //se lee el pin del ADC y se guarda en la variable valueADC\n  int valueADC = analogRead(pinADC);\n  Serial.println(valueADC);// se imprime el valor del ADC\n  delay(10);        // para la estabilidad del valor de entrada\n}\n</code></pre>"},{"location":"05_adc_pwm/#barra-de-leds-con-potenciometro","title":"Barra de LEDs con potenci\u00f3metro","text":"<p>Vamos a realizar una lectura del ADC e ir encendiendo los LEDs en funci\u00f3n del valor que tengamos de entrada, es decir, entre mas valores, mas se prender\u00e1n, y entre menor sea el valor, menos encender\u00e1n.</p> <p>Material</p> Cantidad Descripci\u00f3n 1 Placa ESP32 1 LED 1 Pot 10k 3 LEDs 3 R330 <p>Diagrama pict\u00f3rico</p> <p></p> <p>C\u00f3digo</p> <pre><code>#define pinADC 34  //pin que sera le\u00eddo del ADC\n#define LED1 33    //Configuro el pin en donde colocar\u00e9 el LED\n#define LED2 25    //Configuro el pin en donde colocar\u00e9 el LED\n#define LED3 26    //Configuro el pin en donde colocar\u00e9 el LED\n\n// the setup routine runs once when you press reset:\nvoid setup() {\n  // inicializamos el monitor serial a 115200 baudios\n  Serial.begin(115200);\n  pinMode(LED1, OUTPUT);  //configuro como salida el pin para el led\n  pinMode(LED2, OUTPUT);  //configuro como salida el pin para el led\n  pinMode(LED3, OUTPUT);  //configuro como salida el pin para el led\n}\n\n// the loop routine runs over and over again forever:\nvoid loop() {\n  //se lee el pin del ADC y se guarda en la variable valueADC\n  int valueADC = analogRead(pinADC);\n  Serial.println(valueADC);  // se imprime el valor del ADC\n  if (valueADC &lt; 100) {      // si esta por debajo de este valor, se apagando todos los LEDs\n    digitalWrite(LED1, LOW);\n    digitalWrite(LED2, LOW);\n    digitalWrite(LED3, LOW);\n  } else if (valueADC &gt; 100 &amp;&amp; valueADC &lt;= 1500) {  // si esta en este rango prender\u00e1 los leds indicados\n    digitalWrite(LED1, HIGH);\n    digitalWrite(LED2, LOW);\n    digitalWrite(LED3, LOW);\n  } else if (valueADC &gt; 1500 &amp;&amp; valueADC &lt;= 3000) {  // si esta en este rango prender\u00e1 los leds indicados\n    digitalWrite(LED1, HIGH);\n    digitalWrite(LED2, HIGH);\n    digitalWrite(LED3, LOW);\n  } else {  //si es mayor a 3000, se encienden todos los leds\n    digitalWrite(LED1, HIGH);\n    digitalWrite(LED2, HIGH);\n    digitalWrite(LED3, HIGH);\n  }\n  delay(10);  // para la estabilidad del valor de entrada\n}\n</code></pre>"},{"location":"05_adc_pwm/#control-crepuscular-sensor-de-luz","title":"Control crepuscular (Sensor de luz)","text":"<p>Vamos a encender el LED cuando hay poco luz, de lo contrario se debe apagar.</p> <p>Material</p> Cantidad Descripci\u00f3n 1 Placa ESP32 1 LED 1 R330 1 R10k 1 LDR <p>Diagrama pict\u00f3rico</p> <p></p> <p>C\u00f3digo</p> <pre><code>#define pinADC 34  //pin que sera le\u00eddo del ADC\n#define LED1 25    //Configuro el pin en donde colocar\u00e9 el LED\n#define LIMIT 2500       //ESTE VALOR SE CAMBIA CON BASE AL AJUSTE DEL SENSOR\n\n// the setup routine runs once when you press reset:\nvoid setup() {\n  // inicializamos el monitor serial a 115200 baudios\n  Serial.begin(115200);\n  pinMode(LED1, OUTPUT);  //configuro como salida el pin para el led\n}\n\nvoid loop() {\n  int valueLDR = analogRead(pinADC);  //leemos el pin del ADC\n  Serial.print(\"Valor del ADC: \");\n  Serial.println(valueLDR);\n\n  if (valueLDR &gt; LIMIT) {\n    digitalWrite(LED1, HIGH);\n  } else {\n    digitalWrite(LED1, LOW);\n  }\n\n  delay(10);  // para la estabilidad del valor de entrada\n}\n</code></pre>"},{"location":"05_adc_pwm/#control-crepuscular-sensor-de-luz-con-promedio","title":"Control crepuscular (Sensor de luz) con PROMEDIO","text":"<p>Este circuito toma la lectura del sensor de luz, imprime ese valor y tambi\u00e9n hace el calculo del promedio de 50 muestras, para dar un valor mas estable de salida. Para ver como se ve el resultado utilizar el <code>serial plotter</code> de IDE o alg\u00fan otro software para gr\u00e1ficar datos de comunicaci\u00f3n serial.</p> <p>Material</p> Cantidad Descripci\u00f3n 1 Placa ESP32 1 LED 1 R330 1 R10k 1 LDR <p>Diagrama pict\u00f3rico</p> <p></p> <p>C\u00f3digo</p> <pre><code>#define pinADC 34  //pin que sera le\u00eddo del ADC\n\n// the setup routine runs once when you press reset:\nvoid setup() {\n  // inicializamos el monitor serial a 115200 baudios\n  Serial.begin(115200);\n}\n\nfloat promedio = 0.0;\nlong suma = 0;\nint contador = 0;\n\nvoid loop() {\n\n  int valueADC = analogRead(pinADC);\n  Serial.print(\"Luz:\");\n  Serial.print(valueADC);\n  Serial.print(\",\");\n\n  if (contador &lt; 50) {\n    suma += valueADC;\n    contador++;\n  } else {\n    promedio = (float)suma / 50.0;\n    contador = 0;\n    suma = 0;\n  }\n\n  Serial.print(\"Promedio:\");\n  Serial.println(promedio);\n  delay(500);\n}\n</code></pre> <p>Gr\u00e1fica obtenida</p> <p></p> <p>Software utilizado: Serial Test</p>"},{"location":"05_adc_pwm/#semaforo-con-sensor-de-luz","title":"Sem\u00e1foro con Sensor de Luz","text":"<p>Vamos a encender el LED cuando hay poco luz, de lo contrario se debe apagar.</p> <p>Material</p> Cantidad Descripci\u00f3n 1 Placa ESP32 3 LED 3 R330 1 R10k 1 LDR <p>Diagrama pict\u00f3rico</p> <p></p> <p>Simulaci\u00f3n</p> <p></p> <p>C\u00f3digo</p> <pre><code>#define LED1 32 //ROJO\n#define LED2 33 //AMARILLO\n#define LED3 25 //VERDE\n#define pinADC 34  //pin que sera le\u00eddo del ADC\n#define LIMIT 2000  \n\n// the setup function runs once when you press reset or power the board\n\nvoid setup() {\n  pinMode(LED1, OUTPUT);\n  pinMode(LED2, OUTPUT);\n  pinMode(LED3, OUTPUT);\n  digitalWrite(LED1, LOW);\n  digitalWrite(LED2, LOW);\n  digitalWrite(LED3, LOW);\n  Serial.begin(115200);\n}\n\n// the loop function runs over and over again forever\nvoid loop() {\n\n  int valueLDR = analogRead(pinADC);  //leemos el pin del ADC\n  Serial.print(\"Valor del ADC: \");\n\n  Serial.println(valueLDR);\n\n  if (valueLDR &lt; LIMIT) {\n    digitalWrite(LED1, HIGH);\n    Serial.println(\"Enciende rojo\");\n    delay(2000);\n    digitalWrite(LED1, LOW);\n    digitalWrite(LED3, HIGH);\n    Serial.println(\"Apaga rojo\");\n    Serial.println(\"Enciende Verde\");\n    delay(900);\n    digitalWrite(LED3, LOW);\n    delay(300);\n    digitalWrite(LED3, HIGH);\n    delay(300);\n    digitalWrite(LED3, LOW);\n    delay(500);\n    digitalWrite(LED3, HIGH);\n    delay(300);\n    digitalWrite(LED3, LOW);\n    delay(500);\n    digitalWrite(LED3, HIGH);\n    delay(300);\n    digitalWrite(LED3, LOW);\n    digitalWrite(LED2, HIGH);\n    Serial.println(\"Apaga verde\");\n    Serial.println(\"Enciende amarillo\");\n    delay(900);\n    digitalWrite(LED2, LOW);\n    Serial.println(\"Apaga amarillo\");\n  } else {\n    Serial.println(\"Parpadeo amarillo\");\n    digitalWrite(LED2, HIGH);\n    delay(1000);\n    digitalWrite(LED2, LOW);\n    delay(1000);\n  }\n}\n</code></pre>"},{"location":"05_adc_pwm/#semaforo-con-sensor-de-luz-y-boton","title":"Sem\u00e1foro con Sensor de Luz y bot\u00f3n","text":"<p>Vamos a encender el LED cuando hay poco luz, de lo contrario se debe apagar. En el d\u00eda el peat\u00f3n puede cambiar el estado del sem\u00e1foro, pero si es de noche no puede cambiar.</p> <p>Material</p> Cantidad Descripci\u00f3n 1 Placa ESP32 3 LED 3 R330 1 Push button 1 R1k 1 R10k 1 LDR <p>Diagrama pict\u00f3rico</p> <p></p> <p>Simulaci\u00f3n</p> <p></p> <p>C\u00f3digo</p> <pre><code>#define LED1 32 //ROJO\n#define LED2 33 //AMARILLO\n#define LED3 25 //VERDE\n#define pinADC 34  //pin que sera le\u00eddo del ADC\n#define btn 27 //pin para el bot\u00f3n\n#define LIMIT 2000 // esta constante es para la comparaci\u00f3n del sensor de luz\n\n// the setup function runs once when you press reset or power the board\n\nvoid setup() {\n  pinMode(LED1, OUTPUT);\n  pinMode(LED2, OUTPUT);\n  pinMode(LED3, OUTPUT);\n  pinMode(btn, INPUT);\n  digitalWrite(LED1, LOW);\n  digitalWrite(LED2, LOW);\n  digitalWrite(LED3, LOW);\n  Serial.begin(115200);\n}\n\n// the loop function runs over and over again forever\nvoid loop() {\n\n  int valueLDR = analogRead(pinADC);  //leemos el pin del ADC\n  Serial.print(\"Valor del ADC: \");\n\n  Serial.println(valueLDR);\n\n  if (valueLDR &lt; LIMIT) {\n\n    if ( digitalRead(btn) == 1) {\n      digitalWrite(LED1, HIGH);\n      Serial.println(\"Enciende rojo\");\n      delay(2000);\n      digitalWrite(LED1, LOW);\n      digitalWrite(LED3, HIGH);\n      Serial.println(\"Apaga rojo\");\n      Serial.println(\"Enciende Verde\");\n      delay(900);\n      digitalWrite(LED3, LOW);\n      delay(300);\n      digitalWrite(LED3, HIGH);\n      delay(300);\n      digitalWrite(LED3, LOW);\n      delay(500);\n      digitalWrite(LED3, HIGH);\n      delay(300);\n      digitalWrite(LED3, LOW);\n      delay(500);\n      digitalWrite(LED3, HIGH);\n      delay(300);\n      digitalWrite(LED3, LOW);\n      digitalWrite(LED2, HIGH);\n      Serial.println(\"Apaga verde\");\n      Serial.println(\"Enciende amarillo\");\n      delay(900);\n      digitalWrite(LED2, LOW);\n      Serial.println(\"Apaga amarillo\");\n    } else {\n      digitalWrite(LED1, LOW);\n      digitalWrite(LED2, LOW);\n      digitalWrite(LED3, HIGH);\n      Serial.println(\"Verde parpadeando\");\n      delay(500);\n      digitalWrite(LED3, LOW);\n      delay(500);\n    }\n  } else {\n    Serial.println(\"Parpadeo amarillo\");\n    digitalWrite(LED2, HIGH);\n    delay(1000);\n    digitalWrite(LED2, LOW);\n    delay(1000);\n  }\n}\n</code></pre>"},{"location":"05_adc_pwm/#salida-analogica-pwm","title":"Salida Anal\u00f3gica (PWM)","text":"<p>Modulaci\u00f3n de Ancho de Pulso (<code>Pulse width modulation</code> (<code>PWM</code>)) es una manera artificial de generar una salida anal\u00f3gica en un pin digital. Existen dos par\u00e1metros asociados al PWM que son la frecuencia y el ciclo de trabajo (duty cycle). El ciclo de trabajo define que tan largo sera el estado del pin en alto de <code>un periodo</code>. El m\u00e1ximo ciclo de trabajo es cuando el pin esta todo el tiempo en alto (100%) y el m\u00ednimo todo el tiempo en bajo (0%).</p> <p>En el ESP8266 todos los pines (excepto el GPIO16 o el pin 0) soportan PWM en su salida. </p> <p>Limitaci\u00f3n del PWM</p> <p>La limitaci\u00f3n es que todos deben correr a la misma frecuencia de trabajo, la cual esta entre 1Hz y 1kHz</p> <p></p> <p></p>"},{"location":"05_adc_pwm/#configuracion-de-pwm-en-esp32","title":"Configuraci\u00f3n de PWM en ESP32","text":"<p>Caracter\u00edsticas del PWM en el ESP32</p> <ul> <li>16 Canales. <code>Canal 0 - 15</code> (excepto los pines GPIO36, GPIO39, GPIO34, y GPIO35)</li> <li>Resoluci\u00f3n de 1 - 16 bits. </li> <li>3 Funciones para control y configuraci\u00f3n</li> </ul> <p></p> <p>Las funciones para el PWM</p> <ul> <li><code>ledcSetup</code>: Para configuraci\u00f3n de inicio del PWM</li> <li><code>ledcAttachPin</code>: Asigna la configuraci\u00f3n al pin indicado</li> <li><code>ledcWrite</code>: Escribe el valor que saldr\u00e1 por el pin.</li> </ul> <p>Detalles de la funciones</p> <ul> <li><code>ledcSetup(canal_PWM, frecuencia, resolucion)</code>: Es la primera funcion que se debe llamar y solo una vez para configurar el comportamiento del PWM</li> <li><code>canal_PWM</code>: Es un valor del 0 al 15, donde se selecciona el canal que usaremos del uC</li> <li><code>frecuencia</code>: Es la frecuencia de trabajo del PWM. Vamos a manejar por default 1000 (1kHz)</li> <li><code>resolucion</code>: Tenemos desde 1 a 16 bits de resoluci\u00f3n, en la mayoria de aplicaciones con 8 bits es suficiente o hasta 10 bits. Recordemos que para saber cual sera el valor minimo debemos de aplicar \\(3.3V/resolucion_{bits}\\). Con 8 bits ser\u00eda \\(3.3/256=0.012V\\)</li> <li><code>ledcAttachPin(pin, canal_PWM)</code>:</li> <li><code>pin</code>: Es el numero del pin que vamos a usar como salida PWM (ver el esquema de los pines que podemos usar)</li> <li><code>canal_PWM</code>: El canal que colocamos en la funci\u00f3n anterior</li> <li><code>ledcWrite(canal_PWM, valorPWM)</code>: La funci\u00f3n que se encarga de poner el valor en el pin indicado con un cierto ciclo de trabajo.</li> <li><code>canal_PWM</code>: El canal que estamos usando para el PWM</li> <li><code>valorPWM</code>: El valor que queremos asignar. Recordar que el valor esta en funci\u00f3n de la resoluci\u00f3n. Por ejemplo, si estamos usando 8 bits, los valores van desde 0 a 255.</li> </ul> <p>Ver mas detalles en la documentaci\u00f3n oficial</p>"},{"location":"05_adc_pwm/#control-led-rgb","title":"Control LED RGB","text":"<p>Haremos un simple cambio de color, incrementando el brillo de cada uno.</p> <p>Warning</p> <p>Se esta utilizando en LED RGB de c\u00e1todo com\u00fan, si usas uno de \u00c1nodo com\u00fan, haz tu ajuste en el c\u00f3digo y las conexiones</p> <p>Diagrama pict\u00f3rico</p> <p></p> Animaci\u00f3n <p></p> <p></p> C\u00f3digo <pre><code>#define LED_R 25  // PIN LED ROJO\n#define LED_G 26  // PIN LED VERDE\n#define LED_B 27  // PIN LED AZUL\n\n#define FREQ        1000  // frecuencia de trabajo para el PWM a 1KHz\n#define ledChannel0 0     //defino el canal 0, que usaremos para el color Rojo\n#define ledChannel1 1     //defino el canal 1, que usaremos para el color Verde\n#define ledChannel2 2     //defino el canal 2, que usaremos para el color Azul\n#define resolution  8     // 8-bit de resoluci\u00f3n (para Leds es ideal)\n\nvoid setup() {\n  // configuro el comportamiento del canal\n  ledcSetup(ledChannel0, FREQ, resolution);\n  ledcSetup(ledChannel1, FREQ, resolution);\n  ledcSetup(ledChannel2, FREQ, resolution);\n\n  //se asigna el Pin al canal configurado previamente\n  ledcAttachPin(LED_R, ledChannel0);\n  ledcAttachPin(LED_G, ledChannel1);\n  ledcAttachPin(LED_B, ledChannel2);\n}\n\nvoid loop() {\n  //se apagan todos los Leds\n  ledcWrite(ledChannel0, 0);\n  ledcWrite(ledChannel1, 0);\n  ledcWrite(ledChannel2, 0);\n  delay(15);\n\n  // Incrementa el brillo del rojo\n  for (int dutyCycle = 0; dutyCycle &lt;= 255; dutyCycle++) {\n    ledcWrite(ledChannel0, dutyCycle);\n    delay(15);\n  }\n  // Incrementa el brillo del verde\n  for (int dutyCycle = 0; dutyCycle &lt;= 255; dutyCycle++) {\n    ledcWrite(ledChannel1, dutyCycle);\n    delay(15);\n  }\n  // Incrementa el brillo del azul\n  for (int dutyCycle = 0; dutyCycle &lt;= 255; dutyCycle++) {\n    ledcWrite(ledChannel2, dutyCycle);\n    delay(15);\n  }\n}\n</code></pre>"},{"location":"05_adc_pwm/#control-de-intensidad-de-un-led-botones","title":"Control de Intensidad de un LED botones","text":"<p>Haremos un simple cambio de color con botones, incrementando el brillo de cada uno cuando se presione un bot\u00f3n, para su respectivo color.</p> <p>Warning</p> <p>Se esta utilizando en LED RGB de c\u00e1todo com\u00fan, si usas uno de \u00c1nodo com\u00fan, haz tu ajuste en el c\u00f3digo y las conexiones</p> <p>Diagrama pict\u00f3rico</p> <p></p> Animaci\u00f3n <p></p> C\u00f3digo <pre><code>#define LED_R 25  // PIN LED ROJO\n#define LED_G 26  // PIN LED VERDE\n#define LED_B 27  // PIN LED AZUL\n\n#define BTN_R 34  // PIN LED ROJO\n#define BTN_G 35  // PIN LED VERDE\n#define BTN_B 32  // PIN LED AZUL\n\n#define FREQ        1000  // frecuencia de trabajo para el PWM a 1KHz\n#define ledChannel0 0     //defino el canal 0, que usaremos para el color Rojo\n#define ledChannel1 1     //defino el canal 1, que usaremos para el color Verde\n#define ledChannel2 2     //defino el canal 2, que usaremos para el color Azul\n#define resolution  8     // 8-bit resolution\n\nvoid setup() {\n  pinMode(BTN_R, INPUT);\n  pinMode(BTN_G, INPUT);\n  pinMode(BTN_B, INPUT);\n  // configuro el comportamiento del canal\n  ledcSetup(ledChannel0, FREQ, resolution);\n  ledcSetup(ledChannel1, FREQ, resolution);\n  ledcSetup(ledChannel2, FREQ, resolution);\n\n  //se asigna el Pin al canal configurado previamente\n  ledcAttachPin(LED_R, ledChannel0);\n  ledcAttachPin(LED_G, ledChannel1);\n  ledcAttachPin(LED_B, ledChannel2);\n  //se apagan todos los Leds\n  ledcWrite(ledChannel0, 0);\n  ledcWrite(ledChannel1, 0);\n  ledcWrite(ledChannel2, 0);\n  Serial.begin(115200);\n}\n\nunsigned char red = 0;\nunsigned char blue = 0;\nunsigned char green = 0;\nunsigned char inc = 5;\n\nvoid loop() {\n  // Incrementa el brillo del rojo\n  if (digitalRead(BTN_R) == 1) {\n    if (red &gt; 254) {\n      red = 0;\n    } else {\n      red += inc;\n    }\n    ledcWrite(ledChannel0, red);\n    Serial.print(\"Rojo: \");\n    Serial.println(red);\n    delay(200);\n  }\n\n  if (digitalRead(BTN_G) == 1) {\n    if (green &gt; 254) {\n      green = 0;\n    } else {\n      green += inc;\n    }\n    ledcWrite(ledChannel1, green);\n    Serial.print(\"Verde: \");\n    Serial.println(green);\n\n    delay(200);\n  }\n\n\n  if (digitalRead(BTN_B) == 1) {\n    if (blue &gt; 254) {\n      blue = 0;\n    } else {\n      blue += inc;\n    }\n    ledcWrite(ledChannel2, blue);\n    Serial.print(\"Azul: \");\n    Serial.println(blue);\n    delay(200);\n  }\n\n}\n</code></pre>"},{"location":"05_adc_pwm/#control-de-intensidad-de-un-led-con-potenciometro","title":"Control de intensidad de un LED con potenci\u00f3metro","text":"<p>Haremos un simple cambio de color con botones, incrementando el brillo de cada uno cuando moviendo el v\u00e1stago de un potenci\u00f3metro, cada uno har\u00e1 el cambio de su respectivo color.</p> <p>Warning</p> <p>Se esta utilizando en LED RGB de c\u00e1todo com\u00fan, si usas uno de \u00c1nodo com\u00fan, haz tu ajuste en el c\u00f3digo y las conexiones</p> <p>Diagrama pict\u00f3rico</p> <p></p> Animaci\u00f3n <p></p> C\u00f3digo <pre><code>#define LED_R 25  // PIN LED ROJO\n#define LED_G 26  // PIN LED VERDE\n#define LED_B 27  // PIN LED AZUL\n\n#define POT_R 34  // PIN LED ROJO\n#define POT_G 35  // PIN LED VERDE\n#define POT_B 32  // PIN LED AZUL\n\n#define FREQ        1000  // frecuencia de trabajo para el PWM a 1KHz\n#define ledChannel0 0     //defino el canal 0, que usaremos para el color Rojo\n#define ledChannel1 1     //defino el canal 1, que usaremos para el color Verde\n#define ledChannel2 2     //defino el canal 2, que usaremos para el color Azul\n#define resolution  8     // 8-bit resolution\n\nvoid setup() {\n  // configuro el comportamiento del canal\n  ledcSetup(ledChannel0, FREQ, resolution);\n  ledcSetup(ledChannel1, FREQ, resolution);\n  ledcSetup(ledChannel2, FREQ, resolution);\n\n  //se asigna el Pin al canal configurado previamente\n  ledcAttachPin(LED_R, ledChannel0);\n  ledcAttachPin(LED_G, ledChannel1);\n  ledcAttachPin(LED_B, ledChannel2);\n  //se apagan todos los Leds\n  ledcWrite(ledChannel0, 0);\n  ledcWrite(ledChannel1, 0);\n  ledcWrite(ledChannel2, 0);\n  Serial.begin(115200);\n}\n\n\nvoid loop() {\n  int red = analogRead(POT_R);\n  int blue = analogRead(POT_B);\n  int green = analogRead(POT_G);\n\n  red = map(red, 0, 4095, 0, 255); //se esta convirtiendo el valor del ADC de 0 a 4095 a un valor de 8 bits, es decir, de 0 a 255\n  blue = map(blue, 0, 4095, 0, 255); //se esta convirtiendo el valor del ADC de 0 a 4095 a un valor de 8 bits, es decir, de 0 a 255\n  green = map(green, 0, 4095, 0, 255); //se esta convirtiendo el valor del ADC de 0 a 4095 a un valor de 8 bits, es decir, de 0 a 255\n\n  // Incrementa el brillo del rojo\n  ledcWrite(ledChannel0, red);\n  Serial.print(\"Rojo: \");\n  Serial.println(red);\n\n  ledcWrite(ledChannel1, green);\n  Serial.print(\"Verde: \");\n  Serial.println(green);\n\n  ledcWrite(ledChannel2, blue);\n  Serial.print(\"Azul: \");\n  Serial.println(blue);\n\n  delay(15);\n}\n</code></pre>"},{"location":"05_adc_pwm/#servomotor","title":"Servomotor","text":"<p>El servomotor que utilizaremos el SG-90, es un servomotor b\u00e1sico.</p> <p></p> <p>Este motor necesita la siguiente se\u00f1al para poder generar su desplazamiento:</p> <p></p> <p>Atenci\u00f3n</p> <p>Un servomotor solo se puede desplazar desde 0\u00b0 hasta 180\u00b0. Por default siempre esta en 90\u00b0. Pero, com\u00fanmente se considera 0\u00b0, dado que gira hasta 90\u00b0 y -90\u00b0.</p> <p>Fuente adicional de 5V</p> <p>Para hacer funcionar el servomotor se debe implementar una fuente adicional de 5V, ya que la propia placa NodeMCU no puede dar la suficiente corriente al motor y su sistema para funcionar adecuadamente.</p> <p>Note</p> <p>El dato m\u00ednimo que equivale a 0 grados es 25 en el valor de PWM, y para los 180 grados o m\u00e1ximo es de 127. Estos valores los obtuve haciendo experimentos y pruebas con estos elementos.</p> Angulo PWM 0 grados 25 90 grados 76 180 grados 127 <p>Note</p> <p>Descargar librer\u00eda. Dar click aqu\u00ed. Ver la instalaci\u00f3n manual -&gt; aqu\u00ed</p> <p>Note</p> <p>. </p>"},{"location":"05_adc_pwm/#servomotor-basico","title":"Servomotor b\u00e1sico","text":"<p>Se realiza un movimiento de ida y vuelta en el servomotor, de manera autom\u00e1tica.</p> <p>Warning</p> <p>Se necesita un fuente externa de 5V para el correcto funcionamiento del servomotor.</p> <p>Animaci\u00f3n</p> <p></p> <p>Diagrama pict\u00f3rico</p> <p></p> <p>C\u00f3digo</p> <pre><code>#include &lt;ESP32Servo.h&gt;\n\n#define pos 0    // variable que guarda la posici\u00f3n del servo\n\n#define SERVO_PIN 25\n\n// Los GPIO recomendados para colocar el Servo en ESP32 2,4,12-19,21-23,25-27,32-33\nServo myservo;  // Crea el objeto para el control del servomotor\n// Puede controlar hasta 16 servos\n\nvoid setup() {\n  // permite el uso de todos los timer, siempre deja esta secci\u00f3n, y no preguntes por qu\u00e9\n  ESP32PWM::allocateTimer(0);\n  ESP32PWM::allocateTimer(1);\n  ESP32PWM::allocateTimer(2);\n  ESP32PWM::allocateTimer(3);\n  myservo.setPeriodHertz(50);    // est\u00e1ndar de trabajo del servo es a 50 hz\n  myservo.attach(SERVO_PIN, 500, 2400); // configuramos el objeto del servo\n  // por default se usa min/max de 1000us and 2000us\n  // Si usas otro servo se deben ajustar los tiempos para el giro de 180 grados\n}\n\nvoid loop() {\n\n  for (pos = 0; pos &lt;= 180; pos += 1) { // va desde 0 a 180 grados\n    // in steps of 1 degree\n    myservo.write(pos);    // le indica al servo en donde colocarse\n    delay(15);             // espera 15ms para la siguiente posici\u00f3n\n  }\n  for (pos = 180; pos &gt;= 0; pos -= 1) { // va desde 180 a 0 grados\n    myservo.write(pos);    // le indica al servo en donde colocarse\n    delay(15);             // espera 15ms para la siguiente posici\u00f3n\n  }\n}\n</code></pre>"},{"location":"05_adc_pwm/#control-de-giro-de-servomotor-con-potenciometro","title":"Control de giro de Servomotor con potenci\u00f3metro","text":"<p>Se va a realizar un control de la posici\u00f3n del servo en funci\u00f3n de la posici\u00f3n de un potenci\u00f3metro</p> <p>Warning</p> <p>Se necesita un fuente externa de 5V para el correcto funcionamiento del servomotor.</p> <p>Diagrama pict\u00f3rico</p> <p></p> <p>Animaci\u00f3n</p> <p></p> <p>C\u00f3digo</p> <pre><code>#include &lt;ESP32Servo.h&gt;\n\nServo myservo;  // Crea el objeto para el control del servomotor\n\n#define SERVO 25 // pin donde colocamos el servo\n#define POT  34\n\nvoid setup() {\n  // permite el uso de todos los timer, siempre deja esta secci\u00f3n, y no preguntes por qu\u00e9\n  ESP32PWM::allocateTimer(0);\n  ESP32PWM::allocateTimer(1);\n  ESP32PWM::allocateTimer(2);\n  ESP32PWM::allocateTimer(3);\n  myservo.setPeriodHertz(50);// est\u00e1ndar de trabajo del servo es a 50 hz\n  myservo.attach(SERVO, 500, 2400);   // usando el SG90 servo min/max de 500us y 2400us\n  // para MG995 servo, usa 1000us y 2000us\n}\n\nvoid loop() {\n\n  int val = analogRead(POT);            // Lee el valor del potenci\u00f3metro\n  val = map(val, 0, 4096, 0, 180);     // Convierte el valor de ADC a grados\n  myservo.write(val);                  // ajusta los grados que colocara el servo\n  delay(200);                          //espera 200mS para hacer el cambio\n}\n</code></pre>"},{"location":"05_adc_pwm/#control-de-velocidad-de-motor-dc","title":"Control de velocidad de Motor DC","text":"<p>Vamos a realizar un control de velocidad con un motor DC, utilizando un potenci\u00f3metro para definir la velocidad y mostrando la velocidad en una pantalla LCD</p> <p>Diagrama pict\u00f3rico</p> <p>Animaci\u00f3n</p> <p>C\u00f3digo</p>"},{"location":"06_analog_ex/","title":"Ejercicios con I/O Anal\u00f3gicas","text":""},{"location":"06_analog_ex/#lamparas-del-parque","title":"L\u00e1mparas del parque","text":"<p>Realizar el siguiente ejercicio, ver la animaci\u00f3n</p> <p></p> <p></p> <p>Funcionamiento</p> <ol> <li>Cuando exista poca luz en el sensor (esto definido por el programador), se deben encender todas las lamparas (los LEDs), de forma secuencial e ir quedando encendidas hasta que est\u00e9n todas prendidas.</li> <li>Si hay una luz intermedia, solo deben estar encendidas 2 lamparas.</li> <li>Si hay suficiente luz en el ambiente, deben continuar apagadas.</li> <li>Al momento en apagarse, se ir\u00e1n apagando una a una, hasta que al final queden apagadas.</li> </ol>"},{"location":"07_teoria_sensores/","title":"Sensores - Introducci\u00f3n","text":"<p>Un sensor en es un sistema el cual capta una variable f\u00edsica y reacciona para la activaci\u00f3n de un actuador. Las partes generales de un sensor son:</p> <ul> <li>Transductor</li> <li>Acoplamiento de se\u00f1al del transductor</li> <li>Salida (Pasa la se\u00f1al o acciona un actuador)</li> </ul> <p></p> <p>Un sensor es todo aquello que tiene una propiedad sensible a una magnitud del medio, y al variar esta magnitud tambi\u00e9n var\u00eda con cierta intensidad la propiedad, es decir, manifiesta la presencia de dicha magnitud, y tambi\u00e9n su medida...wikipedia</p>"},{"location":"07_teoria_sensores/#variable-fisica","title":"Variable f\u00edsica","text":"<p>Existen 6 variables fundamentales que podemos captar que son:</p> <ul> <li>Temperatura (Calor, frio)</li> <li>Caudal (Flujo)</li> <li>Presi\u00f3n (Masa)</li> <li>Radiaci\u00f3n (Luz,...)</li> <li>Velocidad (velocidad, aceleraci\u00f3n)</li> <li>Nivel</li> </ul> <p>Existen muchas m\u00e1s, pero solo hago menci\u00f3n de las mas b\u00e1sicas en instrumentaci\u00f3n.</p>"},{"location":"07_teoria_sensores/#transductor","title":"Transductor","text":"<p>Un transductor es un elemento que es capaz de captar una variable f\u00edsica (temperatura, presi\u00f3n, flujo, etc..) convirti\u00e9ndola en una se\u00f1al el\u00e9ctrica (corriente o voltaje). Sin embargo, normalmente la se\u00f1al generada es muy peque\u00f1a, por ende, se debe mandar a una etapa de amplificaci\u00f3n. La se\u00f1al el\u00e9ctrica o su variaci\u00f3n siempre se da por alg\u00fan efecto qu\u00edmico en su interior por su constituci\u00f3n f\u00edsica.</p> <p>Ejemplos:</p> <ul> <li>LDR (Resistencia dependiente de luz): En funci\u00f3n de la luz que incide por su ventana es el valor ohmico que representa al pasar la corriente</li> </ul> <p></p> <ul> <li>Termocupla o termopar: Es la union de dos conductores de diferente composici\u00f3n qu\u00edmica.</li> </ul> <p></p> <ul> <li>Pizoelectrico: Es una lamina o material que al deformarse genera un nivel de voltaje.</li> </ul> <p></p>"},{"location":"07_teoria_sensores/#transductor-pasivo-vs-activo","title":"Transductor Pasivo vs Activo","text":"<p>Existen dos tipos de transductores los cuales pueden ser pasivos o activos esto significa la forma en c\u00f3mo vamos a leer su se\u00f1al o adquirirla, en funci\u00f3n de ello vamos a acoplar, qu\u00e9 tipo es y amplificaci\u00f3n.</p>"},{"location":"07_teoria_sensores/#pasivos","title":"Pasivos","text":"<p>Los <code>transductores pasivos</code> son aquellos los cuales para poder leer o conocer la variable f\u00edsica, se le debe aplicar un voltaje o corriente constante, para que en funci\u00f3n de la variaci\u00f3n de este voltaje o corriente que aplicamos podamos calcular su equivalencia o proporci\u00f3n a dicha variable. Es decir, este tipo de transductor no es capaz de generar un voltaje o corriente la cual nos indique el valor de la magnitud f\u00edsica.</p> <p>El ejemplo m\u00e1s com\u00fan es una LDR, la cual se debe aplicar en un divisor de tensi\u00f3n, y en funci\u00f3n de la variaci\u00f3n del luz har\u00e1 variar el voltaje de la salida del voltaje.</p> <p></p> <p>Como se puede observar en el circuito tenemos un divisor de tension din\u00e1mico que oscila el voltaje en funci\u00f3n de la entrada de luz, esta salida normalmente va a otra etapa de amplificaci\u00f3n.</p>"},{"location":"07_teoria_sensores/#activos","title":"Activos","text":"<p>Los <code>transductores activos</code> generan energ\u00eda de forma natural, generando un voltaje o corriente al ser expuesto al contexto. Sin embargo, esta se\u00f1al es demasiado peque\u00f1a para poder ser le\u00eddo o un elemento digital o cualquier otro elemento.</p> <p>El ejemplo m\u00e1s com\u00fan es un termopar o termocupla, la cual esta constituida por 2 alambres de diferentes elementos qu\u00edmicos. Al se expuesto a altas temperatura genera un mili voltaje.</p> <p></p> <p>Como podemos observar al unir dos alambres de elementos distintos, al calentarse estos generan una diferencia de potencial.</p> <p>Aqu\u00ed tenemos un circuito de ejemplo de acoplamiento de una termocupla con su etapa de amplificaci\u00f3n.</p> <p></p>"},{"location":"07_teoria_sensores/#sensores-digitales-vs-analogicos","title":"Sensores Digitales vs Anal\u00f3gicos","text":"<p>En general todos los transductores son anal\u00f3gicos, pero generan una se\u00f1al muy peque\u00f1a, se necesita acoplar una o dos etapas de amplificaci\u00f3n para tener un voltaje mayor equivalente. Pero justamente aqu\u00ed al final de esa etapa la se\u00f1al se puede enfocar para generar solo <code>se\u00f1ales digitales</code>, es decir, <code>un nivel alto o bajo</code>, o en su defecto generar un <code>rango de voltaje</code>, estos ser\u00edan los <code>anal\u00f3gicos</code></p>"},{"location":"07_teoria_sensores/#sensores-digitales","title":"Sensores Digitales","text":"<p>Los sensores digitales solo pueden generar 2 tipos de se\u00f1al, sea un <code>1</code> o un <code>0</code>. Existen rangos de voltajes que si est\u00e1n en un rango se consideran <code>1 l\u00f3gico</code> o <code>0 l\u00f3gico</code>. A un rango se le conoce como voltajes TTL.</p> Nivel l\u00f3gico Voltaje 1 3V a 5V 0 0V a 0.8V <p>Debemos conocer que tipo de sistema digital estamos empleando y verificar nuestro sensor para asegurar que se puede acoplar directamente o tendremos que acoplar esta se\u00f1al al nivel que deseamos.</p> <p></p>"},{"location":"07_teoria_sensores/#sensores-digitales-basicos-vs-protocolos","title":"Sensores digitales b\u00e1sicos vs protocolos","text":"<p>Los sensores digitales b\u00e1sicos solo nos da una se\u00f1al l\u00f3gica, esto significa que tiene 2 estados, indicando si existe o no existe la variable o la magnitud f\u00edsica, si m\u00e1s.</p> <p>Sensores b\u00e1sicos </p> <p>Ejemplo:</p> <ul> <li>Sensor PIR: Indica si existe presencia o no.</li> </ul> <p></p> <ul> <li>Sensor de Flama: Indica si existe flama o no. Este por su naturaleza da un rango de voltaje, entonces se debe calibrar en que punto se dispara indicando si sobrepasa este punto o no.</li> </ul> <p></p> <ul> <li>Sensor de luz: Indica si existe luz o no. Este por su naturaleza da un rango de voltaje, entonces se debe calibrar en que punto se dispara indicando si sobrepasa este punto o no.</li> </ul> <p></p>"},{"location":"07_teoria_sensores/#los-sensores-digitales-con-comunicacion-por-protocolo","title":"Los sensores digitales con comunicaci\u00f3n por protocolo","text":"<p>Son sensores que internamente son mas complejos, estos ademas de contener su etapa del transductor, amplificaci\u00f3n, acoplamiento, tienen un etapa de comunicaci\u00f3n por medio de alg\u00fan protocolo de comunicaci\u00f3n:</p> <p>Sensores con protocolo de comunicaci\u00f3n:</p> <ul> <li>DS18B20: Sensor de temperatura con protocolo 1 Wire</li> </ul> <p></p> <ul> <li>BME280:: Sensor de presi\u00f3n, humedad y temperatura con protocolo I2C.</li> </ul> <p></p> <ul> <li>MAX31855K: Sensor de temperatura con protocolo SPI</li> </ul> <p></p>"},{"location":"07_teoria_sensores/#sensores-analogicos","title":"Sensores Anal\u00f3gicos","text":"<p>Los sensores anal\u00f3gicos nos proveen un rango de voltaje en el que operan, este voltaje es proporcional la variable o magnitud f\u00edsica que esta censando. Los sensores que son empleados a sistemas digitales trabajan habitualmente en un rango de <code>0V a 5V</code> o <code>0V a 3.3V</code>, estos rangos son comunes pero no los \u00fanicos. En ocasiones tenemos que amplificar este rango para que se pueda aprovechar de mejor manera.</p> <p></p> <p>Pero este rango de voltaje no se puede mandar directamente al sistema digital antes debe pasar por otro elemento que haga la conversion a un sistema digital, estos elementos se llaman ADC, este elemento hace posible que el microcontrolador pueda entender la se\u00f1al anal\u00f3gica.</p> <p></p>"},{"location":"07_teoria_sensores/#actuadores-electricos-o-electronicos","title":"Actuadores el\u00e9ctricos o electr\u00f3nicos","text":"<p>El actuador es el elemento que act\u00faa o realiza una acci\u00f3n a la salida de un sensor, no siempre viene el actuador incorporado al sensor.</p> <p>Los actuadores m\u00e1s comunes son:</p> <ul> <li>Relay</li> <li>Solenoide</li> <li>Bocina</li> <li>LED</li> <li>Buzzer</li> </ul> <p>Aqu\u00ed se pueden ver varios circuitos de sensores:</p> <p>Sensor crepuscular</p> <p></p> <p>Sensor de temperatura</p> <p></p>"},{"location":"07_teoria_sensores/#lista-de-sensores-comunes","title":"Lista de sensores comunes","text":"<p>Realizado por Docente: Alejandro Leyva</p> <p>Mecatr\u00f3nica 85</p> <p>fb/mecatronica85</p>"},{"location":"08_sensores/","title":"Sensores - Aplicaci\u00f3n","text":""},{"location":"08_sensores/#sensores-digitales","title":"Sensores digitales","text":"<p>Usaremos diversos sensores para controlar distintos elementos.</p>"},{"location":"08_sensores/#teclado-matricial-4x4","title":"Teclado matricial 4x4","text":"<p>Note</p> <p>En ocasiones NO se encuentra la librer\u00eda en el IDE, puedes instalarla desde el \"Gestor de bibliotecas\"</p> <p></p> <p>Note</p> <p>De otra forma, puedes descarga la librer\u00eda y realizar la instalaci\u00f3n manual. Dar click aqu\u00ed</p> <p>Aqu\u00ed vamos a probar el correcto conexionado y funcionamiento del teclado, imprimiendo por monitor serial la tecla presionada.</p> <p>Diagrama pict\u00f3rico</p> <p></p> <p>C\u00f3digo</p> <pre><code>#include &lt;Keypad.h&gt; // importamos la librer\u00eda para utilizar el teclado\n\n#define ROW_NUM     4 // indicamos el numero de renglones del teclado\n#define COLUMN_NUM  4 // indicamos el numero de columnas del teclado\n\nchar keys[ROW_NUM][COLUMN_NUM] = { // indicamos las letras que tiene el teclado, estas se pueden cambiar\n  {'1', '2', '3', 'A'},\n  {'4', '5', '6', 'B'},\n  {'7', '8', '9', 'C'},\n  {'*', '0', '#', 'D'}\n};\n\nbyte pin_rows[ROW_NUM]      = {19, 18, 5, 17}; // indicamos los pines que se usaran para los renglones\nbyte pin_column[COLUMN_NUM] = {16, 4, 0, 2};   // indicamos los pines que se usaran para las columnas\n\nKeypad keypad = Keypad( makeKeymap(keys), pin_rows, pin_column, ROW_NUM, COLUMN_NUM ); // se crea y configura el objeto para el uso del teclado\n\nvoid setup() {\n  Serial.begin(115200);\n}\n\nvoid loop() {\n  char key = keypad.getKey(); // esperemos la tecla que se presiono\n\n  if (key) { // si presionaron una tecla, entra al bloque del if\n    Serial.println(key); // se imprime la tecla que fue presionada\n  }\n}\n</code></pre>"},{"location":"08_sensores/#cerradura-basica","title":"Cerradura b\u00e1sica","text":"<p>Haremos una cerradura b\u00e1sica, en la cual si se colocar la contrase\u00f1a correcta se encender\u00e1 un led 3 veces cada medio segundo, esto indica que la contrase\u00f1a fue correctamente colocada. En caso que la contrase\u00f1a se incorrecta, parpadeara el led, indicando que la contrase\u00f1a fue incorrecta. Tendremos todo el feedback en el monitor serial.</p> <p>Diagrama pict\u00f3rico</p> <p></p> <p>C\u00f3digo</p> <pre><code>#include &lt;Keypad.h&gt; // importamos la librer\u00eda para utilizar el teclado\n\n#define ROW_NUM     4 // indicamos el numero de renglones del teclado\n#define COLUMN_NUM  4 // indicamos el numero de columnas del teclado\n\nchar keys[ROW_NUM][COLUMN_NUM] = { // indicamos las letras que tiene el teclado, estas se pueden cambiar\n  {'1', '2', '3', 'A'},\n  {'4', '5', '6', 'B'},\n  {'7', '8', '9', 'C'},\n  {'*', '0', '#', 'D'}\n};\n\nbyte pin_rows[ROW_NUM]      = {19, 18, 5, 17}; // indicamos los pines que se usaran para los renglones\nbyte pin_column[COLUMN_NUM] = {16, 4, 0, 2};   // indicamos los pines que se usaran para las columnas\n\nKeypad keypad = Keypad( makeKeymap(keys), pin_rows, pin_column, ROW_NUM, COLUMN_NUM );  // se crea y configura el objeto para el uso del teclado\n\n\nconst String password = \"7890\"; // Aqu\u00ed el password super secreto\nString input_password;\n\n#define LED 25\n\nvoid setup() {\n  Serial.begin(115200);\n  pinMode(LED, OUTPUT);\n  Serial.println(\"------------------------\");\n  Serial.println(\"El password es de 4 digitos\");\n  Serial.println(\"Presionar # para aceptar el password\");\n  Serial.println(\"Presionar * para cancelar y volver a escribir el password\");\n  Serial.println(\"------------------------\");\n  Serial.println(\"Introducir el password\");\n  Serial.println(\"------------------------\");\n}\n\nvoid loop() {\n  char key = keypad.getKey(); // esperemos la tecla que se presiono\n\n  if (key) {\n    Serial.print(key);\n\n    if (key == '*') {\n      input_password = \"\"; // clear input password\n      Serial.println(\"cancelado\");\n      Serial.println(\"\");\n    } else if (key == '#') {\n      Serial.println(\"\");\n      if (password == input_password) {\n        Serial.println(\"The password CORRECTO!!\");\n        digitalWrite(LED, HIGH);\n        delay(500);\n        digitalWrite(LED, LOW);\n        delay(500);\n        digitalWrite(LED, HIGH);\n        delay(500);\n        digitalWrite(LED, LOW);\n        delay(500);\n        digitalWrite(LED, HIGH);\n        delay(500);\n        digitalWrite(LED, LOW);\n        delay(500);\n      } else {\n        Serial.println(\"The password INCORRECTO!\");\n        digitalWrite(LED, HIGH);\n        delay(250);\n        digitalWrite(LED, LOW);\n        delay(250);\n        digitalWrite(LED, HIGH);\n        delay(250);\n        digitalWrite(LED, LOW);\n        delay(250);\n        digitalWrite(LED, HIGH);\n        delay(250);\n        digitalWrite(LED, LOW);\n        delay(250);\n      }\n      Serial.println(\"------------------------\");\n      Serial.println(\"El password es de 4 digitos\");\n      Serial.println(\"Presionar # para aceptar el password\");\n      Serial.println(\"Presionar * para cancelar y volver a escribir el password\");\n      Serial.println(\"------------------------\");\n      Serial.println(\"Introducir el password\");\n      Serial.println(\"------------------------\");\n      input_password = \"\"; // se limpia el contenido\n    } else {\n      input_password += key; // va juntando los caracteres\n    }\n  }\n}\n</code></pre>"},{"location":"08_sensores/#sensor-de-flama","title":"Sensor de flama","text":"<p>El sensor de flama va detectar cuando exista fuego, haciendo sonar una alarma y una lampara de emergencia (LED). Cuando ya no detecte peligro se apagar\u00e1.</p> <p>Diagrama pict\u00f3rico</p> <p></p> <p>C\u00f3digo</p> <pre><code>// defino los pines que se usaran para el sensor, buzzer y l\u00e1mpara\n#define BUZZER 25\n#define LAMP 26\n#define FLAME_SENSOR 34\n\nvoid setup() {\n  //configuro e inicio la comunicaci\u00f3n serial\n  Serial.begin(115200);\n\n  //configuro los pines como entradas y salidas\n  pinMode(BUZZER, OUTPUT);\n  pinMode(LAMP, OUTPUT);\n  pinMode(FLAME_SENSOR, INPUT);\n\n}\n\nvoid loop() {\n\n  // si detecta flama enciende la lampara y suena la alarma\n  if (digitalRead(FLAME_SENSOR) == 1 ) {\n    digitalWrite(LAMP, HIGH);\n    digitalWrite(BUZZER, HIGH);\n    delay(250);\n    digitalWrite(BUZZER, LOW);\n    delay(250);\n    digitalWrite(BUZZER, HIGH);\n    delay(250);\n    digitalWrite(BUZZER, LOW);\n    delay(250);\n    digitalWrite(BUZZER, HIGH);\n    delay(250);\n    digitalWrite(BUZZER, LOW);\n    delay(250);\n  } else { // de lo contrario esta apagado todo\n    digitalWrite(LAMP, LOW);\n    digitalWrite(BUZZER, LOW);\n    delay(1000); //espero 1 segundo para volver a detectar el sensor\n  }\n  delay(250);\n}\n</code></pre>"},{"location":"08_sensores/#sensor-pir-hc-sr501-sensor-de-presencia","title":"Sensor PIR HC-SR501 (Sensor de presencia)","text":"<p>C\u00f3digo</p> <pre><code>#define PIR 34 //defino el pin para el sensor PIR\n#define LED 25 //defino el pin para el LED\n\nvoid setup() {\n  Serial.begin(115200);\n  pinMode(PIR, INPUT);\n  pinMode(LED, OUTPUT);\n\n}\n\nvoid loop() {\n  if(digitalRead(PIR) == 1){\n    digitalWrite(LED, HIGH);\n    Serial.println(\"Hay presencia\");\n    delay(1000);\n  }else{\n    digitalWrite(LED, LOW);\n  }\n  delay(10);\n}\n</code></pre>"},{"location":"08_sensores/#sensor-de-temperatura-y-humedad-dth11","title":"Sensor de Temperatura y Humedad DTH11","text":"<p>Warning</p> <p>Se deben agregar una librer\u00edas para usar este sensor. Click aqu\u00ed, agregarlas a tu IDE, de lo contrario no funcionara el c\u00f3digo de ejemplo.</p> <p></p> <p></p> <p></p> <pre><code>#include &lt;Adafruit_Sensor.h&gt;\n#include &lt;DHT.h&gt;\n#include &lt;DHT_U.h&gt;\n\n#define DHTPIN 2     // El pin que se usara para comunicar al sensor con el micro\n\n#define DHTTYPE    DHT11   // se define que sensor se usara (tenemos el DHT22, FHT21)\n\nDHT_Unified dht(DHTPIN, DHTTYPE); // Se crea el objeto con los valores indicados para que se configure el sensor a usar\n\nuint32_t delayMS;\n\nvoid setup() {\n  Serial.begin(115200);\n  // Initialize device.\n  dht.begin(); //inicializamos al sensor\n  Serial.println(F(\"Sensor DHT11\"));\n  // Print temperature sensor details.\n  sensor_t sensor;\n  dht.temperature().getSensor(&amp;sensor);\n  Serial.println(F(\"------------------------------------\"));\n  Serial.println(F(\"Temperature Sensor\"));\n  Serial.print  (F(\"Sensor Tipo: \")); Serial.println(sensor.name);\n  Serial.print  (F(\"Driver Ver:  \")); Serial.println(sensor.version);\n  Serial.print  (F(\"ID:   \")); Serial.println(sensor.sensor_id);\n  Serial.print  (F(\"Valor Max:   \")); Serial.print(sensor.max_value); Serial.println(F(\"\u00b0C\"));\n  Serial.print  (F(\"Valor Min:   \")); Serial.print(sensor.min_value); Serial.println(F(\"\u00b0C\"));\n  Serial.print  (F(\"Resolution:  \")); Serial.print(sensor.resolution); Serial.println(F(\"\u00b0C\"));\n  Serial.println(F(\"------------------------------------\"));\n  // Print humidity sensor details.\n  dht.humidity().getSensor(&amp;sensor);\n  Serial.println(F(\"Humidity Sensor\"));\n  Serial.print  (F(\"Sensor Type: \")); Serial.println(sensor.name);\n  Serial.print  (F(\"Driver Ver:  \")); Serial.println(sensor.version);\n  Serial.print  (F(\"Unique ID:   \")); Serial.println(sensor.sensor_id);\n  Serial.print  (F(\"Max Value:   \")); Serial.print(sensor.max_value); Serial.println(F(\"%\"));\n  Serial.print  (F(\"Min Value:   \")); Serial.print(sensor.min_value); Serial.println(F(\"%\"));\n  Serial.print  (F(\"Resolution:  \")); Serial.print(sensor.resolution); Serial.println(F(\"%\"));\n  Serial.println(F(\"------------------------------------\"));\n  // Set delay between sensor readings based on sensor details.\n  delayMS = sensor.min_delay / 1000;\n}\n\nvoid loop() {\n  // Delay between measurements.\n  delay(delayMS);\n  // Get temperature event and print its value.\n  sensors_event_t event;\n  dht.temperature().getEvent(&amp;event);\n  if (isnan(event.temperature)) {\n    Serial.println(F(\"Error reading temperature!\"));\n  }\n  else {\n    Serial.print(F(\"Temperature: \"));\n    Serial.print(event.temperature);\n    Serial.println(F(\"\u00b0C\"));\n  }\n  // Get humidity event and print its value.\n  dht.humidity().getEvent(&amp;event);\n  if (isnan(event.relative_humidity)) {\n    Serial.println(F(\"Error reading humidity!\"));\n  }\n  else {\n    Serial.print(F(\"Humidity: \"));\n    Serial.print(event.relative_humidity);\n    Serial.println(F(\"%\"));\n  }\n}\n</code></pre>"},{"location":"08_sensores/#graficando-temperatura-y-humedad-dth11","title":"Graficando Temperatura y Humedad DTH11","text":"<p>Warning</p> <p>Se deben agregar una librer\u00edas para usar este sensor. Click aqu\u00ed, agregarlas a tu IDE, de lo contrario no funcionara el c\u00f3digo de ejemplo.</p> <p></p> <p></p> <p></p> <pre><code>#include &lt;Adafruit_Sensor.h&gt;\n#include &lt;DHT.h&gt;\n#include &lt;DHT_U.h&gt;\n\n#define DHTPIN 2     // El pin que se usara para comunicar al sensor con el micro\n\n#define DHTTYPE    DHT11   // se define que sensor se usara (tenemos el DHT22, FHT21)\n\nDHT_Unified dht(DHTPIN, DHTTYPE); // Se crea el objeto con los valores indicados para que se configure el sensor a usar\n\nvoid setup() {\n  //inicializa la comunicaci\u00f3n serial\n  Serial.begin(115200);\n  dht.begin(); //inicializamos al sensor\n  delay(500);\n  Serial.println();\n}\n\nvoid loop() {\n\n  sensors_event_t event;\n  dht.temperature().getEvent(&amp;event);\n  if (isnan(event.temperature)) {\n    Serial.println(F(\"Error reading temperature!\"));\n  }\n  else {\n    Serial.print(F(\"Temperature: \"));\n    Serial.print(event.temperature);\n    Serial.print(\",\");\n  }\n  // Get humidity event and print its value.\n  dht.humidity().getEvent(&amp;event);\n  if (isnan(event.relative_humidity)) {\n    Serial.println(F(\"Error reading humidity!\"));\n  }\n  else {\n    Serial.print(F(\"Humidity: \"));\n    Serial.print(event.relative_humidity);\n    Serial.println();\n  }\n  delay(1000);// esperamos un segundo para tomar otra lectura\n}\n</code></pre>"},{"location":"08_sensores/#sensor-ultrasonico-hc-sr04","title":"Sensor Ultras\u00f3nico HC-SR04","text":"<p>Note</p> <p>Agregar la librer\u00eda de manera manual. Dar click aqu\u00ed</p> <p>Note</p> <p>Abrir el \"Gestor de Librer\u00edas\" y buscar como se muestra.</p> <p></p>"},{"location":"08_sensores/#distancia-con-sensor-ultrasonico","title":"Distancia con sensor Ultras\u00f3nico","text":"<p>Diagrama pict\u00f3rico</p> <p></p> <p>Animaci\u00f3n</p> <p></p> <pre><code>#include &lt;NewPing.h&gt;\n\n#define TRIGGER_PIN  4  // Pin que se usara para el TRIGGER que recibe el sensor\n#define ECHO_PIN     2  // Pin que se usara el el ECHO que enviara el sensor\n#define MAX_DISTANCE 400 // Distancia maxima que puede medir el sensor\n\nNewPing ultrasonico(TRIGGER_PIN, ECHO_PIN, MAX_DISTANCE); // Se configura el objeto del sensor que usara los datos\n\nvoid setup() {\n  Serial.begin(115200);\n}\n\nfloat duracion, distancia;\n\nvoid loop() {\n\n  duracion = ultrasonico.ping();\n\n  distancia = (duracion / 2) * 0.0343;\n  Serial.print(\"Distancia: \");\n\n  if (distancia &gt;= 400 || distancia &lt;= 2) {\n    Serial.println(\"Fuera de rango\");\n  } else {\n    Serial.print(distancia);\n    Serial.println(\" cm\");\n    delay(500);\n  }\n\n  delay(500);\n}\n</code></pre>"},{"location":"08_sensores/#barra-de-leds-con-ultrasonico","title":"Barra de leds con Ultrasonico","text":"<p>Diagrama pict\u00f3rico</p> <p></p> <p>Animaci\u00f3n</p> <p></p> <pre><code>#include &lt;NewPing.h&gt;\n\n#define TRIGGER_PIN  4  // Pin que se usara para el TRIGGER que recibe el sensor\n#define ECHO_PIN     2  // Pin que se usara el el ECHO que enviara el sensor\n#define MAX_DISTANCE 400 // Distancia maxima que puede medir el sensor\n\nNewPing ultrasonico(TRIGGER_PIN, ECHO_PIN, MAX_DISTANCE); // Se configura el objeto del sensor que usara los datos\n\n#define NO_LEDS 7\nconst int PINS[] = {32, 33, 25, 26, 27, 12, 14}; //pines para leds\n\n\nvoid setup() {\n  Serial.begin(115200);\n  for (char x = 0; x &lt; NO_LEDS; x++) {\n    pinMode(PINS[x], OUTPUT);\n  }\n}\n\nvoid loop() {\n\n  float distancia = (ultrasonico.ping() / 2) * 0.0343;\n  Serial.print(\"Distancia: \");\n\n  if (distancia &gt;= 400 || distancia &lt;= 2) {\n    Serial.println(\"Fuera de rango\");\n\n    for (char x = 0; x &lt; NO_LEDS; x++) {\n      digitalWrite(PINS[x], HIGH);\n    }\n    delay(250);\n    for (char x = 0; x &lt; NO_LEDS; x++) {\n      digitalWrite(PINS[x], LOW);\n    }\n    delay(250);\n\n  } else {\n    Serial.print(distancia);\n    Serial.println(\" cm\");\n\n    if (distancia &lt; 50) {\n      const int LEVEL = 1;\n\n      for (char x = 0; x &lt; LEVEL; x++) {\n        digitalWrite(PINS[x], HIGH);\n      }\n      delay(100);\n      for (char x = LEVEL; x &lt; NO_LEDS; x++) {\n        digitalWrite(PINS[x], LOW);\n      }\n    } else if (distancia &gt;= 50 &amp;&amp; distancia &lt; 100) {\n      const int LEVEL = 2;\n\n      for (char x = 0; x &lt; LEVEL; x++) {\n        digitalWrite(PINS[x], HIGH);\n      }\n      delay(100);\n      for (char x = LEVEL; x &lt; NO_LEDS; x++) {\n        digitalWrite(PINS[x], LOW);\n      }\n    } else if (distancia &gt;= 100 &amp;&amp; distancia &lt; 150) {\n      const int LEVEL = 3;\n\n      for (char x = 0; x &lt; LEVEL; x++) {\n        digitalWrite(PINS[x], HIGH);\n      }\n      delay(100);\n      for (char x = LEVEL; x &lt; NO_LEDS; x++) {\n        digitalWrite(PINS[x], LOW);\n      }\n    } else if (distancia &gt;= 150 &amp;&amp; distancia &lt; 200) {\n      const int LEVEL = 4;\n\n      for (char x = 0; x &lt; LEVEL; x++) {\n        digitalWrite(PINS[x], HIGH);\n      }\n      delay(100);\n      for (char x = LEVEL; x &lt; NO_LEDS; x++) {\n        digitalWrite(PINS[x], LOW);\n      }\n    } else if (distancia &gt;= 200 &amp;&amp; distancia &lt; 250) {\n      const int LEVEL = 5;\n\n      for (char x = 0; x &lt; LEVEL; x++) {\n        digitalWrite(PINS[x], HIGH);\n      }\n      delay(100);\n      for (char x = LEVEL; x &lt; NO_LEDS; x++) {\n        digitalWrite(PINS[x], LOW);\n      }\n    } else if (distancia &gt;= 250 &amp;&amp; distancia &lt; 300) {\n      const int LEVEL = 6;\n\n      for (char x = 0; x &lt; LEVEL; x++) {\n        digitalWrite(PINS[x], HIGH);\n      }\n      delay(100);\n      for (char x = LEVEL; x &lt; NO_LEDS; x++) {\n        digitalWrite(PINS[x], LOW);\n      }\n    } else {\n      const int LEVEL = 7;\n\n      for (char x = 0; x &lt; LEVEL; x++) {\n        digitalWrite(PINS[x], HIGH);\n      }\n      delay(100);\n      for (char x = LEVEL; x &lt; NO_LEDS; x++) {\n        digitalWrite(PINS[x], LOW);\n      }\n    }\n    delay(500);\n  }\n\n  delay(10);\n}\n</code></pre>"},{"location":"08_sensores/#sensor-ds18b20-sensor-de-temperatura","title":"Sensor DS18B20 - Sensor de temperatura","text":"<p>Note</p> <p>Agregar la librer\u00eda de manera manual. Dar click aqu\u00ed</p> <p>Note</p> <p>Abrir el \"Gestor de Librer\u00edas\" y buscar como se muestra.</p> <p></p> <p></p> <p>Warning</p> <p>Se necesita agregarle una resistencia de pull-up al pin de se\u00f1al, de lo contrario funcionara mal. <code>La resistencia es de</code> \\(4.7k\\Omega\\)</p> Pines DS18B20 <p>Descripci\u00f3n del encapsulado. Hacer los ajustes necesarios</p> <p></p> <p>Vamos a realizar un lectura b\u00e1sica de la temperatura con el sensor de Dallas DS18B20 y mandar el valor al monitor serial</p> <p>Diagrama pict\u00f3rico</p> <p></p> <p>C\u00f3digo</p> <pre><code>// Se deben incluir estas librer\u00edas para el control del sensor\n#include &lt;OneWire.h&gt; // conexi\u00f3n de one wire para la comunicaci\u00f3n\n#include &lt;DallasTemperature.h&gt; // lib que se encarga de transformar el dato al valor de temperatura\n\n// definimos el pin que usaremos para la comunicaci\u00f3n con el sensor\n#define ONE_WIRE_BUS 25\n\n// se configura la instancia (el objeto) para la comunicaci\u00f3n con el protocolo one wire\nOneWire oneWire(ONE_WIRE_BUS);\n\n// se pasa la referencia a la lib de Dallas, que recibir\u00e1 los datos del sensor y hacer la conversi\u00f3n\nDallasTemperature sensors(&amp;oneWire);\n\nvoid setup(void) {\n  Serial.begin(115200); // Se configura la comunicaci\u00f3n serial\n\n  //se arranca y configura la comunicaci\u00f3n con el sensor de temperatura\n  sensors.begin();\n}\n\nvoid loop(void) {\n  Serial.print(\"Obteniendo temperatura...\");\n  sensors.requestTemperatures(); // se hace la solicitud de temperatura al sensor\n\n  // se obtiene la temperatura en grados Celsius del sensor que hay (se le pasa 0 porque solo tenemos un sensor)\n  float tempC = sensors.getTempCByIndex(0);\n\n  // se verifica si el valor es correcto\n  if (tempC != DEVICE_DISCONNECTED_C) {\n    Serial.print(\"La temperatura es: \");\n    Serial.println(tempC);\n  }\n  else  {\n    Serial.println(\"Error: No se pudo obtener el valor de temperatura\");\n  }\n  delay(5000);\n}\n</code></pre>"},{"location":"08_sensores/#sensor-de-sonido","title":"Sensor de Sonido","text":"<p>Vamos a realizar un interruptor por aplausos, con dos aplausos se prende y con otros 2 se apaga el led.</p> <p>Diagrama Pict\u00f3rico</p> <p></p> <p></p> <p>C\u00f3digo</p> <pre><code>//C\u00d3DIGO NO PROBADO \n// C\u00d3DIGO PARA EL SENSOR CON SALIDA ANAL\u00d3GICA\n#define MICROPHONE 34\n#define LED 25\nint clap = 0;\nlong detection_range_start = 0;\nlong detection_range = 0;\nboolean status_lights = false;\n\nvoid setup() {\n  pinMode(MICROPHONE, INPUT);\n  pinMode(LED, OUTPUT);\n}\n\nvoid loop() {\n  int status_microphone = digitalRead(MICROPHONE);\n\n  if (status_microphone == 0) {\n    if (clap == 0) {\n      detection_range_start = detection_range = millis();\n      clap++;\n    }\n    else if (clap &gt; 0 &amp;&amp; millis() - detection_range &gt;= 50) {\n      detection_range = millis();\n      clap++;\n    }\n  }\n\n  if (millis() - detection_range_start &gt;= 400) {\n    if (clap == 2) {\n      if (!status_lights) {\n        status_lights = true;\n        digitalWrite(LED, HIGH);\n      }\n      else if (status_lights) {\n        status_lights = false;\n        digitalWrite(LED, LOW);\n      }\n    }\n    clap = 0;\n  }\n}\n</code></pre>"},{"location":"08_sensores/#sensor-de-humedad-de-tierra-higrometro","title":"Sensor de humedad de tierra (Higr\u00f3metro)","text":"<p>Este sensor mide la conductividad de la tierra, es decir, que entre mas seca, menos conduce. Esta medici\u00f3n me esta indicando que har\u00eda falta agua (esto depende de la planta, que tanta agua requiera).</p> <p>Diagrama pict\u00f3rico</p> <p></p> <p>C\u00f3digo</p> <pre><code>#define SENSOR 34\n#define LED 25\n\nvoid setup() {\n  Serial.begin(115200);\n  pinMode(SENSOR, INPUT);\n  pinMode(LED, OUTPUT);\n}\n\nvoid loop() {\n\n  if (humedad == digitalRead(SENSOR)) {\n    Serial.println(\"Tierra seca\");\n    Serial.println(\"Encender bomba\");\n    digitalWrite(LED, HIGH);\n  } else {\n    Serial.println(\"Encender apagada\");\n    digitalWrite(LED, LOW);\n  }\n  delay(1000);\n}\n</code></pre> <p>Diagrama pict\u00f3rico</p> <p></p> <p>C\u00f3digo</p> <pre><code>//Entrada anal\u00f3gica\n#define SENSOR_HUMEDAD 34\n#define LED 25\n\nvoid setup() {\n  Serial.begin(115200);\n  pinMode(LED, OUTPUT);\n}\n\nvoid loop() {\n  int humedad = analogRead(SENSOR_HUMEDAD);\n  Serial.print(humedad);\n\n  if (humedad &lt; 500) {\n    Serial.println(\"Tierra seca\");\n    Serial.println(\"Encender bomba\");\n    digitalWrite(LED, HIGH);\n  }else{\n    Serial.println(\"Encender apagada\");\n    digitalWrite(LED, LOW);\n  }\n\n\n  delay(1000);\n}\n</code></pre>"},{"location":"08_sensores/#sensor-de-gas-lp-mq-2","title":"Sensor de Gas LP (MQ-2)","text":"<p>Vamos a realizar una simple alarma que al detectar una fuga de gas, active una alarma sonora, para alarmar al usuario de dicha fuga.</p> <p>Note</p> <p></p> <p>Diagrama Pict\u00f3rico</p> <p></p> <p>C\u00f3digo</p> <pre><code>#define LED  25\n#define BUZZER  26\n#define SENSOR_GAS 34\n#define LIMIT 1200\n\nvoid setup() {\n  Serial.begin(115200);\n  pinMode(LED, OUTPUT);\n}\nvoid loop() {\n\n  int valor = analogRead(SENSOR_GAS);\n\n  Serial.print(\"Gas Sensor: \");\n  Serial.println(valor);\n\n  if (valor &gt; LIMIT) {\n    Serial.println(\"Fuga de Gas\");\n    digitalWrite (LED, HIGH);\n    digitalWrite (BUZZER, HIGH);\n    delay(250);\n    digitalWrite (LED, LOW);\n    digitalWrite (BUZZER, LOW);\n    delay(250);\n    digitalWrite (LED, HIGH);\n    digitalWrite (BUZZER, HIGH);\n    delay(250);\n    digitalWrite (LED, LOW);\n    digitalWrite (BUZZER, LOW);\n    delay(250);\n    digitalWrite (LED, HIGH);\n    digitalWrite (BUZZER, HIGH);\n    delay(250);\n    digitalWrite (LED, LOW);\n    digitalWrite (BUZZER, LOW);\n    delay(250);\n  }\n  else {\n    Serial.println(\"Sin fuga de Gas\");\n    digitalWrite (LED, HIGH) ;\n    digitalWrite (BUZZER, LOW);\n    delay(1000);\n  }\n}\n</code></pre>"},{"location":"08_sensores/#tarjeta-rfid","title":"Tarjeta RFID","text":"<p>Note</p> <p>Descarga la librer\u00eda, Dar click aqu\u00ed</p> <p>Note</p> <p>. Ver la instalaci\u00f3n manual -&gt; aqu\u00ed</p> <p>Warning</p> <p></p> <p>Note</p> <p>Estas conexiones no pueden cambiar, siempre se debe conectar de esta manera</p> ESP32 &lt;---&gt; RFID 1 3.3V &lt;---&gt; VCC 2 D0 &lt;---&gt; RST 3 GND &lt;---&gt; GND 4 NC &lt;---&gt; IRQ 5 D19 &lt;---&gt; MISO 6 D23 &lt;---&gt; MOSI 7 D18 &lt;---&gt; SCK 8 D5 &lt;---&gt; SDA"},{"location":"08_sensores/#dumpeando-los-datos-de-tarjeta-rfid","title":"Dumpeando los datos de tarjeta RFID","text":"<p>Obteniendo todos los datos de la tarjeta o llavero. Mostrando toda la informaci\u00f3n en el monitor serial.</p> <p>Diagrama Pict\u00f3rico</p> <p></p> <p>C\u00f3digo</p> <pre><code>#include &lt;SPI.h&gt;\n#include &lt;MFRC522.h&gt;\n\n#define RST_PIN   0\n#define SS_PIN    5\n\nMFRC522 mfrc522(SS_PIN, RST_PIN);  // Crea el objeto para el m\u00f3dulo RFID\n\nvoid setup() {\n  Serial.begin(115200);     // Inicializa la comunicaci\u00f3n serial\n\n  SPI.begin();          // Inicia la comunicaci\u00f3n de SPI\n  mfrc522.PCD_Init();   // Inicializa la comunicaci\u00f3n con el modulo\n  delay(4);             // un delay para esperar que se configure correctamente el modulo\n  mfrc522.PCD_DumpVersionToSerial();    // Muestra los detalles del modulo MFRC522\n  Serial.println(F(\"Escaneado el PICC para ver el UID, SAK, tipo, bloque de datos...\"));\n}\n//\nvoid loop() {\n  // Resetea en cada vuelta del ciclo, para leer una una tarjeta.\n  if ( ! mfrc522.PICC_IsNewCardPresent()) {\n    return;\n  }\n\n  // Selecciona una tarjeta\n  if ( ! mfrc522.PICC_ReadCardSerial()) {\n    return;\n  }\n\n  // vuelca la informacion encontrada en la tarjeta\n  mfrc522.PICC_DumpToSerial(&amp;(mfrc522.uid));\n}\n</code></pre>"},{"location":"08_sensores/#leyendo-el-nuid-de-la-tarjeta-rfid","title":"Leyendo el NUID de la tarjeta RFID","text":"<p>Lo que se realiza es leer la tarjeta, si es diferente a la anterior, te muestra su c\u00f3digo en hexadecimal y decimal, en caso que se la misma tarjeta que se vuelve a pasar por el lector, manda el mensaje de <code>tarjeta le\u00edda</code></p> <pre><code>#include &lt;SPI.h&gt;\n#include &lt;MFRC522.h&gt;\n\n#define RST_PIN   0\n#define SS_PIN    5\n\nMFRC522 rfid(SS_PIN, RST_PIN); // crea el objeto para ocupar el lector\n\nMFRC522::MIFARE_Key key; \n\n// inicializa el array donde se almacenara el NUID\nbyte nuidPICC[4];\n\nvoid setup() { \n  Serial.begin(115200);\n  SPI.begin(); // Inicializa el bus para la comunicaci\u00f3n SPI\n  rfid.PCD_Init(); // Inicializa el modulo MFRC522 \n\n  for (byte i = 0; i &lt; 6; i++) {// crea una llave temporal de referencia\n    key.keyByte[i] = 0xFF;\n  }\n\n  Serial.println(F(\"Este es el codigo leido NUID.\"));\n  Serial.print(F(\"Usa la siguiente llave:\"));\n  printHex(key.keyByte, MFRC522::MF_KEY_SIZE);\n  Serial.println(\"\");//solo para dar un enter\n}\n\nvoid loop() {\n\n  // Resetea en cada vuelta del ciclo, para leer una una tarjeta.\n  if ( ! rfid.PICC_IsNewCardPresent())\n    return;\n\n  // Verifica si el NUID ha sido le\u00eddo\n  if ( ! rfid.PICC_ReadCardSerial())\n    return;\n\n  if (rfid.uid.uidByte[0] != nuidPICC[0] || \n    rfid.uid.uidByte[1] != nuidPICC[1] || \n    rfid.uid.uidByte[2] != nuidPICC[2] || \n    rfid.uid.uidByte[3] != nuidPICC[3] ) {\n    Serial.println(F(\"Tarjeta nueva detectada.\"));\n\n    // Almacena el NUID dentro del array\n    for (byte i = 0; i &lt; 4; i++) {\n      nuidPICC[i] = rfid.uid.uidByte[i];\n    }\n\n    Serial.println(F(\"El tag del NUID:\"));\n    Serial.print(F(\"En hex: \"));\n    printHex(rfid.uid.uidByte, rfid.uid.size);\n    Serial.println();\n    Serial.print(F(\"En dec: \"));\n    printDec(rfid.uid.uidByte, rfid.uid.size);\n    Serial.println();\n  }\n  else Serial.println(F(\"Tarjeta ya leida.\"));\n\n  // Con estas 2 funciones se evita que siga leyendo como loco el sensor,\n  // si lo quitas comenzara a leer sin parar\n  // tu decides si es necesario quitarlo\n  // Halt PICC\n  rfid.PICC_HaltA();\n  // Detiene la encriptacion en PCD\n  rfid.PCD_StopCrypto1();\n}\n\n\n/**\n * Ayuda a imprimir los bytes del array en forma hexadecimal. \n */\nvoid printHex(byte *buffer, byte bufferSize) {\n  for (byte i = 0; i &lt; bufferSize; i++) {\n    Serial.print(buffer[i] &lt; 0x10 ? \" 0\" : \" \");\n    Serial.print(buffer[i], HEX);\n  }\n}\n\n/**\n * Ayuda a volcar los bytes del array en forma decimal. \n */\nvoid printDec(byte *buffer, byte bufferSize) {\n  for (byte i = 0; i &lt; bufferSize; i++) {\n    Serial.print(buffer[i] &lt; 0x10 ? \" 0\" : \" \");\n    Serial.print(buffer[i], DEC);\n  }\n}\n</code></pre>"},{"location":"08_sensores/#acceso-autorizado","title":"Acceso autorizado","text":"<p>Este codigo lee la tarjeta e indica si el codigo leido es igual al almacenado. En caso que sea correcto, manda el mensaje <code>ACCESO CORRECTO</code>, de lo contrario <code>Acceso no autorizado</code>.</p> <pre><code>#include &lt;SPI.h&gt;\n#include &lt;MFRC522.h&gt;\n\n#define RST_PIN   0\n#define SS_PIN    5\n\nMFRC522 rfid(SS_PIN, RST_PIN); // crea el objeto para ocupar el lector\n\n// Es la NUID de una tarjeta, aqu\u00ed reempl\u00e1zalo por tu NUID\nbyte nuidPICC[4] = {138, 92, 3, 14};;\n\nvoid setup() {\n  Serial.begin(115200);\n  SPI.begin(); // Inicializa el bus para la comunicaci\u00f3n SPI\n  rfid.PCD_Init(); // Inicializa el modulo MFRC522\n\n}\n\nvoid loop() {\n\n  // Resetea en cada vuelta del ciclo, para leer una una tarjeta.\n  if ( ! rfid.PICC_IsNewCardPresent())\n    return;\n\n  // Verifica si el NUID ha sido le\u00eddo\n  if ( ! rfid.PICC_ReadCardSerial())\n    return;\n\n  //aqu\u00ed verifico que el c\u00f3digo almacenado en la memoria sera igual al de la tarjeta que se esta verificando\n  if (rfid.uid.uidByte[0] != nuidPICC[0] || rfid.uid.uidByte[1] != nuidPICC[1] || rfid.uid.uidByte[2] != nuidPICC[2] || rfid.uid.uidByte[3] != nuidPICC[3] ) {\n    Serial.println(F(\"ACCESO CORRECTO\"));\n\n  }\n  else Serial.println(F(\"Acceso no autorizado\"));\n\n  // Con estas 2 funciones se evita que siga leyendo como loco el sensor,\n  // si lo quitas comenzara a leer sin parar\n  // tu decides si es necesario quitarlo\n  // Halt PICC\n  rfid.PICC_HaltA();\n  // Detiene la encriptaci\u00f3n en PCD\n  rfid.PCD_StopCrypto1();\n}\n</code></pre>"},{"location":"09_screen/","title":"Pantallas","text":""},{"location":"09_screen/#pantalla-lcd-con-comunicacion-i2c","title":"Pantalla LCD con comunicaci\u00f3n I<sup>2</sup>C","text":"<p>La pantalla LCD es una pantalla de cristal liquido, su controlador mas com\u00fan es el HD44780, su comunicaci\u00f3n puede ser de 4 bits u 8 bits. Dado que si nos comunicamos con 8 bits, implica usar 8 pines del microcontrolador, o en su defecto si usamos la comunicaci\u00f3n de 4 bits, se usar\u00edan 4 pines, y en ocasiones dependiendo del microcontrolador, no nos podemos dar el lujo de usar tantos, surgi\u00f3 un modulo de comunicaci\u00f3n I<sup>2</sup>C, que implica solo usar 2 pines para el control total de toda la pantalla.</p> <p></p> <p>Los tama\u00f1os mas comunes de pantalla son </p> <ul> <li>16x2: 16 caracteres de forma horizontal y 2 renglones</li> <li>20x4: 20 caracteres de forma horizontal y 4 renglones</li> </ul> <p></p> <p>El control es exactamente igual, obviamente se debe especificar en que sitio se colocara el car\u00e1cter.</p> <p>Cada car\u00e1cter esta formado de 5x7 pixels, es decir, podemos dar la forma o figura que quisi\u00e9ramos por cada car\u00e1cter y hacer combinaciones infinitas (inclusive hacer juegos)</p> <p></p> <p>La comunicaci\u00f3n I<sup>2</sup>C nos reduce el uso de pines, pero esto incrementa el uso de mas hardware o librer\u00edas para implementar el protocolo.</p> <p></p> <p>El controlador es el PCF8574 el encargado de recibir la informaci\u00f3n y comunicarla al microcontrolador de la LCD, realizando las acciones que enviamos por el protocolo.</p> <p></p> <p>En la comunicaci\u00f3n I<sup>2</sup>C es un protocolo tipo Maestro-Esclavo, y cada esclavo tiene un ID \u00fanico (direcci\u00f3n), para saber a que dispositivo le estamos solicitando la informaci\u00f3n y de quien estamos recibiendo.</p> <p>Al igual en este modulo incorpora un trimpot para ajustar el contraste de la pantalla, el jumper para el brillo de la pantalla y el selector de direcci\u00f3n (es la modificaci\u00f3n de una resistencia)</p> <p></p>"},{"location":"09_screen/#referencias","title":"Referencias","text":"<p>https://naylampmechatronics.com/oled/638-display-oled-i2c-130-12864-sh1106.html</p>"},{"location":"09_screen/#pines-de-la-lcd-con-i2c","title":"Pines de la LCD con I<sup>2</sup>C","text":"<p>Warning</p> <p>Los pines a los que se conectan los pines de <code>SDA</code> y <code>SCL</code> de la pantalla Iran a:</p> LCD ESP32 SDA GPIO21 SCL GPIO22 VCC 5V GND GND <p>]</p> <p>Warning</p> <p>Descargar la librer\u00eda para poder comunicar el ESP32 con el m\u00f3dulo I<sup>2</sup>C. Agregarla a Arduino IDE. Dar click aqu\u00ed</p> <p>Note</p> <p>Si al arrancar la pantalla no se ve nada, recuerda mover el tripot para el contraste.</p>"},{"location":"09_screen/#algoritmos-de-encendido-de-pantalla","title":"Algoritmos de encendido de pantalla","text":"<p>Estos son los pasos que siempre Iran al inicio para arrancar la pantalla.</p> <ol> <li>Funci\u00f3n <code>begin()</code>: Solo se llama al inicio para arrancar la pantalla</li> <li>Funci\u00f3n <code>backlight()</code>: Enciende la luz de fondo (depende si quieres prenderla)</li> <li>Funci\u00f3n <code>clear()</code>: Limpia la pantalla de cualquier ruido o car\u00e1cter raro que salga en pantalla</li> <li>Funci\u00f3n <code>setCursor(column, row)</code> </li> </ol> <p>Ya posicionados, podemos comenzar a escribir el mensaje en pantalla.</p> <p>https://lastminuteengineers.com/esp32-i2c-lcd-tutorial/</p>"},{"location":"09_screen/#visualizacion-de-mensaje","title":"Visualizaci\u00f3n de mensaje","text":"<p>Se mandara un mensaje a la pantalla, l\u00ednea por l\u00ednea.</p> <p>Diagrama Pict\u00f3rico</p> <p></p> <p></p> <pre><code>#include &lt;Wire.h&gt;\n#include &lt;LiquidCrystal_I2C.h&gt;\n\n// Set the LCD address to 0x27 for a 16 chars and 2 line display\nLiquidCrystal_I2C lcd(0x27, 16, 2);\n\nvoid setup()\n{\n  // inicializamos la pantalla para comunicaci\u00f3n \n  lcd.begin();\n  // Enciende la luz de fondo pantalla\n  lcd.backlight();\n  //Por default comenzar\u00e1 a escribir en la posici\u00f3n x=0,y=0\n  //se manda el siguiente texto a la pantalla\n  lcd.print(\"Mecatronica 85\"); //no se ponen acentos \n  //Nos movemos al segundo rengl\u00f3n, en la primera posici\u00f3n\n  lcd.setCursor(0, 1);\n  //se manda el siguiente texto a la pantalla\n  lcd.print(\"Rules\");\n}\n\nvoid loop()\n{\n  // Aqu\u00ed no colocamos nada\n}\n</code></pre>"},{"location":"09_screen/#voltimetro","title":"Volt\u00edmetro","text":"<p>Realizaremos un volt\u00edmetro sencillo y b\u00e1sico, donde vamos a leer el voltaje de un divisor de tension.</p> <p>Para ello debemos aplicar una formula donde vamos a convertir el valor que se recibe del ADC a un valor equivalente de voltaje, como tenemos un potenci\u00f3metro lineal, la relaci\u00f3n es directa, quedando la formula</p> \\[voltaje = ADC_{bit} \\frac{3.3V}{4095_{bit}}\\] <p>Con esta formula estamos convirtiendo lo que recibimos en la entrada del ADC a lo correspondiente de voltaje.</p> <p>Como el valor m\u00e1ximo de voltaje es 3.3V, esto se divide entre la resoluci\u00f3n del ADC y lo multiplicamos por el valor le\u00eddo.</p> <p>Diagrama pict\u00f3rico</p> <p></p> <p> <p></p> <p></p> <p>C\u00f3digo b\u00e1sico</p> <pre><code>#include &lt;Wire.h&gt;\n#include &lt;LiquidCrystal_I2C.h&gt;\n\n// Set the LCD address to 0x27 for a 16 chars and 2 line display\nLiquidCrystal_I2C lcd(0x27, 16, 2);\n#define PIN_ADC 34\n\n\nvoid setup(){\n  // inicializamos la pantalla para comunicaci\u00f3n \n  lcd.begin();\n  // Enciende la luz de fondo pantalla\n  lcd.backlight();\n  //Por default comenzar\u00e1 a escribir en la posici\u00f3n x=0,y=0\n  //se manda el siguiente texto a la pantalla\n  lcd.print(\"Mecatronica 85\");\n  //Nos movemos al segundo rengl\u00f3n, en la primera posici\u00f3n\n  lcd.setCursor(0, 1);\n  //se manda el siguiente texto a la pantalla\n  lcd.print(\"Voltimetro\");\n  delay(1000); //esperamos un segundo para el mensaje de bienvenida\n  lcd.clear(); //limpiamos la pantalla\n  lcd.setCursor(0,0); //regresamos a la posici\u00f3n inicial\n  lcd.print(\"Voltimetro 85\");\n  lcd.setCursor(15,1);  //nos movemos a la columna 15 y la ultima posici\u00f3n\n  lcd.print(\"V\"); //colocamos la unidad del voltaje (V)\n}\n\nvoid loop(){\n  int valorADC = analogRead(PIN_ADC);\n  delay(10); //esperamos un momento de estabilizaci\u00f3n del dato\n  float voltaje = (valorADC * 3.3) / 4095.0; //convertimos el valor a voltaje\n  lcd.setCursor(11,1); //nos colocamos en la parte para que el numero salga al final al lado de la \"V\"\n  lcd.print(voltaje);\n  delay(50);\n}\n</code></pre> <p>C\u00f3digo m\u00e1s estable</p> <p>Este c\u00f3digo es m\u00e1s eficiente para tener una valor m\u00e1s estable. Aplicamos un promedio de la muestra. Con esto hacemos que el valor que se muestra se m\u00e1s conciso.</p> <pre><code>#include &lt;Wire.h&gt;\n#include &lt;LiquidCrystal_I2C.h&gt;\n\n// Set the LCD address to 0x27 for a 16 chars and 2 line display\nLiquidCrystal_I2C lcd(0x27, 16, 2);\n#define PIN_ADC 34\n\n\nvoid setup() {\n  // inicializamos la pantalla para comunicaci\u00f3n\n  lcd.begin();\n  // Enciende la luz de fondo pantalla\n  lcd.backlight();\n  //Por default comenzar\u00e1 a escribir en la posici\u00f3n x=0,y=0\n  //se manda el siguiente texto a la pantalla\n  lcd.print(\"Mecatronica 85\");\n  //Nos movemos al segundo rengl\u00f3n, en la primera posici\u00f3n\n  lcd.setCursor(0, 1);\n  //se manda el siguiente texto a la pantalla\n  lcd.print(\"Voltimetro\");\n  delay(1000); //esperamos un segundo para el mensaje de bienvenida\n  lcd.clear(); //limpiamos la pantalla\n  lcd.setCursor(0, 0); //regresamos a la posici\u00f3n inicial\n  lcd.print(\"Voltimetro 85\");\n  lcd.setCursor(15, 1); //nos movemos a la columna 15 y la ultima posici\u00f3n\n  lcd.print(\"V\"); //colocamos la unidad del voltaje (V)\n}\n\n#define MUESTRAS 60.0 // defino una cantidad de muestras que se tomaran para el promedio\n\nvoid loop() {\n  int valorADC = 0;     //aqu\u00ed guardaremos el valor del ADC\n  int suma = 0;         //acumulara el valor de las muestras del ADC\n  for (byte x = 0; x &lt; MUESTRAS; x++) {\n    valorADC = analogRead(PIN_ADC);\n    suma += valorADC;\n    delay(5); //esperamos un momento de estabilizaci\u00f3n del dato\n  }\n  float promedio = suma / MUESTRAS;\n  float voltaje = (valorADC * 3.3) / 4095.0; //convertimos el valor a voltaje\n  lcd.setCursor(11, 1); //nos colocamos en la parte para que el numero salga al final al lado de la \"V\"\n  lcd.print(voltaje);\n\n}\n</code></pre>"},{"location":"09_screen/#oled","title":"OLED","text":"<p>Las pantalla OLED se han popularizado mucho \u00faltimamente, y gracias a Adafruit se ha economizado mucho.</p> <p>Nos da una amplia gama de aplicaci\u00f3n en diversas situaciones, como realizar estaciones meteorol\u00f3gicas, un contador para nuestros suscriptores de YT, juegos, etc.</p> <p></p> <p></p> <p>Contamos con 2 drivers, los mas comunes son:</p> <ul> <li>SSD1306</li> <li>SH110X</li> </ul> <p>Con dos protocolos, estos son</p> <ul> <li>I<sup>2</sup>C</li> <li>SPI</li> </ul> <p>Note</p> <p>Aqu\u00ed debes probar en caso de no conocer cual es el driver de tuu pantalla OLED, en mi caso tengo con driver: SH110X con I<sup>2</sup>C</p> <p>Warning</p> <p>Los pines a los que se conectan los pines de <code>SDA</code> y <code>SCL</code> de la pantalla Iran a:</p> OLED ESP32 SDA GPIO21 SCL GPIO22 VDD 3V3 GND GND <p></p> <p>Warning</p> <p>Las librer\u00edas que se necesitan son varias, si estas con el gestor e instalar en la carpeta de <code>librer\u00edas</code> del IDE de Arduino. Descargar aqu\u00ed y las agregamos de manera manual. Ver la instalaci\u00f3n manual -&gt; aqu\u00ed</p>  Instalando desde el Gestor de librer\u00edas <p>Buscamos por \"oled\" e instalamos las siguientes e instalamos las librer\u00edas adiciones</p> <p></p> <p></p> <p></p>"},{"location":"09_screen/#convertidores-de-imagenes-para-la-pantalla","title":"Convertidores de im\u00e1genes para la pantalla","text":"<ul> <li>image2cpp [web]</li> </ul> <ul> <li>LCD Image Converter [Desktop]</li> </ul> <p>Descargar</p> <p>Para conocer mas, ingresa a la documentaci\u00f3n oficial de Adafruit</p>"},{"location":"09_screen/#assets","title":"Assets","text":"<p>La imagen demo que sale al inicio</p> <p></p> <p></p> <p></p> <p></p>"},{"location":"09_screen/#codigo-demo-de-la-oled","title":"C\u00f3digo DEMO de la OLED","text":"<p>Se realizara demo simple de uso de la pantalla OLED</p> <p>Diagrama Pict\u00f3rico</p> <p></p> <p></p> <pre><code>// Para la pantalla SH110X\n#include &lt;SPI.h&gt;\n#include &lt;Wire.h&gt;\n#include &lt;Adafruit_GFX.h&gt;\n#include &lt;Adafruit_SH110X.h&gt;\n\n#define i2c_Address 0x3c //initialize with the I2C addr 0x3C Typically eBay OLED's\n//#define i2c_Address 0x3d //initialize with the I2C addr 0x3D Typically Adafruit OLED's\n\n#define SCREEN_WIDTH 128 // OLED display width, in pixels\n#define SCREEN_HEIGHT 64 // OLED display height, in pixels\n#define OLED_RESET -1   //   QT-PY / XIAO\nAdafruit_SH1106G display = Adafruit_SH1106G(SCREEN_WIDTH, SCREEN_HEIGHT, &amp;Wire, OLED_RESET);\n\n\n#define NUMFLAKES 10\n#define XPOS 0\n#define YPOS 1\n#define DELTAY 2\n\n\n#define LOGO16_GLCD_HEIGHT 16\n#define LOGO16_GLCD_WIDTH  16\nstatic const unsigned char PROGMEM logo16_glcd_bmp[] = {\n  0x06, 0x60,\n  0x06, 0x60,\n  0x3f, 0xfc,\n  0x20, 0x04,\n  0x20, 0x04,\n  0xee, 0x77,\n  0xea, 0x47,\n  0x2a, 0x44,\n  0x2e, 0x74,\n  0xea, 0x17,\n  0xea, 0x17,\n  0x2e, 0x74,\n  0x20, 0x04,\n  0x3f, 0xfc,\n  0x06, 0x60,\n  0x06, 0x60\n};\n\n\nvoid setup()   {\n\n  Serial.begin(115200);\n\n  delay(250); // wait for the OLED to power up\n  display.begin(i2c_Address, true); // Address 0x3C default\n  //display.setContrast (0); // dim display\n\n  display.display();\n  delay(2000);\n\n  // limpia la pantalla\n  display.clearDisplay();\n\n  // dibuja un pixel\n  display.drawPixel(10, 10, SH110X_WHITE);\n  // Show the display buffer on the hardware.\n  // NOTE: You _must_ call display after making any drawing commands\n  // to make them visible on the display hardware!\n  display.display();\n  delay(2000);\n  display.clearDisplay();\n\n  // dibuja muchas lineas\n  testdrawline();\n  display.display();\n  delay(2000);\n  display.clearDisplay();\n\n  // dibuja rectangulos\n  testdrawrect();\n  display.display();\n  delay(2000);\n  display.clearDisplay();\n\n  // dibuja multiples rectangulos\n  testfillrect();\n  display.display();\n  delay(2000);\n  display.clearDisplay();\n\n  // dibuja multiples circulos\n  testdrawcircle();\n  display.display();\n  delay(2000);\n  display.clearDisplay();\n\n  // dibuja un circulo de 10px de radio SH110X_WHITE\n  display.fillCircle(display.width() / 2, display.height() / 2, 10, SH110X_WHITE);\n  display.display();\n  delay(2000);\n  display.clearDisplay();\n\n  testdrawroundrect();\n  delay(2000);\n  display.clearDisplay();\n\n  testfillroundrect();\n  delay(2000);\n  display.clearDisplay();\n\n  testdrawtriangle();\n  delay(2000);\n  display.clearDisplay();\n\n  testfilltriangle();\n  delay(2000);\n  display.clearDisplay();\n\n  // dibuja las primeras 12 letras en una fuente\n  testdrawchar();\n  display.display();\n  delay(2000);\n  display.clearDisplay();\n\n  // Muestra texto\n  display.setTextSize(1);\n  display.setTextColor(SH110X_WHITE);\n  display.setCursor(0, 0);\n  display.println(\"Failure is always an option\");\n  display.setTextColor(SH110X_BLACK, SH110X_WHITE); // 'inverted' text\n  display.println(3.141592);\n  display.setTextSize(2);\n  display.setTextColor(SH110X_WHITE);\n  display.print(\"0x\"); display.println(0xDEADBEEF, HEX);\n  display.display();\n  delay(2000);\n  display.clearDisplay();\n\n  // muestra la imagen (logo)\n  display.drawBitmap(30, 16,  logo16_glcd_bmp, 16, 16, 1);\n  display.display();\n  delay(1);\n\n  // invierte el color del display\n  display.invertDisplay(true);\n  delay(1000);\n  display.invertDisplay(false);\n  delay(1000);\n  display.clearDisplay();\n\n  // dibuja el icono bitmap en un movimiento animado\n  testdrawbitmap(logo16_glcd_bmp, LOGO16_GLCD_HEIGHT, LOGO16_GLCD_WIDTH);\n}\n\n\nvoid loop() {\n\n}\n\n\nvoid testdrawbitmap(const uint8_t *bitmap, uint8_t w, uint8_t h) {\n  uint8_t icons[NUMFLAKES][3];\n\n  // initialize\n  for (uint8_t f = 0; f &lt; NUMFLAKES; f++) {\n    icons[f][XPOS] = random(display.width());\n    icons[f][YPOS] = 0;\n    icons[f][DELTAY] = random(5) + 1;\n\n    Serial.print(\"x: \");\n    Serial.print(icons[f][XPOS], DEC);\n    Serial.print(\" y: \");\n    Serial.print(icons[f][YPOS], DEC);\n    Serial.print(\" dy: \");\n    Serial.println(icons[f][DELTAY], DEC);\n  }\n\n  while (1) {\n    // draw each icon\n    for (uint8_t f = 0; f &lt; NUMFLAKES; f++) {\n      display.drawBitmap(icons[f][XPOS], icons[f][YPOS], bitmap, w, h, SH110X_WHITE);\n    }\n    display.display();\n    delay(200);\n\n    // then erase it + move it\n    for (uint8_t f = 0; f &lt; NUMFLAKES; f++) {\n      display.drawBitmap(icons[f][XPOS], icons[f][YPOS], bitmap, w, h, SH110X_BLACK);\n      // move it\n      icons[f][YPOS] += icons[f][DELTAY];\n      // if its gone, reinit\n      if (icons[f][YPOS] &gt; display.height()) {\n        icons[f][XPOS] = random(display.width());\n        icons[f][YPOS] = 0;\n        icons[f][DELTAY] = random(5) + 1;\n      }\n    }\n  }\n}\n\n\nvoid testdrawchar(void) {\n  display.setTextSize(1);\n  display.setTextColor(SH110X_WHITE);\n  display.setCursor(0, 0);\n\n  for (uint8_t i = 0; i &lt; 168; i++) {\n    if (i == '\\n') continue;\n    display.write(i);\n    if ((i &gt; 0) &amp;&amp; (i % 21 == 0))\n      display.println();\n  }\n  display.display();\n  delay(1);\n}\n\nvoid testdrawcircle(void) {\n  for (int16_t i = 0; i &lt; display.height(); i += 2) {\n    display.drawCircle(display.width() / 2, display.height() / 2, i, SH110X_WHITE);\n    display.display();\n    delay(1);\n  }\n}\n\nvoid testfillrect(void) {\n  uint8_t color = 1;\n  for (int16_t i = 0; i &lt; display.height() / 2; i += 3) {\n    // alternate colors\n    display.fillRect(i, i, display.width() - i * 2, display.height() - i * 2, color % 2);\n    display.display();\n    delay(1);\n    color++;\n  }\n}\n\nvoid testdrawtriangle(void) {\n  for (int16_t i = 0; i &lt; min(display.width(), display.height()) / 2; i += 5) {\n    display.drawTriangle(display.width() / 2, display.height() / 2 - i,\n                         display.width() / 2 - i, display.height() / 2 + i,\n                         display.width() / 2 + i, display.height() / 2 + i, SH110X_WHITE);\n    display.display();\n    delay(1);\n  }\n}\n\nvoid testfilltriangle(void) {\n  uint8_t color = SH110X_WHITE;\n  for (int16_t i = min(display.width(), display.height()) / 2; i &gt; 0; i -= 5) {\n    display.fillTriangle(display.width() / 2, display.height() / 2 - i,\n                         display.width() / 2 - i, display.height() / 2 + i,\n                         display.width() / 2 + i, display.height() / 2 + i, SH110X_WHITE);\n    if (color == SH110X_WHITE) color = SH110X_BLACK;\n    else color = SH110X_WHITE;\n    display.display();\n    delay(1);\n  }\n}\n\nvoid testdrawroundrect(void) {\n  for (int16_t i = 0; i &lt; display.height() / 2 - 2; i += 2) {\n    display.drawRoundRect(i, i, display.width() - 2 * i, display.height() - 2 * i, display.height() / 4, SH110X_WHITE);\n    display.display();\n    delay(1);\n  }\n}\n\nvoid testfillroundrect(void) {\n  uint8_t color = SH110X_WHITE;\n  for (int16_t i = 0; i &lt; display.height() / 2 - 2; i += 2) {\n    display.fillRoundRect(i, i, display.width() - 2 * i, display.height() - 2 * i, display.height() / 4, color);\n    if (color == SH110X_WHITE) color = SH110X_BLACK;\n    else color = SH110X_WHITE;\n    display.display();\n    delay(1);\n  }\n}\n\nvoid testdrawrect(void) {\n  for (int16_t i = 0; i &lt; display.height() / 2; i += 2) {\n    display.drawRect(i, i, display.width() - 2 * i, display.height() - 2 * i, SH110X_WHITE);\n    display.display();\n    delay(1);\n  }\n}\n\nvoid testdrawline() {\n  for (int16_t i = 0; i &lt; display.width(); i += 4) {\n    display.drawLine(0, 0, i, display.height() - 1, SH110X_WHITE);\n    display.display();\n    delay(1);\n  }\n  for (int16_t i = 0; i &lt; display.height(); i += 4) {\n    display.drawLine(0, 0, display.width() - 1, i, SH110X_WHITE);\n    display.display();\n    delay(1);\n  }\n  delay(250);\n\n  display.clearDisplay();\n  for (int16_t i = 0; i &lt; display.width(); i += 4) {\n    display.drawLine(0, display.height() - 1, i, 0, SH110X_WHITE);\n    display.display();\n    delay(1);\n  }\n  for (int16_t i = display.height() - 1; i &gt;= 0; i -= 4) {\n    display.drawLine(0, display.height() - 1, display.width() - 1, i, SH110X_WHITE);\n    display.display();\n    delay(1);\n  }\n  delay(250);\n\n  display.clearDisplay();\n  for (int16_t i = display.width() - 1; i &gt;= 0; i -= 4) {\n    display.drawLine(display.width() - 1, display.height() - 1, i, 0, SH110X_WHITE);\n    display.display();\n    delay(1);\n  }\n  for (int16_t i = display.height() - 1; i &gt;= 0; i -= 4) {\n    display.drawLine(display.width() - 1, display.height() - 1, 0, i, SH110X_WHITE);\n    display.display();\n    delay(1);\n  }\n  delay(250);\n\n  display.clearDisplay();\n  for (int16_t i = 0; i &lt; display.height(); i += 4) {\n    display.drawLine(display.width() - 1, 0, 0, i, SH110X_WHITE);\n    display.display();\n    delay(1);\n  }\n  for (int16_t i = 0; i &lt; display.width(); i += 4) {\n    display.drawLine(display.width() - 1, 0, i, display.height() - 1, SH110X_WHITE);\n    display.display();\n    delay(1);\n  }\n  delay(250);\n}\n</code></pre>"},{"location":"09_screen/#voltimetro_1","title":"Volt\u00edmetro","text":"<p>Realizaremos un volt\u00edmetro sencillo y b\u00e1sico, donde vamos a leer el voltaje de un divisor de tension.</p> <p>Para ello debemos aplicar una formula donde vamos a convertir el valor que se recibe del ADC a un valor equivalente de voltaje, como tenemos un potenci\u00f3metro lineal, la relaci\u00f3n es directa, quedando la formula</p> \\[voltaje = ADC_{bit} \\frac{3.3V}{4095_{bit}}\\] <p>Con esta formula estamos convirtiendo lo que recibimos en la entrada del ADC a lo correspondiente de voltaje.</p> <p>Como el valor m\u00e1ximo de voltaje es 3.3V, esto se divide entre la resoluci\u00f3n del ADC y lo multiplicamos por el valor le\u00eddo.</p> <p>Haciendo uso de una pantalla OLED para mostrar le valor en la pantalla.</p> <p>Diagrama pict\u00f3rico</p> <p></p> <p></p> <p>C\u00f3digo</p> <pre><code>#include &lt;SPI.h&gt;\n#include &lt;Wire.h&gt;\n#include &lt;Adafruit_GFX.h&gt;\n#include &lt;Adafruit_SH110X.h&gt;\n\n#define i2c_Address 0x3c //inicializa la comunicaci\u00f3n con el I2C con la direcci\u00f3n 0x3C.\n//#define i2c_Address 0x3d // inicializa la comunicaci\u00f3n con el I2C con la direcci\u00f3n 0x3D.\n\n#define SCREEN_WIDTH 128 // OLED ancho del display, en pixels\n#define SCREEN_HEIGHT 64 // OLED alto del display, en pixels\n#define OLED_RESET -1   //   QT-PY / XIAO\nAdafruit_SH1106G display = Adafruit_SH1106G(SCREEN_WIDTH, SCREEN_HEIGHT, &amp;Wire, OLED_RESET);\n\n#define PIN_ADC 34\n\nvoid setup()   {\n  ////NO MODIFICAR\n  Serial.begin(115200);\n  delay(250); // wait for the OLED to power up\n  display.begin(i2c_Address, true); // Address 0x3C default\n  //display.setContrast (0); // dim display\n  display.display();\n  delay(2000);\n  display.clearDisplay();\n  ////NO MODIFICAR\n\n  // text display tests\n  display.setTextSize(2);\n  display.setTextColor(SH110X_WHITE);\n  display.setCursor(0, 0);\n  display.println(\"Voltimetro\");\n  display.display();\n  delay(2000);\n  display.clearDisplay();\n\n}\n\n#define MUESTRAS 60.0 // defino una cantidad de muestras que se tomaran para el promedio\n\nvoid loop() {\n\n  int valorADC = 0;     //aqu\u00ed guardaremos el valor del ADC\n  int suma = 0;         //acumulara el valor de las muestras del ADC\n  for (byte x = 0; x &lt; MUESTRAS; x++) {\n    valorADC = analogRead(PIN_ADC);\n    suma += valorADC;\n    delay(5); //esperamos un momento de estabilizaci\u00f3n del dato\n  }\n  float promedio = suma / MUESTRAS;\n  float voltaje = (valorADC * 3.3) / 4095.0; //convertimos el valor a voltaje\n\n  display.setTextSize(2);\n  display.setTextColor(SH110X_WHITE);\n  display.clearDisplay();\n  display.setCursor(0, 0);\n  display.print(\"Voltimetro\");\n  display.setCursor(SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2);\n  display.print(voltaje);\n  display.println(\"V\");\n  display.display();\n}\n</code></pre>"},{"location":"100_tools_port/","title":"Herramientas de comunicaci\u00f3n serial","text":""},{"location":"100_tools_port/#putty","title":"PuTTY","text":"<p>Ir al sitio</p>"},{"location":"100_tools_port/#cutecom","title":"CuteCOM","text":"<p>Ir al sitio</p>"},{"location":"Referencias/","title":"Referencias","text":"<ul> <li>https://cplusplus.com/reference/</li> <li>https://docs.espressif.com/projects/arduino-esp32/en/latest/getting_started.html</li> <li>https://docs.espressif.com/projects/esp-idf/en/latest/esp32/hw-reference/esp32/get-started-devkitc.html#get-started-esp32-devkitc-board-front</li> <li>Datasheet</li> </ul>"},{"location":"instalacion_manual/","title":"Instalaci\u00f3n manual de librer\u00edas","text":""},{"location":"instalacion_manual/#arduino-ide-18x","title":"Arduino IDE 1.8.x","text":"<ol> <li>Descargar la librer\u00eda en cuesti\u00f3n a tu almacenamiento local </li> <li>Ir al men\u00fa Sketch &gt; Incluir librer\u00eda &gt; Agregar librer\u00eda .ZIP </li> <li>Buscamos nuestra librer\u00eda en formato <code>.zip</code>, damos <code>Ok</code> </li> <li>Vemos el mensaje de que la instalaci\u00f3n de la librer\u00eda fue exitosa     </li> <li>Verificamos en los ejemplos y compilamos alguno para saber que todo este bien     </li> </ol>"},{"location":"instalacion_manual/#arduino-ide-2x","title":"Arduino IDE 2.x","text":"<ol> <li> <p>Descargar la librer\u00eda en cuesti\u00f3n a tu almacenamiento local </p> </li> <li> <p>Abrir tu editor Arduino IDE 2.x     Sketch &gt; Agregar librer\u00eda &gt; agregar librer\u00eda ZIP     </p> </li> <li> <p>Seleccionar el archivo en donde lo tengamos guardado     </p> </li> <li> <p>Aceptamos agregarla     </p> </li> <li> <p>Observamos el log con el mensaje de \"Librer\u00eda instalada\"     </p> </li> <li> <p>Verificamos que se haya instalado correctamente con alg\u00fan ejemplo, compilamos para ello     </p> </li> </ol>"},{"location":"lista_de_materiales/","title":"Lista de materiales","text":""},{"location":"lista_de_materiales/#individual","title":"Individual","text":"<ul> <li>1 Placa ESP32-WROOM-\u00ad32 (ESP32-DevKitC V4) (con su cable usb)</li> <li>5 LEDs de diferentes colores</li> <li>5 Resistencias de 330, 1/4W</li> <li>5 Resistencias de 1k, 1/4W</li> <li>5 push button</li> <li>1 buzzer (mini) activo</li> <li>1 display de 7 segmentos (c\u00e1todo com\u00fan de preferencia)</li> <li>1 LED RGB (c\u00e1todo com\u00fan de preferencia)</li> <li>1 potenci\u00f3metro de 1k</li> <li>5 LDR con una Resistencias de 10k</li> </ul>"},{"location":"lista_de_materiales/#por-equipo","title":"Por equipo","text":"<ul> <li>Motor DC (de m\u00e1ximo 6V)</li> <li>Driver para motor DC, puente H (modulo L298)</li> <li>Fuente de 5V de m\u00ednimo 2A</li> <li>1 Motor PAP con su driver</li> <li>1 Modulo de relay de 5V (con el sencillo esta bien, pero de preferencia el doble)</li> <li>1 Servo motor SG90 </li> <li>1 teclado matricial de 4x4 (tambi\u00e9n puede ser de 3x4)</li> <li>1 Sensor de flama (Modulo Ky-026), con salida digital y anal\u00f3gica</li> <li>1 Sensor de presencia (PIR HC-SR501)</li> <li>1 Sensor DTH11 (humedad y temperatura)</li> <li>1 Sensor Ultrasonico</li> <li>1 Sensor DS18B20 (preferiblemente la sonda)</li> <li>1 Pantalla LCD con modulo de comunicaci\u00f3n I2C</li> <li>1 Modulo de lector RFID MFRC522 con una tarjeta o llavero</li> </ul>"},{"location":"simuladores/","title":"Simuladores","text":"<p>Para la simulaci\u00f3n del ESP32, tenemos algunas opciones, sin embargo, siempre de manera f\u00edsica sera mucho mejor.</p>"},{"location":"simuladores/#wokwi","title":"Wokwi","text":"<p>Es una simulador web para diversas plataformas, lenguajes, placas, microcontroladores.</p> <p></p>"},{"location":"simuladores/#picsimlab","title":"PicSimLab","text":"<p>Este simulador se basa en puros proyectos open source, los puedes compilar para cada plataforma. </p> <p>Tiene una version Web (pero es super lenta y pesada, esperemos en un futuro mejore). click aqu\u00ed, picsimlab web</p> <p></p>"}]}